{"componentChunkName":"component---src-templates-blog-list-template-js","path":"/","result":{"data":{"site":{"siteMetadata":{"title":"아웃풋 트레이닝","description":"Frontend Software Engineer"}},"posts":{"edges":[{"node":{"excerpt":"2023년 상반기동안 쓴 글들을 회고해보니, 다양한 한계를 극복해 나아가기 위해, 실제 업무 상황에서 겪는 다양한 문제들과 그 해결 과정을 담은 글을 쓰려고 노력하였다.","timeToRead":2,"frontmatter":{"title":"기술 공식 문서에는 없는 현업 개발자의 실질적 문제 해결의 글쓰기","type":null,"tags":["retrospective"],"language":null,"slug":"post/52/","hero":"/assets/images/basic/001.png","cover":null}}},{"node":{"excerpt":"코드를 커밋할 때마다 '내 코드의 변경 사이즈는 얼마나 될까?'라는 고민이 있다면 이번 글이 도움이 될 것이다. 리뷰어라면 너무 큰 Merge Review/PR로 인해 부담을 느낀 적이 있을 것이다. 그래서 이번 편에서는 Git 변경 사항의 크기를 미리 확인할 수 있는 자동화 스크립트를 소개한다. 이를 통해 자신 혹은 팀차원에서 효율적인 커밋 관리 방법을 만들어가보자. ","timeToRead":2,"frontmatter":{"title":"git stat를 이용하여 코드 리뷰 요청 전 커밋 사이즈 관리하기","type":null,"tags":["git","Git Alias","shell script"],"language":null,"slug":"post/51/","hero":"/assets/images/post/2023/2023_051_000.gif","cover":null}}},{"node":{"excerpt":"유형에 따라 갖는 프로퍼티가 다른 경우 Optional Property를 만들어서 불확실한 타입체크를 주기보다는 Dsicriminated Union을 활용한 타입스크립트로 확장성있는 타입을 만들어보자.","timeToRead":2,"frontmatter":{"title":"TypeScript의 강력함: Discriminated Union과 as const 활용하기","type":null,"tags":["typescript"],"language":null,"slug":"post/50/","hero":"/assets/images/post/2023/2023_045_000.png","cover":null}}},{"node":{"excerpt":"최근 회사에서 N년 이상 성숙된 프로젝트의 npm registry를 사내 registry로 변경하는 업무를 진행했다. 정석대로 프로젝트내 npm registry를 변경하고 npm i로 package-lock.json 을 재생성했지만 의존성 변경으로 인해 코드 수정이 필요할 수 밖에 없었다. 이를 어떻게 해결했는지 그 과정을 소개한다. ","timeToRead":3,"frontmatter":{"title":"설치된 라이브러리가 많은 프로젝트의 npm registry 변경하기 with package-lock.json 이해","type":null,"tags":["npm","npm registry","package.json"],"language":null,"slug":"post/49/","hero":"/assets/images/post/2023/2023_049_000.png","cover":null}}},{"node":{"excerpt":"Array.prototype.reduce를 이용한 방식과 Promise.all/Promise.allSettled 방식은 프로미스 처리에 있어 중요한 차이점을 가지고 있다. 어떤 방식을 선택할지 결정하기 전에 각 방식의 특성을 이해하고 사용 사례를 고려해야 한다.","timeToRead":2,"frontmatter":{"title":"Promise를 이용한 비동기 순차 처리와 병렬 처리 핸들하기","type":null,"tags":["javascript","promise"],"language":null,"slug":"post/48/","hero":"/assets/images/post/2021/2021_035.png","cover":null}}},{"node":{"excerpt":"Yarn PnP를 적용하여 개발중인 프로젝트에서 eslint 적용하려고 하니 다음과 같은 오류가 발생했다.  원인 Yarn PnP는 기존 npm을 이용한 패키지와 종속성 관리 방식이 다르기 때문이다. PnP(Plug'n'Play…","timeToRead":1,"frontmatter":{"title":"Yarn PnP 사용시 IntelliJ에서 ESLint 적용하기","type":null,"tags":["yarn","yarn pnp","eslint"],"language":null,"slug":"post/47/","hero":"/assets/images/post/2023/2023_047_000.png","cover":null}}},{"node":{"excerpt":"개발자에게 커뮤니케이션 스킬은 옵션인줄 알았는데, 필수불가결이었다. 서로 다른 직군의 개발자이지만, 같은 개발자끼리도 커뮤니케이션이 왜 쉽지 않은지 소개하고 싶다.","timeToRead":3,"frontmatter":{"title":"백엔드 개발자에게 원하는 걸 말했는데, 왜 대화가 안될까?","type":null,"tags":["소프트스킬","커뮤니케이션"],"language":null,"slug":"post/46/","hero":"/assets/images/basic/luffy_cry.gif","cover":null}}},{"node":{"excerpt":"타입스크립트 예약어 중에 식별자(변수명, 함수명 등)로 사용할 수 있는 예약어가 있다? 어떤 차이점이 있는지 자세히 알아보자.","timeToRead":1,"frontmatter":{"title":"타입스크립트 예약어 중에 식별자(변수명, 함수명 등)로 사용할 수 있는 예약어가 있다?","type":null,"tags":["typescript"],"language":null,"slug":"post/45/","hero":"/assets/images/post/2023/2023_045_000.png","cover":null}}},{"node":{"excerpt":"글 쓰는 것이 왜 어려울까 고민했을 때 내 기준에서 가장 큰 요인은 '무엇을 쓸 것인가, 글감의 부재'였다. 낱개로 흩어지는 메모를 유기적으로 연결하고 싶은 니즈는 온전히 사람의 손으로만 이루어져야 하는 것인가에 대한 고민들도 한 몫했다.","timeToRead":2,"frontmatter":{"title":"다시 쓰는 글쓰기 with 제텔카스텐","type":null,"tags":["diary"],"language":null,"slug":"post/44/","hero":"/assets/images/post/2023/2023_044_000.png","cover":null}}},{"node":{"excerpt":"Callback 보다는 Promise가 코드 작성하기 쉽고, 타입 추론하기가 쉽다.","timeToRead":1,"frontmatter":{"title":"이펙티브 타입스크립트 - 6. 비동기 코드에는 콜백 대신 async 함수 사용하기","type":"til","tags":["frontend","typescript","book"],"language":null,"slug":"til/typescript/effective-typescript/ch03/item25","hero":"/assets/images/til/book-effective-typescript.png","cover":null}}}]}},"pageContext":{"limit":10,"skip":0,"currentPage":1,"nbPages":6}},"staticQueryHashes":["1956263691","2749999020"]}