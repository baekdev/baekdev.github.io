<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[아웃풋 트레이닝]]></title><description><![CDATA[자바 둘 타세요-에서 자바 인력1을 맡고 있습니다.]]></description><link>https://baek.dev</link><image><url>https://baek.dev/assets/images/basic/profile.jpg</url><title>아웃풋 트레이닝</title><link>https://baek.dev</link></image><generator>GatsbyJS</generator><lastBuildDate>Thu, 10 Mar 2022 15:50:51 GMT</lastBuildDate><author><![CDATA[BAEKDEV]]></author><language><![CDATA[ko]]></language><item><title><![CDATA[Typescript/이펙티브 타입스크립트 - 2장 타입스크립트의 타입 시스템]]></title><description><![CDATA[<h2>아이템6. 편집기를 사용하여 타입 시스템 탐색하기</h2>
<h3>타입스크립트를 설치하면</h3>
<ul>
<li>타입스크립트 컴파일러(tsc)를 실행할 수 있음</li>
<li>단독으로 실행할 수 있는 타입스크립트 서버(tsserver)를 실행할 수 있음  </li>
</ul>
<h3>언어 서비스에 포함된 항목</h3>
<ul>
<li>코드 자동 완성</li>
<li>명세 검사</li>
<li>검색</li>
<li>리팩터링</li>
</ul>
<h2>아이템7. 타입이 값들의 집합이라고 생각하기</h2>
<h3>가장 작은 집합</h3>
<ul>
<li>아무 값도 포함하지 않는 공집합  </li>
<li>타입스크립트에서는 never 타입</li>
</ul>
<h3>Literal Type</h3>
<ul>
<li>한 가지 값만 포함하는 타입  </li>
<li>타입스크립트에서 unit type이라고도 불림  </li>
</ul>
<pre><code class="language-typescript">type A = 'A';
type B = 'B';
type Twelve = 12;

// union type
type AB = A | B;
type AB12 = A | B | Twelve;

const c: AB = 'C';
//    ~ 'C' 형식은 'AB' 형식에 할당할 수 없습니다.    
</code></pre>
<h3>타입 체커의 주요 역할 - 집합 검사</h3>
<ul>
<li>하나의 집합이 다른 집합의 부분 집합인지 검사하는 것  </li>
</ul>
<pre><code class="language-typescript">const ab: AB = Math.random() &#x3C; 0.5 ? 'A' : 'B';
const ab12: AB12 = ab; // { 'A', 'B' }는 {'A', 'B', 12}의 부분 집합이라 정상임  
</code></pre>
<ul>
<li>구조적 타이핑 규칙들은 어떠한 값이 다른 속성도 가질 수 있음을 의미  </li>
<li>심지어 함수 호출의 매개변수에도 다른 속성을 가질 수 있음  </li>
<li>특정 상황에서만 추가 속성을 허용하지 않는 잉여 속성 체크만 생각하다 보면 간과하기 쉬움  </li>
</ul>
<h4>두 타입의 인터섹션</h4>
<ul>
<li>&#x26; 연산자는 두 타입의 인턱센션(교집합)을 계산  </li>
<li>아래 예시에서 두 인터페이스는 공통 속성이 없기 때문에 공집합 예상할 수도 있지만  </li>
<li>인터페이스 속성이 아닌 값의 집합에 적용이 됨</li>
</ul>
<pre><code class="language-typescript">interface Person {
  name: string;
}
interface Lifespan {
  birth: Date;
  death?: Date;
}
type PersonSpan = Person &#x26; Lifespan;

const ps: PersonSpan = {
  name: 'Alan Turing',
  birth: new Date('1912/06/23'),
  death: new Date('1954/06/07'),
}; // 정상  
</code></pre>
<h5>인터페이스 유니온에 대한 never 타입</h5>
<pre><code class="language-typescript">type K = keyof (Person | Lifespan); // 타입이 never 
</code></pre>
<h4>서브타입</h4>
<ul>
<li>Vector3D는 Vector2D의 서브 타입임    </li>
<li>Vector2D는 Vector1D의 서브 타입임    </li>
</ul>
<pre><code class="language-typescript">interface Vector1D { x: number; }
interface Vector2D extends Vector1D { y: number; }
interface Vector3D extends Vector2D { z: number; }
</code></pre>
<h2>아이템8. 타입 공간과 값 공간의 심벌 구분하기</h2>
<p>타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재함</p>
<h3>interface와 instanceof</h3>
<pre><code class="language-typescript">interface Cylinder {
  radius: number;
  height: number;
}

function calculateVolumn(shape: unknown) {
  if (shape instanceof Cylinder) {
    shape.radius
    // ~ '{}'형식에 'radius'속성이 없습니다. 
  }
}
</code></pre>
<ul>
<li>instanceof는 자바스크립트의 런타임 연사자이고, 값에 대해 연산함  </li>
<li>instanceof Cylinder는 타입이 아니라 함수를 참조함  </li>
</ul>
<h3>class &#x26; enum</h3>
<ul>
<li>상황에 따라 타입과 값 두 가지 모두 가능한 예약어  </li>
<li>클래스가 타입으로 쓰일 때는 형태(속성과, 메서드)가 사용됨</li>
<li>클래스가 값으로 쓰일 때는 생성자가 사용됨  </li>
</ul>
<pre><code class="language-typescript">class Cylinder {
  radius = 1;
  height = 1;
}

function calculateVolumn(shape: unknown) {
  if (shape instanceof Cylinder) {
    shape        // 정상, 타입은 Cylinder  
    shape.radius // 정상, 타입은 number
  }
}
</code></pre>
<h3>typeof</h3>
<ul>
<li>typeof는 값을 읽어서 타입스크립트 타입을 반환함  </li>
<li>타입 공간의 typeof는 보다 큰 타입의 일부분으로 사용할 수 있음  </li>
<li>type 구문으로 이름을 붙이는 용도로도 사용할 수 있음  </li>
<li>값의 관점에서 typeof는 자바스크립트 런타임의 typeof 연산자가 됨  </li>
<li>값 공간의 typeof는 대상 심벌의 런타임 타입을 가리키는 문자열을 반환, 타입스크립트 타입과는 다름  </li>
<li>
<p>자바스크립트의 런타임 타입은 총 6개</p>
<ul>
<li>string, number, boolean, undefined, object, function  </li>
</ul>
</li>
</ul>
<pre><code class="language-typescript">  
class Cylinder {  // 클래스가 자바스크립트에서는 실제 함수로 구현됨  
  radius = 1;
  height = 1;
}

const v = typeof Cylinder; // 그래서 값이 "function"임   
type T = typeof Cylinder;  // 타입이 typeof Cylinder  

declare let fn: T;
const c = new fn(); // 타입이 Cylinder  
</code></pre>
<h3>두 공간 사이에서 다른 의미를 가지는 코드 패턴</h3>
<ul>
<li>
<p>값으로 쓰이는 this는 자바스크립트의 this keyword임  </p>
<ul>
<li>타입으로 쓰이는 this는 일명 다형성 this라고 불리는 this의 타입스크립트 타입임  </li>
<li>서브클래스의 메서드 체인을 구현할 떄 유용</li>
</ul>
</li>
<li>
<p>값에서 &#x26;와 |는 AND와 OR 비트 연산</p>
<ul>
<li>타입에서는 인터섹션과 유니온임 </li>
</ul>
</li>
<li>const는 새 변수를 선언하지만, as const는 리터럴 또는 리터럴 표현식의 추론된 타입을 바꿈  </li>
<li>extends는 서브클래스 또는 서브타입 또는 제너릭 타입의 한정자를 정의할 수 있음  </li>
<li>in은 루프 또는 매핑된 타입에 등장  </li>
</ul>
<blockquote>
<p>타입스크립트 코드가 잘 동작하지 않는다면 타입 공간과 값 공간을 혼동해서 잘못 작성했을 가능성이 큼  </p>
</blockquote>
<hr>
<p>출처: <a href="https://link.coupang.com/a/ki28i">이펙티브 타입스크립트</a>  </p>]]></description><link>https://baek.dev/til/typescript/effective-typescript/ch02</link><guid isPermaLink="false">https://baek.dev/til/typescript/effective-typescript/ch02</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Thu, 10 Mar 2022 13:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;아이템6. 편집기를 사용하여 타입 시스템 탐색하기&lt;/h2&gt;
&lt;h3&gt;타입스크립트를 설치하면&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;타입스크립트 컴파일러(tsc)를 실행할 수 있음&lt;/li&gt;
&lt;li&gt;단독으로 실행할 수 있는 타입스크립트 서버(tsserver)를 실행할 수 있음  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;언어 서비스에 포함된 항목&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드 자동 완성&lt;/li&gt;
&lt;li&gt;명세 검사&lt;/li&gt;
&lt;li&gt;검색&lt;/li&gt;
&lt;li&gt;리팩터링&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;아이템7. 타입이 값들의 집합이라고 생각하기&lt;/h2&gt;
&lt;h3&gt;가장 작은 집합&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;아무 값도 포함하지 않는 공집합  &lt;/li&gt;
&lt;li&gt;타입스크립트에서는 never 타입&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Literal Type&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;한 가지 값만 포함하는 타입  &lt;/li&gt;
&lt;li&gt;타입스크립트에서 unit type이라고도 불림  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;type A = &apos;A&apos;;
type B = &apos;B&apos;;
type Twelve = 12;

// union type
type AB = A | B;
type AB12 = A | B | Twelve;

const c: AB = &apos;C&apos;;
//    ~ &apos;C&apos; 형식은 &apos;AB&apos; 형식에 할당할 수 없습니다.    
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;타입 체커의 주요 역할 - 집합 검사&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;하나의 집합이 다른 집합의 부분 집합인지 검사하는 것  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;const ab: AB = Math.random() &amp;#x3C; 0.5 ? &apos;A&apos; : &apos;B&apos;;
const ab12: AB12 = ab; // { &apos;A&apos;, &apos;B&apos; }는 {&apos;A&apos;, &apos;B&apos;, 12}의 부분 집합이라 정상임  
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;구조적 타이핑 규칙들은 어떠한 값이 다른 속성도 가질 수 있음을 의미  &lt;/li&gt;
&lt;li&gt;심지어 함수 호출의 매개변수에도 다른 속성을 가질 수 있음  &lt;/li&gt;
&lt;li&gt;특정 상황에서만 추가 속성을 허용하지 않는 잉여 속성 체크만 생각하다 보면 간과하기 쉬움  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;두 타입의 인터섹션&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&amp;#x26; 연산자는 두 타입의 인턱센션(교집합)을 계산  &lt;/li&gt;
&lt;li&gt;아래 예시에서 두 인터페이스는 공통 속성이 없기 때문에 공집합 예상할 수도 있지만  &lt;/li&gt;
&lt;li&gt;인터페이스 속성이 아닌 값의 집합에 적용이 됨&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;interface Person {
  name: string;
}
interface Lifespan {
  birth: Date;
  death?: Date;
}
type PersonSpan = Person &amp;#x26; Lifespan;

const ps: PersonSpan = {
  name: &apos;Alan Turing&apos;,
  birth: new Date(&apos;1912/06/23&apos;),
  death: new Date(&apos;1954/06/07&apos;),
}; // 정상  
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;인터페이스 유니온에 대한 never 타입&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;type K = keyof (Person | Lifespan); // 타입이 never 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;서브타입&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Vector3D는 Vector2D의 서브 타입임    &lt;/li&gt;
&lt;li&gt;Vector2D는 Vector1D의 서브 타입임    &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;interface Vector1D { x: number; }
interface Vector2D extends Vector1D { y: number; }
interface Vector3D extends Vector2D { z: number; }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;아이템8. 타입 공간과 값 공간의 심벌 구분하기&lt;/h2&gt;
&lt;p&gt;타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재함&lt;/p&gt;
&lt;h3&gt;interface와 instanceof&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;interface Cylinder {
  radius: number;
  height: number;
}

function calculateVolumn(shape: unknown) {
  if (shape instanceof Cylinder) {
    shape.radius
    // ~ &apos;{}&apos;형식에 &apos;radius&apos;속성이 없습니다. 
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;instanceof는 자바스크립트의 런타임 연사자이고, 값에 대해 연산함  &lt;/li&gt;
&lt;li&gt;instanceof Cylinder는 타입이 아니라 함수를 참조함  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;class &amp;#x26; enum&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;상황에 따라 타입과 값 두 가지 모두 가능한 예약어  &lt;/li&gt;
&lt;li&gt;클래스가 타입으로 쓰일 때는 형태(속성과, 메서드)가 사용됨&lt;/li&gt;
&lt;li&gt;클래스가 값으로 쓰일 때는 생성자가 사용됨  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;class Cylinder {
  radius = 1;
  height = 1;
}

function calculateVolumn(shape: unknown) {
  if (shape instanceof Cylinder) {
    shape        // 정상, 타입은 Cylinder  
    shape.radius // 정상, 타입은 number
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;typeof&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;typeof는 값을 읽어서 타입스크립트 타입을 반환함  &lt;/li&gt;
&lt;li&gt;타입 공간의 typeof는 보다 큰 타입의 일부분으로 사용할 수 있음  &lt;/li&gt;
&lt;li&gt;type 구문으로 이름을 붙이는 용도로도 사용할 수 있음  &lt;/li&gt;
&lt;li&gt;값의 관점에서 typeof는 자바스크립트 런타임의 typeof 연산자가 됨  &lt;/li&gt;
&lt;li&gt;값 공간의 typeof는 대상 심벌의 런타임 타입을 가리키는 문자열을 반환, 타입스크립트 타입과는 다름  &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;자바스크립트의 런타임 타입은 총 6개&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;string, number, boolean, undefined, object, function  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;  
class Cylinder {  // 클래스가 자바스크립트에서는 실제 함수로 구현됨  
  radius = 1;
  height = 1;
}

const v = typeof Cylinder; // 그래서 값이 &quot;function&quot;임   
type T = typeof Cylinder;  // 타입이 typeof Cylinder  

declare let fn: T;
const c = new fn(); // 타입이 Cylinder  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;두 공간 사이에서 다른 의미를 가지는 코드 패턴&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;값으로 쓰이는 this는 자바스크립트의 this keyword임  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;타입으로 쓰이는 this는 일명 다형성 this라고 불리는 this의 타입스크립트 타입임  &lt;/li&gt;
&lt;li&gt;서브클래스의 메서드 체인을 구현할 떄 유용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;값에서 &amp;#x26;와 |는 AND와 OR 비트 연산&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;타입에서는 인터섹션과 유니온임 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;const는 새 변수를 선언하지만, as const는 리터럴 또는 리터럴 표현식의 추론된 타입을 바꿈  &lt;/li&gt;
&lt;li&gt;extends는 서브클래스 또는 서브타입 또는 제너릭 타입의 한정자를 정의할 수 있음  &lt;/li&gt;
&lt;li&gt;in은 루프 또는 매핑된 타입에 등장  &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;타입스크립트 코드가 잘 동작하지 않는다면 타입 공간과 값 공간을 혼동해서 잘못 작성했을 가능성이 큼  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;출처: &lt;a href=&quot;https://link.coupang.com/a/ki28i&quot;&gt;이펙티브 타입스크립트&lt;/a&gt;  &lt;/p&gt;</content:encoded></item><item><title><![CDATA[Typescript/이펙티브 타입스크립트 - 1장 타입스크립트 알아보기]]></title><description><![CDATA[<h2>아이템1. 타입스크립트와 자바스크립트의 관계 이해하기</h2>
<p>타입스크립트(이하 ts)는 자바스크립트(이하 js)의 상위집합</p>
<ul>
<li>타입스크립트는 타입이 정의된 자바스크립트의 상위집합</li>
<li>ts는 js의 상위집합이기 때문에 .js에 있는 코드는 이미 타입스크립트 코드임</li>
<li>
<p>main.js -> main.ts로 바꾼다고 해도 달라지는 것은 없음</p>
<ul>
<li>js에서 ts로 migration 큰 이점  </li>
</ul>
</li>
</ul>
<h2>아이템2. 타입스크립트 설정 이해하기</h2>
<p>타입스크립트 설정 파일 생성 방법  </p>
<pre><code class="language-typescript">tsc --init  
</code></pre>
<h3>설정1. noImplicitAny</h3>
<p>변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어   </p>
<ul>
<li>타입을 명시하지 않으면 암시적으로 'any' 타입  </li>
<li>any 타입을 매개변수에 사용하면 타입 체커는 무용 지물    </li>
<li>any는 유용하나 주의해서 사용해야함  </li>
<li>설정을 해재야하는 경우는 타입스크립트로 마이그레이션 하는 경우만 필요  </li>
</ul>
<pre><code class="language-typescript">/* noImplicitAny: true는 아래 코드가 문제 없음 */
function add(a, b) {
  //         ~ 'a' 매개변수에는 암시적으로 'any' 형식이 포함됨  
  return a + b;
}  
</code></pre>
<h3>설정2. strictNullChecks</h3>
<p>null과 undefined가 모든 타입에서 허용되는지 확인하는 설정  </p>
<pre><code class="language-typescript">// strictNullChecks: true  
const x: number = null;
//    ~ 'null' 형식은 'number' 형식에 할당할 수 없음  


// null을 허용하려고 하는 경우  
const y: number | null = null;  
//                null을 허용하려고 의도를 명시적으로 드러냄  
</code></pre>
<h3>설정3. noEmitOnError</h3>
<p>오류가 있을 때 컴파일 하지 않는 옵션  </p>
<h2>아이템3. 코드 생성과 타입이 관계없음을 이해하기</h2>
<p>타입스크림트 컴파일러는 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스립트를 트랜스파일함  </p>
<h3>타입 오류가 있는 코드도 컴파일이 가능함</h3>
<p>타입스크립트 오류는 warning 개념이라서 알려 주지만 그렇다고 빌드를 멈추지는 않음  </p>
<ul>
<li>참고: noEmitOnError 옵션  </li>
</ul>
<h3>런타입에는 타입 체크가 불가능</h3>
<p>타입스크립트의 타입은 '제거 가능(erasable)'하기에 자바스크립트로 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문은 그냥 제거되어 버림  </p>
<pre><code class="language-typescript">// (버그) 기대와 다른 타입 체크  
interface  Square {
  width: number;
}  

interface Rectangle extends Square {
  height: number;
}

type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
    //                 ~~~~~~~~~~ 'Rectangle'은 형식만 참조하지만, 여기서는 값으로 사용되고 있음  
    return shape.width * shape.height;
    //                         ~~~~~~ 'Shape' 형식에 'height' 속성이 없음  
  } else {
    return shape.width * shape.width;
  }
}
</code></pre>
<p>그럼 <code>런타임에 타입 정보를 유지하는 방법이 필요</code> </p>
<h4>방법1. 속성이 존재하는지 체크해보기</h4>
<pre><code class="language-typescript">interface  Square {
  width: number;
}

interface Rectangle extends Square {
  height: number;
}

type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if ('height' in shape) {
    shape; // shape는 Rectangle
    return shape.width * shape.height;
  } else {
    shape; // shape는 Square
    return shape.width * shape.width;
  }
}
</code></pre>
<h4>방법2. '태그'기법</h4>
<pre><code class="language-typescript">interface  Square {
  kind: 'square';
  width: number;
}

interface Rectangle {
  kind: 'rectangle';
  width: number;
  height: number;
}

type Shape = Square | Rectangle; // 태그된 유니온 -> 런타임에 타입 정보를 손쉽게 유지할 수 있음  

function calculateArea(shape: Shape) {
  if (shape.height === 'rectangle') {
    shape; // shape는 Rectangle
    return shape.width * shape.height;
  } else {
    shape; // shape는 Square
    return shape.width * shape.width;
  }
}
</code></pre>
<h4>방법3. 클래스로 만들기</h4>
<p>인터페이스는 타입으로만 사용 가능하지만, 클래스로 선언하면 타입과 값으로 모두 사용할 수 있으므로 오류가 없음  </p>
<pre><code class="language-typescript">class Square {
  constructor(public width: number) {
  }
}

class Rectangle extends Square {
  constructor(public width: number, public height: number) {
    super(width);
  }
}

type Shape = Square | Rectangle; // Rectangle은 타입으로 참조되지만  

function calculateArea(shape: Shape) {  
  if (shape instanceof Rectangle) { // 여기서는 값으로 참조됨  
    shape; // shape는 Rectangle
    return shape.width * shape.height;
  } else {
    shape; // shape는 Square
    return shape.width * shape.width;
  }
}
</code></pre>
<h3>타입 연산은 런타임에 영향을 주지 않음</h3>
<p>타입 체커를 통과하지만 잘못된 방법임  </p>
<pre><code class="language-typescript">// 타입스크립트 
function asNumber(val: number | string): number {
  return val as number;
}

// 컴파일 후 아무런 정제 과정이 없음  
function asNumber(val) {
  return val;
}
</code></pre>
<h2>아이템4. 구조적 타이핑에 익숙해지기</h2>
<p>자바스크립트는 본질적으로 덕 타이핑 기반으로 어떤 함수의 매개변수 값이 모두 제대로 주어진다면, 그 값이 어떻게 만들어졌는지 신경 쓰지 않고 사용함  </p>
<ul>
<li>
<p>덕 타이핑? </p>
<ul>
<li>객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우 객체를 해당 타입에 속하는 것으로 간주하는 방식  </li>
<li>"만약 어떤 새가 오리처럼 걷고, 헤어지고, 꽥꽥거리는 소리를 낸다면 나는 그 새를 오리라고 부를 것이다."</li>
</ul>
</li>
</ul>
<p>아래 예제가 실행 가능한 이유는 구조적 타이핑 관점에서 Vector3D에 x, y가 있어서 Vector2D와 호환이 되기 때문  </p>
<pre><code class="language-typescript">interface Vector2D {
  name: string;
  x: number;
  y: number;
}

interface Vector3D {
  x: number;
  y: number;
  z: number;
}

function calculateLength(v: Vector2D) {
  return Math.sqrt(v.x * v.x + v.y * v.y);
}

calculateLength({name: 'vector2D', x: 3, y: 4}); // Vector2D
calculateLength({x: 3, y: 4, z:8}); // Vector3D
</code></pre>
<h2>아이템5. any 타입 지양하기</h2>
<p>any 타입을 사용하면 타입 체커와 타입스크립트 언어 서비스를 무력화시켜 버림<br>
any 타입은 진짜 문제점을 감추며, 개발 경험을 나쁘게 하고, 타입 시스템의 신뢰도를 떨어드리기에 최대한 사용을 피해야함  </p>
<h3>단점1. any 타입에는 타입 안전성이 없음</h3>
<pre><code class="language-typescript">let age: number;
age = '12' as any;
age += 1; // 결과: 121 
</code></pre>
<h3>단점2. any는 함수 시그니처를 무시해 버림</h3>
<pre><code class="language-typescript">function calculateAge(birthDate: Date): number {
  // ...
}

let birthDate: any = '1990-01-19';
calculateAge(birthDate); // 정상  
</code></pre>
<h3>단점3. any 타입에는 언어 서비스가 적용되지 않음</h3>
<p>언어 서비스는 자동완성 기능과 적절한 도움말을 제공함  </p>
<h3>단점4. any 타입 설게를 감춰버림</h3>
<p>객체를 정의할 때 특히 문제가 되는데 상태 객체의 설계를 감춰버리기 때문<br>
깔끔하고 정확하고 명료한 코드 작성을 위해 제대로 된 타입 설계는 필수  </p>
<h3>단점5. any는 타입시스템의 신뢰도를 떨어뜨림</h3>
<p>타입스크립트는 개발자의 삶을 편하게 하는 데 목적이 있지만, 코드 내에 존재하는 수많은 any 타입으로 인해 자바스크립트보다 일을 더 여럽게 만듬<br>
타입 오류를 고쳐야 하고 여전히 머릿속에 실제 타입을 기억해야 하기 때문<br>
타입이 실제 값과 일치한다면 타입 정보를 기억해 둘 필요가 없음<br>
타입스크립트가 타입 정보를 기억해 주기 때문  </p>
<hr>
<p>출처: <a href="https://link.coupang.com/a/ki28i">이펙티브 타입스크립트</a>  </p>]]></description><link>https://baek.dev/til/typescript/effective-typescript/ch01</link><guid isPermaLink="false">https://baek.dev/til/typescript/effective-typescript/ch01</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Thu, 03 Mar 2022 11:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;아이템1. 타입스크립트와 자바스크립트의 관계 이해하기&lt;/h2&gt;
&lt;p&gt;타입스크립트(이하 ts)는 자바스크립트(이하 js)의 상위집합&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;타입스크립트는 타입이 정의된 자바스크립트의 상위집합&lt;/li&gt;
&lt;li&gt;ts는 js의 상위집합이기 때문에 .js에 있는 코드는 이미 타입스크립트 코드임&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;main.js -&gt; main.ts로 바꾼다고 해도 달라지는 것은 없음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;js에서 ts로 migration 큰 이점  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;아이템2. 타입스크립트 설정 이해하기&lt;/h2&gt;
&lt;p&gt;타입스크립트 설정 파일 생성 방법  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;tsc --init  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;설정1. noImplicitAny&lt;/h3&gt;
&lt;p&gt;변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;타입을 명시하지 않으면 암시적으로 &apos;any&apos; 타입  &lt;/li&gt;
&lt;li&gt;any 타입을 매개변수에 사용하면 타입 체커는 무용 지물    &lt;/li&gt;
&lt;li&gt;any는 유용하나 주의해서 사용해야함  &lt;/li&gt;
&lt;li&gt;설정을 해재야하는 경우는 타입스크립트로 마이그레이션 하는 경우만 필요  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;/* noImplicitAny: true는 아래 코드가 문제 없음 */
function add(a, b) {
  //         ~ &apos;a&apos; 매개변수에는 암시적으로 &apos;any&apos; 형식이 포함됨  
  return a + b;
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;설정2. strictNullChecks&lt;/h3&gt;
&lt;p&gt;null과 undefined가 모든 타입에서 허용되는지 확인하는 설정  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// strictNullChecks: true  
const x: number = null;
//    ~ &apos;null&apos; 형식은 &apos;number&apos; 형식에 할당할 수 없음  


// null을 허용하려고 하는 경우  
const y: number | null = null;  
//                null을 허용하려고 의도를 명시적으로 드러냄  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;설정3. noEmitOnError&lt;/h3&gt;
&lt;p&gt;오류가 있을 때 컴파일 하지 않는 옵션  &lt;/p&gt;
&lt;h2&gt;아이템3. 코드 생성과 타입이 관계없음을 이해하기&lt;/h2&gt;
&lt;p&gt;타입스크림트 컴파일러는 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스립트를 트랜스파일함  &lt;/p&gt;
&lt;h3&gt;타입 오류가 있는 코드도 컴파일이 가능함&lt;/h3&gt;
&lt;p&gt;타입스크립트 오류는 warning 개념이라서 알려 주지만 그렇다고 빌드를 멈추지는 않음  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;참고: noEmitOnError 옵션  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;런타입에는 타입 체크가 불가능&lt;/h3&gt;
&lt;p&gt;타입스크립트의 타입은 &apos;제거 가능(erasable)&apos;하기에 자바스크립트로 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문은 그냥 제거되어 버림  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// (버그) 기대와 다른 타입 체크  
interface  Square {
  width: number;
}  

interface Rectangle extends Square {
  height: number;
}

type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
    //                 ~~~~~~~~~~ &apos;Rectangle&apos;은 형식만 참조하지만, 여기서는 값으로 사용되고 있음  
    return shape.width * shape.height;
    //                         ~~~~~~ &apos;Shape&apos; 형식에 &apos;height&apos; 속성이 없음  
  } else {
    return shape.width * shape.width;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그럼 &lt;code&gt;런타임에 타입 정보를 유지하는 방법이 필요&lt;/code&gt; &lt;/p&gt;
&lt;h4&gt;방법1. 속성이 존재하는지 체크해보기&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;interface  Square {
  width: number;
}

interface Rectangle extends Square {
  height: number;
}

type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (&apos;height&apos; in shape) {
    shape; // shape는 Rectangle
    return shape.width * shape.height;
  } else {
    shape; // shape는 Square
    return shape.width * shape.width;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;방법2. &apos;태그&apos;기법&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;interface  Square {
  kind: &apos;square&apos;;
  width: number;
}

interface Rectangle {
  kind: &apos;rectangle&apos;;
  width: number;
  height: number;
}

type Shape = Square | Rectangle; // 태그된 유니온 -&gt; 런타임에 타입 정보를 손쉽게 유지할 수 있음  

function calculateArea(shape: Shape) {
  if (shape.height === &apos;rectangle&apos;) {
    shape; // shape는 Rectangle
    return shape.width * shape.height;
  } else {
    shape; // shape는 Square
    return shape.width * shape.width;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;방법3. 클래스로 만들기&lt;/h4&gt;
&lt;p&gt;인터페이스는 타입으로만 사용 가능하지만, 클래스로 선언하면 타입과 값으로 모두 사용할 수 있으므로 오류가 없음  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;class Square {
  constructor(public width: number) {
  }
}

class Rectangle extends Square {
  constructor(public width: number, public height: number) {
    super(width);
  }
}

type Shape = Square | Rectangle; // Rectangle은 타입으로 참조되지만  

function calculateArea(shape: Shape) {  
  if (shape instanceof Rectangle) { // 여기서는 값으로 참조됨  
    shape; // shape는 Rectangle
    return shape.width * shape.height;
  } else {
    shape; // shape는 Square
    return shape.width * shape.width;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;타입 연산은 런타임에 영향을 주지 않음&lt;/h3&gt;
&lt;p&gt;타입 체커를 통과하지만 잘못된 방법임  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;// 타입스크립트 
function asNumber(val: number | string): number {
  return val as number;
}

// 컴파일 후 아무런 정제 과정이 없음  
function asNumber(val) {
  return val;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;아이템4. 구조적 타이핑에 익숙해지기&lt;/h2&gt;
&lt;p&gt;자바스크립트는 본질적으로 덕 타이핑 기반으로 어떤 함수의 매개변수 값이 모두 제대로 주어진다면, 그 값이 어떻게 만들어졌는지 신경 쓰지 않고 사용함  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;덕 타이핑? &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우 객체를 해당 타입에 속하는 것으로 간주하는 방식  &lt;/li&gt;
&lt;li&gt;&quot;만약 어떤 새가 오리처럼 걷고, 헤어지고, 꽥꽥거리는 소리를 낸다면 나는 그 새를 오리라고 부를 것이다.&quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래 예제가 실행 가능한 이유는 구조적 타이핑 관점에서 Vector3D에 x, y가 있어서 Vector2D와 호환이 되기 때문  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;interface Vector2D {
  name: string;
  x: number;
  y: number;
}

interface Vector3D {
  x: number;
  y: number;
  z: number;
}

function calculateLength(v: Vector2D) {
  return Math.sqrt(v.x * v.x + v.y * v.y);
}

calculateLength({name: &apos;vector2D&apos;, x: 3, y: 4}); // Vector2D
calculateLength({x: 3, y: 4, z:8}); // Vector3D
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;아이템5. any 타입 지양하기&lt;/h2&gt;
&lt;p&gt;any 타입을 사용하면 타입 체커와 타입스크립트 언어 서비스를 무력화시켜 버림&lt;br&gt;
any 타입은 진짜 문제점을 감추며, 개발 경험을 나쁘게 하고, 타입 시스템의 신뢰도를 떨어드리기에 최대한 사용을 피해야함  &lt;/p&gt;
&lt;h3&gt;단점1. any 타입에는 타입 안전성이 없음&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;let age: number;
age = &apos;12&apos; as any;
age += 1; // 결과: 121 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;단점2. any는 함수 시그니처를 무시해 버림&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-typescript&quot;&gt;function calculateAge(birthDate: Date): number {
  // ...
}

let birthDate: any = &apos;1990-01-19&apos;;
calculateAge(birthDate); // 정상  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;단점3. any 타입에는 언어 서비스가 적용되지 않음&lt;/h3&gt;
&lt;p&gt;언어 서비스는 자동완성 기능과 적절한 도움말을 제공함  &lt;/p&gt;
&lt;h3&gt;단점4. any 타입 설게를 감춰버림&lt;/h3&gt;
&lt;p&gt;객체를 정의할 때 특히 문제가 되는데 상태 객체의 설계를 감춰버리기 때문&lt;br&gt;
깔끔하고 정확하고 명료한 코드 작성을 위해 제대로 된 타입 설계는 필수  &lt;/p&gt;
&lt;h3&gt;단점5. any는 타입시스템의 신뢰도를 떨어뜨림&lt;/h3&gt;
&lt;p&gt;타입스크립트는 개발자의 삶을 편하게 하는 데 목적이 있지만, 코드 내에 존재하는 수많은 any 타입으로 인해 자바스크립트보다 일을 더 여럽게 만듬&lt;br&gt;
타입 오류를 고쳐야 하고 여전히 머릿속에 실제 타입을 기억해야 하기 때문&lt;br&gt;
타입이 실제 값과 일치한다면 타입 정보를 기억해 둘 필요가 없음&lt;br&gt;
타입스크립트가 타입 정보를 기억해 주기 때문  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;출처: &lt;a href=&quot;https://link.coupang.com/a/ki28i&quot;&gt;이펙티브 타입스크립트&lt;/a&gt;  &lt;/p&gt;</content:encoded></item><item><title><![CDATA[[React Basic] SASS의 세번째 버전 SCSS]]></title><description><![CDATA[<h2>SCSS</h2>
<ul>
<li>SCSS는 SASS의 3번째 버전에 추가  </li>
<li>SASS의 모든 기능을 쓸 수 있음 </li>
<li>CSS와 호환도 잘됨  </li>
</ul>
<h3>특징 및 주요 문법</h3>
<p>자세한 내용은 <a href="https://sass-lang.com/guide">sass-lang.com/guide</a>, <a href="https://sass-lang.com/documentation">sass-lang.com/documentation</a> 참고  </p>
<h4>$를 통한 변수 선언 -> 중복 제거 및 재사용</h4>
<pre><code class="language-scss">$font-stack: Helvetica, sans-serif;
$primary-color: #333;

body {
  font: 100% $font-stack;
  color: $primary-color;
}
</code></pre>
<h4>중첩 작성 방식을 통한 시각적 계층 구조 표현</h4>
<pre><code class="language-scss">    div {
    background-color: green
      &#x26;:hover { background-color: blue }
    }
    
    .div {
      background-color: green
      &#x26;_blue { background-color: blue }
    }
</code></pre>
<h4>일부 SCSS 분리를 통한 CSS 모듈화 -> @use 사용</h4>
<pre><code class="language-scss">nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}
</code></pre>
<h4>mixins 사용으로 CSS 선언 그룹을 만들 수 있음, 함수처럼 사용</h4>
<pre><code class="language-scss">@mixin theme($theme: DarkGray) {
  background: $theme;
  box-shadow: 0 0 1px rgba($theme, .25);
  color: #fff;
}

.info {
  @include theme;
}
.alert {
  @include theme($theme: DarkRed);
}
.success {
  @include theme($theme: DarkGreen);
}
</code></pre>
<h4>@extend 사용으로 속성 집합을 공유할 수 있음</h4>
<pre><code class="language-scss">%message-shared {
  border: 1px solid #ccc;
  padding: 10px;
  color: #333;
}

.message {
  @extend %message-shared;
}

.success {
  @extend %message-shared;
  border-color: green;
}
</code></pre>
<h4>- +, -, *, math.div(), % 연산자를 사용 할 수 있음</h4>
<pre><code class="language-scss">@use "sass:math";

.container {
  display: flex;
}

article[role="main"] {
  width: math.div(600px, 960px) * 100%;
}
</code></pre>
<h3>설치</h3>
<p>npm install을 통해 다음 패키지들을 설치  </p>
<ul>
<li>node-sass  </li>
<li>open-color  </li>
<li>sass-loader  </li>
<li>classnames  </li>
</ul>]]></description><link>https://baek.dev/post/43/</link><guid isPermaLink="false">https://baek.dev/post/43/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 23 Jan 2022 12:45:00 GMT</pubDate><content:encoded>&lt;h2&gt;SCSS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SCSS는 SASS의 3번째 버전에 추가  &lt;/li&gt;
&lt;li&gt;SASS의 모든 기능을 쓸 수 있음 &lt;/li&gt;
&lt;li&gt;CSS와 호환도 잘됨  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;특징 및 주요 문법&lt;/h3&gt;
&lt;p&gt;자세한 내용은 &lt;a href=&quot;https://sass-lang.com/guide&quot;&gt;sass-lang.com/guide&lt;/a&gt;, &lt;a href=&quot;https://sass-lang.com/documentation&quot;&gt;sass-lang.com/documentation&lt;/a&gt; 참고  &lt;/p&gt;
&lt;h4&gt;$를 통한 변수 선언 -&gt; 중복 제거 및 재사용&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;$font-stack: Helvetica, sans-serif;
$primary-color: #333;

body {
  font: 100% $font-stack;
  color: $primary-color;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;중첩 작성 방식을 통한 시각적 계층 구조 표현&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;    div {
    background-color: green
      &amp;#x26;:hover { background-color: blue }
    }
    
    .div {
      background-color: green
      &amp;#x26;_blue { background-color: blue }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;일부 SCSS 분리를 통한 CSS 모듈화 -&gt; @use 사용&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;mixins 사용으로 CSS 선언 그룹을 만들 수 있음, 함수처럼 사용&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@mixin theme($theme: DarkGray) {
  background: $theme;
  box-shadow: 0 0 1px rgba($theme, .25);
  color: #fff;
}

.info {
  @include theme;
}
.alert {
  @include theme($theme: DarkRed);
}
.success {
  @include theme($theme: DarkGreen);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;@extend 사용으로 속성 집합을 공유할 수 있음&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;%message-shared {
  border: 1px solid #ccc;
  padding: 10px;
  color: #333;
}

.message {
  @extend %message-shared;
}

.success {
  @extend %message-shared;
  border-color: green;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;- +, -, *, math.div(), % 연산자를 사용 할 수 있음&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-scss&quot;&gt;@use &quot;sass:math&quot;;

.container {
  display: flex;
}

article[role=&quot;main&quot;] {
  width: math.div(600px, 960px) * 100%;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;설치&lt;/h3&gt;
&lt;p&gt;npm install을 통해 다음 패키지들을 설치  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;node-sass  &lt;/li&gt;
&lt;li&gt;open-color  &lt;/li&gt;
&lt;li&gt;sass-loader  &lt;/li&gt;
&lt;li&gt;classnames  &lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[[React Basic] 리액트 프로젝트 생성하기. 그런데 이제 npx를 곁들인]]></title><description><![CDATA[<p>우리가 웹사이트를 만들기 위해 필요한 것들을 하나씩 설치할 수 있지만, 이미 필요한 것들을 모아놓은 패키지를 이용하면 손쉬울 것이다.
이게 바로 <strong>CRA(Create React App)</strong>이다.    </p>
<p>CRA를 이용한 프로젝트 생성을 진행하기 위해서는 <strong>node</strong> 및 <strong>npm</strong> 설치가 되어 있어야 한다. (이 포스팅에서는 이 내용은 생략하고, node와 npm이 설치되어 있다고 전제하겠다.) 그럼 npm을 이용해 npx를 설치해보자.  </p>
<pre><code class="language-shell">$> npm install -g npx  
</code></pre>
<p>대부분 많이 쓰는 <code>npm install -g create-react-app</code> 을 사용 하지 않는 이유는, -g 를 통해 전역적으로 create-react-app 가 설치됨으로서 여러 문제점을 야기한다.  </p>
<ul>
<li>
<p>CRA의 무거운 의존성 라이브러리들이 로컬에 남음  </p>
<ul>
<li>앞서 소개했듯 필요한 것들을 모아놓은 패키지이기 때문에 많은 의존성 라이브러리들이 있음   </li>
</ul>
</li>
<li>CRA 버전 업데이트 시, 전역으로 설치된 CRA를 재설치 해야함</li>
</ul>
<p>반대로 npx를 이용하면,  </p>
<ul>
<li>최신 CPA 패키지가 다운로드가 되고, 설정들을 세팅한 후에 CRA 패키지는 제거됨  </li>
<li>무거운 의존성 라이브러리들도 남지 않고, 함께 제거되는 장점  </li>
</ul>
<p>그럼 npx로 CRA를 이용해 프로젝트를 생성해보자.  </p>
<pre><code class="language-shell">$> npx create-react-app [프로젝트 이름]    
$> npx create-react-app sample-project   
</code></pre>
<p>프로젝트는 바로 실행해 볼 수 있다.<br>
생성한 프로젝트 이름의 폴더로 이동해서 npm run start를 실행한다.  </p>
<pre><code class="language-shell">$> cd sample-project
sample-project $> npm run start
</code></pre>
<p>실행이 완료되면 <a href="http://localhost:3000/">http://localhost:3000/</a> 과 같이 접속가능한 url을 터미널에 보여준다. 접속해 보면 이렇게 리액트 로고와 함께 페이지가 열린다.  </p>
<p><img src="https://baek.dev/assets/images/post/2022/2022_042_001.png" alt="CRA">  </p>]]></description><link>https://baek.dev/post/42/</link><guid isPermaLink="false">https://baek.dev/post/42/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sat, 22 Jan 2022 14:00:00 GMT</pubDate><content:encoded>&lt;p&gt;우리가 웹사이트를 만들기 위해 필요한 것들을 하나씩 설치할 수 있지만, 이미 필요한 것들을 모아놓은 패키지를 이용하면 손쉬울 것이다.
이게 바로 &lt;strong&gt;CRA(Create React App)&lt;/strong&gt;이다.    &lt;/p&gt;
&lt;p&gt;CRA를 이용한 프로젝트 생성을 진행하기 위해서는 &lt;strong&gt;node&lt;/strong&gt; 및 &lt;strong&gt;npm&lt;/strong&gt; 설치가 되어 있어야 한다. (이 포스팅에서는 이 내용은 생략하고, node와 npm이 설치되어 있다고 전제하겠다.) 그럼 npm을 이용해 npx를 설치해보자.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$&gt; npm install -g npx  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;대부분 많이 쓰는 &lt;code&gt;npm install -g create-react-app&lt;/code&gt; 을 사용 하지 않는 이유는, -g 를 통해 전역적으로 create-react-app 가 설치됨으로서 여러 문제점을 야기한다.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CRA의 무거운 의존성 라이브러리들이 로컬에 남음  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;앞서 소개했듯 필요한 것들을 모아놓은 패키지이기 때문에 많은 의존성 라이브러리들이 있음   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CRA 버전 업데이트 시, 전역으로 설치된 CRA를 재설치 해야함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;반대로 npx를 이용하면,  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;최신 CPA 패키지가 다운로드가 되고, 설정들을 세팅한 후에 CRA 패키지는 제거됨  &lt;/li&gt;
&lt;li&gt;무거운 의존성 라이브러리들도 남지 않고, 함께 제거되는 장점  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그럼 npx로 CRA를 이용해 프로젝트를 생성해보자.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$&gt; npx create-react-app [프로젝트 이름]    
$&gt; npx create-react-app sample-project   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로젝트는 바로 실행해 볼 수 있다.&lt;br&gt;
생성한 프로젝트 이름의 폴더로 이동해서 npm run start를 실행한다.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$&gt; cd sample-project
sample-project $&gt; npm run start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실행이 완료되면 &lt;a href=&quot;http://localhost:3000/&quot;&gt;http://localhost:3000/&lt;/a&gt; 과 같이 접속가능한 url을 터미널에 보여준다. 접속해 보면 이렇게 리액트 로고와 함께 페이지가 열린다.  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2022/2022_042_001.png&quot; alt=&quot;CRA&quot;&gt;  &lt;/p&gt;</content:encoded></item><item><title><![CDATA[아디오스 글또!]]></title><description><![CDATA[<p>글또 5기를 시작한지 엊그제 같은데 벌써 이번이 글또로서 작성하는 마지막 글이되었다. 사실 5기에 참여할지 말지 고민을 많이 했었다. 4기에 참여하면서 글쓰는 것이 재밌기도 했지만 글을 쥐어짜며 쓴적도 있어 쉽지 않았기 때문이다. 이후 글또 5기 모집글을 보고서는 글을 하나도 쓰지 않은 나 자신을 발견하곤 무조건 참여가 필요하다 느꼈다.  </p>
<ul>
<li><a href="http://baek.dev/post/29/">다시 또 글또를 시작하게 된 이유 2가지</a>  </li>
</ul>
<p>이번 5기에 참여하면서는 꾸준히 글을 쓰는 것보다 새로운 공부를 하면서 글을 발행한다는 것이 더 힘들었다. 나의 짧은 지식으로 부족한 글을 쓰게 되면 누군가는 부족한 지식을 습득하게되지 않을까 두렵기도 했고, 아는 지식이 짧다보니 무엇을 써야하는지도 가늠하기 어려웠다.  </p>
<p>누군가가 약속은 깨라고 있는 것이랬던가, 거창한 플랜은 지키지 못했고 이론적인 글과 추천하고 싶은 책 리뷰 정도로 글을 작성했다.   </p>
<p><br/><br/>
<a href="http://baek.dev/post/34/"><img src="https://baek.dev/assets/images/post/2020/2020_033.png"/></a><br/>  </p>
<p><a href="http://baek.dev/post/33/">1. 둘리 &#x26; 도우너 어서오고 짤 생성기 회고</a>  </p>
<ul>
<li>하고 싶었던 짤 생성기 프로젝트에 대한 회고 포스팅이다.  </li>
<li>짭짤한 트래픽 맛을 보게 해준 프로젝트를 어떻게 만들게 되었는지 공유했다.  </li>
</ul>
<p><br/><br/>
<a href="http://baek.dev/post/34/"><img src="https://baek.dev/assets/images/post/2020/2020_034.png"/></a><br/></p>
<p><a href="http://baek.dev/post/34/">2. 뉴노멀 중심에서 하는 2020 회고</a>  </p>
<ul>
<li>코로나가 메인이었던 2020년 회멀고를 하며 한 해를 마무리한다. 끝이 보이지 않는 터널을 지나는 기분이지만 돌이켜보니 많은 기회가 있었다.  </li>
</ul>
<p><br/><br/>
<a href="http://baek.dev/post/34/"><img src="https://baek.dev/assets/images/post/2021/2021_035.png"/></a><br/></p>
<p><a href="http://baek.dev/post/36/">3. 예제로 만나보는 자바스크립트 호이스팅(hoisting)</a><br>
<a href="http://baek.dev/post/37/">4. 자바스크립의 실행 컨텍스트</a>  </p>
<ul>
<li>코어 자바스크립트 책을 공부하면서 일부 정리해본 내용이다.  </li>
</ul>
<p><br/><br/>
<a href="http://baek.dev/post/34/"><img src="https://baek.dev/assets/images/post/2021/2021_038.png"/></a><br/></p>
<p><a href="http://baek.dev/post/38/">5. CSS 사이즈 단위 - 절대 길이와 상대 길이</a>  </p>
<ul>
<li>반응형 사이트라면 필수적인 길이에 대한 개념을 정리했다.  </li>
</ul>
<p><br/><br/>
<a href="http://baek.dev/post/34/"><img src="https://baek.dev/assets/images/post/2021/2021_039.png"/></a><br/></p>
<p><a href="http://baek.dev/post/39/">6. 포트폴리오 하나로 구글 입사 제의를 받은 - 일은 배신하지 않는다(1)</a><br>
<a href="http://baek.dev/post/40/">7. 아이들에게 코딩을 가르치지 않는 이유 - 일은 배신하지 않는다(2)</a>  </p>
<ul>
<li>개발자 에세이로, 업을 갖고 있는 모든 회사원들에게 추천하고 싶은 책이다.  </li>
<li>Google I/O 2014 발표, FWA 수상 등 세계 무대에서 활약중인 구글 UX Engineer 김종민님은 고졸이었던 PC방 알바가 포트폴리오 하나로 구글의 입사 제안을 받기까지의 과정을 책으로 다시 펴냈다. 직업을 바라보는 시각, 내가 하고 싶은 일과 해야하는 일의 괴리를 극복하는 방법, 계속 변하는 시장의 요구사항에서 살아남는 방법 등을 소개한다.   </li>
</ul>
<hr>
<p>아쉬운 점도 많지만 좋은 분들도 알게 되고 글을 꾸준히 작성한 성취감도 얻어 보람찬 활동이었다. 다음에 기회가 된다면 더 글또 커뮤니티에 기여할 수 있는 참가자가 되고 싶다.<br>
글또 여러분 고생하셨어요 :)  </p>]]></description><link>https://baek.dev/post/41/</link><guid isPermaLink="false">https://baek.dev/post/41/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 02 May 2021 12:26:00 GMT</pubDate><content:encoded>&lt;p&gt;글또 5기를 시작한지 엊그제 같은데 벌써 이번이 글또로서 작성하는 마지막 글이되었다. 사실 5기에 참여할지 말지 고민을 많이 했었다. 4기에 참여하면서 글쓰는 것이 재밌기도 했지만 글을 쥐어짜며 쓴적도 있어 쉽지 않았기 때문이다. 이후 글또 5기 모집글을 보고서는 글을 하나도 쓰지 않은 나 자신을 발견하곤 무조건 참여가 필요하다 느꼈다.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baek.dev/post/29/&quot;&gt;다시 또 글또를 시작하게 된 이유 2가지&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이번 5기에 참여하면서는 꾸준히 글을 쓰는 것보다 새로운 공부를 하면서 글을 발행한다는 것이 더 힘들었다. 나의 짧은 지식으로 부족한 글을 쓰게 되면 누군가는 부족한 지식을 습득하게되지 않을까 두렵기도 했고, 아는 지식이 짧다보니 무엇을 써야하는지도 가늠하기 어려웠다.  &lt;/p&gt;
&lt;p&gt;누군가가 약속은 깨라고 있는 것이랬던가, 거창한 플랜은 지키지 못했고 이론적인 글과 추천하고 싶은 책 리뷰 정도로 글을 작성했다.   &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;
&lt;a href=&quot;http://baek.dev/post/34/&quot;&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_033.png&quot;/&gt;&lt;/a&gt;&lt;br/&gt;  &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://baek.dev/post/33/&quot;&gt;1. 둘리 &amp;#x26; 도우너 어서오고 짤 생성기 회고&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하고 싶었던 짤 생성기 프로젝트에 대한 회고 포스팅이다.  &lt;/li&gt;
&lt;li&gt;짭짤한 트래픽 맛을 보게 해준 프로젝트를 어떻게 만들게 되었는지 공유했다.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;
&lt;a href=&quot;http://baek.dev/post/34/&quot;&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_034.png&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://baek.dev/post/34/&quot;&gt;2. 뉴노멀 중심에서 하는 2020 회고&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;코로나가 메인이었던 2020년 회멀고를 하며 한 해를 마무리한다. 끝이 보이지 않는 터널을 지나는 기분이지만 돌이켜보니 많은 기회가 있었다.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;
&lt;a href=&quot;http://baek.dev/post/34/&quot;&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2021/2021_035.png&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://baek.dev/post/36/&quot;&gt;3. 예제로 만나보는 자바스크립트 호이스팅(hoisting)&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;http://baek.dev/post/37/&quot;&gt;4. 자바스크립의 실행 컨텍스트&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;코어 자바스크립트 책을 공부하면서 일부 정리해본 내용이다.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;
&lt;a href=&quot;http://baek.dev/post/34/&quot;&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2021/2021_038.png&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://baek.dev/post/38/&quot;&gt;5. CSS 사이즈 단위 - 절대 길이와 상대 길이&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;반응형 사이트라면 필수적인 길이에 대한 개념을 정리했다.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;
&lt;a href=&quot;http://baek.dev/post/34/&quot;&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2021/2021_039.png&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://baek.dev/post/39/&quot;&gt;6. 포트폴리오 하나로 구글 입사 제의를 받은 - 일은 배신하지 않는다(1)&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;http://baek.dev/post/40/&quot;&gt;7. 아이들에게 코딩을 가르치지 않는 이유 - 일은 배신하지 않는다(2)&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개발자 에세이로, 업을 갖고 있는 모든 회사원들에게 추천하고 싶은 책이다.  &lt;/li&gt;
&lt;li&gt;Google I/O 2014 발표, FWA 수상 등 세계 무대에서 활약중인 구글 UX Engineer 김종민님은 고졸이었던 PC방 알바가 포트폴리오 하나로 구글의 입사 제안을 받기까지의 과정을 책으로 다시 펴냈다. 직업을 바라보는 시각, 내가 하고 싶은 일과 해야하는 일의 괴리를 극복하는 방법, 계속 변하는 시장의 요구사항에서 살아남는 방법 등을 소개한다.   &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;아쉬운 점도 많지만 좋은 분들도 알게 되고 글을 꾸준히 작성한 성취감도 얻어 보람찬 활동이었다. 다음에 기회가 된다면 더 글또 커뮤니티에 기여할 수 있는 참가자가 되고 싶다.&lt;br&gt;
글또 여러분 고생하셨어요 :)  &lt;/p&gt;</content:encoded></item><item><title><![CDATA[아이들에게 코딩을 가르치지 않는 이유 - 일은 배신하지 않는다(2)]]></title><description><![CDATA[<ul>
<li><a href="https://baek.dev/post/39/">일은 배신하지 않는다(1) - 포트폴리오 하나로 구글 입사 제의를 받은</a>  </li>
<li><a href="https://baek.dev/post/40/">일은 배신하지 않는다(2) - 구글에 가면 행복할까요?</a></li>
</ul>
<hr>
<h2>실리콘밸리의 구글러</h2>
<h3>인터뷰</h3>
<p>인터뷰 제안이 온 회사들 중 특정 회사는 <code>전체적인 작업 프로세스나 유저 인터랙션</code>에 대한 질문들보다 CSS와 Javascript의 속성, 개발 언어의 문법 등
<strong>인터넷에 검색하면 나올 법한 질문</strong>들을 하기시작했다. 평소 특정 언어의 기능이나 문법보단 구조를 설계하는 능력, 퍼포먼스를 높이는 방법, 모션이나 인터랙션 등의 디테일 등을 더 중요하게 생각했었기 때문에 질문에 제대로 답할 수 없었다.   </p>
<p>구글에선 구글이 내준 과제와 포트폴리오 사이트, 그리고 개인 작업인 Form Follows Function을 주제로 잡았다. 주로 어떤 의도로 만들었는지, 내가 가지고 있는 생각은 무엇인가에 대한 발표였다.
그 다음은 유명한 구글의 '화이트보드 인터뷰'였다. 주로 개발을 할 때 닥치는 문제를 어떻게 해결할 것인가에 대한 질문이었다. 정해진 답이 있다기보단 해결하는 과정을 보는 것이다.  </p>
<p>많은 사람들이 인터뷰 준비를 어떻게 해야 하는지 궁금해한다. 나의 경우엔 특별한 준비를 하지 않았고 다른 사람이 어떻게 했는지도 관심이 없었다.
심지어 리크루터가 보내준 인터뷰 관련 링크조차 읽어보지 않았다. 막상 읽어도 한 달 안에 내가 달라질 것 같지 않아서였다. 그냥 내 얘기를 했다.
지금 내가 가진 것을 그대로 보여주는 게 가장 중요하다고 생각했다. 나를 과장해서 보여줘 봤자 같이 일해보면 다 들통나기 마련이다.<br>
<code>인터뷰 준비가 힘든 이유는 내가 가진것보다 더 이야기하려고 하기 때문이다.</code>  </p>
<p>=> 나 역시 이 부분을 매우 공감한다. 우리가 언어의 API를 통채로 외우지 않는 것 처럼 더 중요한 것을 인터뷰에서 확인해야 한다고 본다. Reference, Syntax는 언제든지 공식문서를 통해 확인 할 수 있기 때문이다. 물론 이런 질문들이 단정적으로 나쁜것은 아니지만 답이 정해져있는 질문의 특성상 면접을 위해 잠깐 공부하면 충분히 극복가능한 것이라는 생각이 크다. 그래서 면접시엔 주로 <code>문제 해결을 어떻게 접근</code>하는지, <code>큰 그림 보고 점차 디테일함</code>으로 들어 갈 수 있는지 등을 더 살펴보려한다.  </p>
<blockquote>
<p>와이프가 내게 말해준 직업에 대한 정의가 있다.<br>
'직업을 고를 땐 다른 사람에게 해를 끼치지 않고 도움이 될 수 있는 직업을 선택해야 한다고 생각해.'  </p>
</blockquote>
<p><br/><br/>  </p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ke14Bhhdotg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>  
<br/><br/>  
<h3>구글에 가면 행복할까요?</h3>
<p>'구글에 가면 행복할까요?'라는 질문을 받은 적이 있다. 그 말은 목표가 구글이고 구글이라는 회사에 입사하면 본인의 삶이 달라질까요라는 말인데 사실 생각을 달리 해야 한다.
구글이 꿈이거나 목표가 돼선 안 된다. 이 세상에 완벽한 회사는 없다. 그래서 목표를 달리 해야 한다.  </p>
<p><code>내가 구글에 입사하는 것이 아니라 구글 같은 회사가 나를 원하도록 하는 것이 목표가 되어야 한다.</code> 다시 말해서 자신의 <strong>성장에 더 초점</strong>을 맞추라는 얘기다. 내 실력이 구글에갈 정도로 충분해지면 구글 입사 여부는 더는 중요한 것이 아니게 된다. 회사는 성장의 도구이지 삶의 목표가 아니다. 내가 좋아하는 일을 찾아 꾸준히 노력한 결과 구글뿐만 아니라 다른 세계적인 기업에서 러브콜을 받을 정도로 성장할 수 있었다고 생각한다.  </p>
<p><img src="https://baek.dev/assets/images/post/2021/2021_040_002.jpg">  </p>
<h2>내가 아이들에게 코딩을 가르치지 않는 이유</h2>
<p>사실 아이들의 영재성을 부추기는 프로그램을 별로 좋아하지 않는다. 어릴 땐 영재일 순 있지만, 그 친구가 커서도 영재일 거라는 보장은 없다. 오히려 어린 시절의 이런 잘못된 관심은 '나는 노력하지 않아도 되는 특별한 존재'라는 위험한 <strong>선민의식</strong>을 가지게 할 수 있다.<br>
개인적으론 어릴 땐 하나의 특정 분야를 공부하기보단 <strong>나중에 어떤 일을 하더라도 잘할 수 있는 바탕</strong>이 되는 창의성을 길러주는게 중요하다고 생각한다. 지금은 코딩이 열풍이지만, 우리 아이들이 컸을 땐 코딩은 AI가 하고 다른 직종이 또 인기를 얻을 수도 있다. 그런 <code>변화에 대처할 수 있는 창의성을 기르는 것</code>이 어떤 교육보다 중요하다고 생각한다.  </p>
<h3>창의성을 기르는 방법</h3>
<p>창의성을 기르는 훈련 방법 중의 하나가 <strong>미술</strong>이다. 나의 경험에 비추어 보면 어릴 땐 집에 있는 가전제품을 다 분해해보고, 그림도 상상해서 많이 그렸었다. 하루는 마문지 뒷면이 모눈종이처럼 그리드가 있었는데, 그 그리드를 바탕으로 재단을 하며 원하는 장난감을 만들곤 했었다. 후에 아이큐 검사 시 공간지각력 테스트에서 높은 점수를 받았었는데, 아마 이때의 경험이 도움이 되지 않았나 생각한다.  </p>
<h3>승자의 뇌</h3>
<p><strong>미술의 장점은 정답이 없다는 것</strong>이다. 이것은 아이들에게 완성의 <code>기쁨, 성취감, 목표의식, 승자의 뇌 구조</code>를 만들어 준다. 수학 같이 정답이 정해진 과목은 틀릴 수도 있기에 항상 승리하지 못한다. 하지만 미술은 내가 만든 것이 답이기에 만복되는 미술 학습을 통해 승리하는 기쁨을 뇌에 인식시켜 줄 수 있다.  이것이 승자의 뇌 구조를 만들어 자신감과 자존감을 갖게 하는 효과를 준다.  </p>
<p>&#x3C;승자의 뇌> 저자인 이안 로버트슨의 TED 강의를 보면 <strong>승자의 뇌 구조</strong>에 대해 잘 설명하고 있는데,  </p>
<ul>
<li>경쟁 상황에선 뇌의 테스토스테론의 분비량이 늘면서 도전 과제에 반응 </li>
<li>
<p>테스토스테론의 분비량이 많을수록 승리할 가능성이 높음  </p>
<ul>
<li>이는 도파민의 생성과 활동을 촉진하기 때문    </li>
</ul>
</li>
<li>
<p>승진, 합격, 완성 같이 무언가를 성취하고 이겼을 때  </p>
<ul>
<li>뇌 속 깊숙한 곳에 있는 도파민 경로에 더 명확한 길이 새겨짐    </li>
</ul>
</li>
<li>도파민은 일종의 보상으로 동기 부여, 집중력, 목표설정 등에 큰 영향을 미침  </li>
<li>이런 성공이 계속되면 뇌는 인간을 대담하게 만들고 두뇌를 더욱 영리하게 만듬    </li>
</ul>
<p><img src="https://baek.dev/assets/images/post/2021/2021_040_001.jpg">  </p>
<p>또한 뇌는 참신한(Novelty) 환경에 반응하는데, 쥐의 연구에서 참신한 환경을 접하면 <strong>새로운 뇌세포가 성장하고 기억력이 향상되는 결과</strong>를 보이다. 이런 참신성은 뇌 내 전달물질을 통해 두뇌에 영향을 미치고, <strong>두뇌의 비료</strong>라고 불리는 노르에피네프린이라는 물질을 생성시켜 학습에 도움을 주고 기억력을 향상하기도 한다.  </p>
<p>미술 교육을 통해 새로움을 접하고 무언가를 완성하며 성공하는 기쁨을 아이들에게 가르친다면 이는 다른 어떤 교육보다 뇌의 발달에 중요한 기본이 되는 교육이 될 것이라고 생각한다. <strong>스스로 뭔가를 생각해서 분해하고, 조립하고, 만드는 훈련은 나중에 아이가 자라서 어떤 직업을 선택했을 때 남들보다 뛰어난 성과를 보여줄 수 있게 한다.</strong> 이것은 내가 대학 교육을 받지 않은 고졸임에도 내 분야에서 뒤처지지 않고 일을 할 수 있는 원동력이라고 생각한다.  </p>
<p>물론 아이가 원하면 코딩을 가르치겠지만, 그것이 아니라면 나는 아이들에게 코딩이라는 특정 과목을 억지로 가르치기보단 그림을 자유롭게 그리게 한다는지, 종이로 장난감을 만들도록 도와주는 그런 학습이 더 중요하다고 생각하고 있다.  </p>
<p>=> 큰 성공만을 만들려고 하기 보다는 작은 성공, 작은 성취감을 자주 느끼는게 중요하기 하다. 그래서 목표를 최대한 잘게 쪼개는 것을 중요하게 생각한다. 특히 토이 프로젝트나 특정 목표를 가진 모임을 할 때 막연하기 보다는 구체적으로 최대한 작은 scope으로 설정할 것은 권유하곤 한다.  </p>
<p><br/><br/><br>
<br/><br/>  </p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/TzP0pBQCzM0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>  
<br/><br/>  
<h2>일해주고 욕먹는 사람이 되지 말아라</h2>
<p>중학교 댄 용돈을 벌기 위해 아버지를 따라가 일을 도왔다. 아버지께서는 항상 나와 형에게 "일해주고 욕먹는 사람이 되지 말아라"라고 말씀하셨다. 이는 '사소한 일이라도 맡아서 하기로 했으면 대충하지 말고 처음부터 끝까지 책임지고 해라'라는 뜻이었다. 아버지의 경험에서 나왔던 이 가르침은 지금도 내 가슴에 남아서 내가 일하는 습관을 만들어줬다. 작은 것 하나를 만들더라도 <code>대충 하지 않고 최선을 다해 만들어내면 그런 모습이 쌓여서 신뢰를 만들고</code> 나 자신의 가치를 높이는 것이라고 지금도 생각한다. 덕분에 어떤 일을 시켜도 믿고 맡길 수 있는 동료라는 말을 듣고 한다.  </p>
<h2>짜낸다</h2>
<p>나는 작업을 할 때 <strong>'짜낸다'</strong>라는 표현을 쓴다. 한번 만든 것으로 끝내지 않고 더 나은 방향은 없는지 고민하고 고민하는 과정이 마치 머릿속의 생각을 마지막 한 방울까지 짜내는 것과 비슷하기 때문이다. 남들이 보기에 쉬워 보이는 작업도 '짜낸다'라고 말할 만큼 생각에 생각을 거쳐 만들어내는 것들이다.  </p>
<hr>
<p>정말 너무 좋은 책을 오랜만에 만났다. <a href="https://coupa.ng/bVbAJ3">&#x3C;일은 배신하지 않는다></a>는 개발자의 에세이이지만, 개발자가 아닌 다른 일을 하는 모든 이들에게 추천하고 싶다. 겉치레가 아닌 본질에 대한 내용이 많기 때문이다.  </p>
<ul>
<li><a href="https://baek.dev/post/39/">일은 배신하지 않는다(1) - 포트폴리오 하나로 구글 입사 제의를 받은</a>  </li>
<li><a href="https://baek.dev/post/40/">일은 배신하지 않는다(2) - 구글에 가면 행복할까요?</a>  </li>
</ul>
<h5>References</h5>
<ul>
<li><a href="https://coupa.ng/bVbAJ3">&#x3C;일은 배신하지 않는다>, 2021 아이스크림미디어</a>  </li>
</ul>]]></description><link>https://baek.dev/post/40/</link><guid isPermaLink="false">https://baek.dev/post/40/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sat, 17 Apr 2021 15:20:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://baek.dev/post/39/&quot;&gt;일은 배신하지 않는다(1) - 포트폴리오 하나로 구글 입사 제의를 받은&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://baek.dev/post/40/&quot;&gt;일은 배신하지 않는다(2) - 구글에 가면 행복할까요?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;실리콘밸리의 구글러&lt;/h2&gt;
&lt;h3&gt;인터뷰&lt;/h3&gt;
&lt;p&gt;인터뷰 제안이 온 회사들 중 특정 회사는 &lt;code&gt;전체적인 작업 프로세스나 유저 인터랙션&lt;/code&gt;에 대한 질문들보다 CSS와 Javascript의 속성, 개발 언어의 문법 등
&lt;strong&gt;인터넷에 검색하면 나올 법한 질문&lt;/strong&gt;들을 하기시작했다. 평소 특정 언어의 기능이나 문법보단 구조를 설계하는 능력, 퍼포먼스를 높이는 방법, 모션이나 인터랙션 등의 디테일 등을 더 중요하게 생각했었기 때문에 질문에 제대로 답할 수 없었다.   &lt;/p&gt;
&lt;p&gt;구글에선 구글이 내준 과제와 포트폴리오 사이트, 그리고 개인 작업인 Form Follows Function을 주제로 잡았다. 주로 어떤 의도로 만들었는지, 내가 가지고 있는 생각은 무엇인가에 대한 발표였다.
그 다음은 유명한 구글의 &apos;화이트보드 인터뷰&apos;였다. 주로 개발을 할 때 닥치는 문제를 어떻게 해결할 것인가에 대한 질문이었다. 정해진 답이 있다기보단 해결하는 과정을 보는 것이다.  &lt;/p&gt;
&lt;p&gt;많은 사람들이 인터뷰 준비를 어떻게 해야 하는지 궁금해한다. 나의 경우엔 특별한 준비를 하지 않았고 다른 사람이 어떻게 했는지도 관심이 없었다.
심지어 리크루터가 보내준 인터뷰 관련 링크조차 읽어보지 않았다. 막상 읽어도 한 달 안에 내가 달라질 것 같지 않아서였다. 그냥 내 얘기를 했다.
지금 내가 가진 것을 그대로 보여주는 게 가장 중요하다고 생각했다. 나를 과장해서 보여줘 봤자 같이 일해보면 다 들통나기 마련이다.&lt;br&gt;
&lt;code&gt;인터뷰 준비가 힘든 이유는 내가 가진것보다 더 이야기하려고 하기 때문이다.&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;=&gt; 나 역시 이 부분을 매우 공감한다. 우리가 언어의 API를 통채로 외우지 않는 것 처럼 더 중요한 것을 인터뷰에서 확인해야 한다고 본다. Reference, Syntax는 언제든지 공식문서를 통해 확인 할 수 있기 때문이다. 물론 이런 질문들이 단정적으로 나쁜것은 아니지만 답이 정해져있는 질문의 특성상 면접을 위해 잠깐 공부하면 충분히 극복가능한 것이라는 생각이 크다. 그래서 면접시엔 주로 &lt;code&gt;문제 해결을 어떻게 접근&lt;/code&gt;하는지, &lt;code&gt;큰 그림 보고 점차 디테일함&lt;/code&gt;으로 들어 갈 수 있는지 등을 더 살펴보려한다.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;와이프가 내게 말해준 직업에 대한 정의가 있다.&lt;br&gt;
&apos;직업을 고를 땐 다른 사람에게 해를 끼치지 않고 도움이 될 수 있는 직업을 선택해야 한다고 생각해.&apos;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;  &lt;/p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/ke14Bhhdotg&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;  
&lt;br/&gt;&lt;br/&gt;  
&lt;h3&gt;구글에 가면 행복할까요?&lt;/h3&gt;
&lt;p&gt;&apos;구글에 가면 행복할까요?&apos;라는 질문을 받은 적이 있다. 그 말은 목표가 구글이고 구글이라는 회사에 입사하면 본인의 삶이 달라질까요라는 말인데 사실 생각을 달리 해야 한다.
구글이 꿈이거나 목표가 돼선 안 된다. 이 세상에 완벽한 회사는 없다. 그래서 목표를 달리 해야 한다.  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;내가 구글에 입사하는 것이 아니라 구글 같은 회사가 나를 원하도록 하는 것이 목표가 되어야 한다.&lt;/code&gt; 다시 말해서 자신의 &lt;strong&gt;성장에 더 초점&lt;/strong&gt;을 맞추라는 얘기다. 내 실력이 구글에갈 정도로 충분해지면 구글 입사 여부는 더는 중요한 것이 아니게 된다. 회사는 성장의 도구이지 삶의 목표가 아니다. 내가 좋아하는 일을 찾아 꾸준히 노력한 결과 구글뿐만 아니라 다른 세계적인 기업에서 러브콜을 받을 정도로 성장할 수 있었다고 생각한다.  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2021/2021_040_002.jpg&quot;&gt;  &lt;/p&gt;
&lt;h2&gt;내가 아이들에게 코딩을 가르치지 않는 이유&lt;/h2&gt;
&lt;p&gt;사실 아이들의 영재성을 부추기는 프로그램을 별로 좋아하지 않는다. 어릴 땐 영재일 순 있지만, 그 친구가 커서도 영재일 거라는 보장은 없다. 오히려 어린 시절의 이런 잘못된 관심은 &apos;나는 노력하지 않아도 되는 특별한 존재&apos;라는 위험한 &lt;strong&gt;선민의식&lt;/strong&gt;을 가지게 할 수 있다.&lt;br&gt;
개인적으론 어릴 땐 하나의 특정 분야를 공부하기보단 &lt;strong&gt;나중에 어떤 일을 하더라도 잘할 수 있는 바탕&lt;/strong&gt;이 되는 창의성을 길러주는게 중요하다고 생각한다. 지금은 코딩이 열풍이지만, 우리 아이들이 컸을 땐 코딩은 AI가 하고 다른 직종이 또 인기를 얻을 수도 있다. 그런 &lt;code&gt;변화에 대처할 수 있는 창의성을 기르는 것&lt;/code&gt;이 어떤 교육보다 중요하다고 생각한다.  &lt;/p&gt;
&lt;h3&gt;창의성을 기르는 방법&lt;/h3&gt;
&lt;p&gt;창의성을 기르는 훈련 방법 중의 하나가 &lt;strong&gt;미술&lt;/strong&gt;이다. 나의 경험에 비추어 보면 어릴 땐 집에 있는 가전제품을 다 분해해보고, 그림도 상상해서 많이 그렸었다. 하루는 마문지 뒷면이 모눈종이처럼 그리드가 있었는데, 그 그리드를 바탕으로 재단을 하며 원하는 장난감을 만들곤 했었다. 후에 아이큐 검사 시 공간지각력 테스트에서 높은 점수를 받았었는데, 아마 이때의 경험이 도움이 되지 않았나 생각한다.  &lt;/p&gt;
&lt;h3&gt;승자의 뇌&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;미술의 장점은 정답이 없다는 것&lt;/strong&gt;이다. 이것은 아이들에게 완성의 &lt;code&gt;기쁨, 성취감, 목표의식, 승자의 뇌 구조&lt;/code&gt;를 만들어 준다. 수학 같이 정답이 정해진 과목은 틀릴 수도 있기에 항상 승리하지 못한다. 하지만 미술은 내가 만든 것이 답이기에 만복되는 미술 학습을 통해 승리하는 기쁨을 뇌에 인식시켜 줄 수 있다.  이것이 승자의 뇌 구조를 만들어 자신감과 자존감을 갖게 하는 효과를 준다.  &lt;/p&gt;
&lt;p&gt;&amp;#x3C;승자의 뇌&gt; 저자인 이안 로버트슨의 TED 강의를 보면 &lt;strong&gt;승자의 뇌 구조&lt;/strong&gt;에 대해 잘 설명하고 있는데,  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;경쟁 상황에선 뇌의 테스토스테론의 분비량이 늘면서 도전 과제에 반응 &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;테스토스테론의 분비량이 많을수록 승리할 가능성이 높음  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이는 도파민의 생성과 활동을 촉진하기 때문    &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;승진, 합격, 완성 같이 무언가를 성취하고 이겼을 때  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;뇌 속 깊숙한 곳에 있는 도파민 경로에 더 명확한 길이 새겨짐    &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;도파민은 일종의 보상으로 동기 부여, 집중력, 목표설정 등에 큰 영향을 미침  &lt;/li&gt;
&lt;li&gt;이런 성공이 계속되면 뇌는 인간을 대담하게 만들고 두뇌를 더욱 영리하게 만듬    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2021/2021_040_001.jpg&quot;&gt;  &lt;/p&gt;
&lt;p&gt;또한 뇌는 참신한(Novelty) 환경에 반응하는데, 쥐의 연구에서 참신한 환경을 접하면 &lt;strong&gt;새로운 뇌세포가 성장하고 기억력이 향상되는 결과&lt;/strong&gt;를 보이다. 이런 참신성은 뇌 내 전달물질을 통해 두뇌에 영향을 미치고, &lt;strong&gt;두뇌의 비료&lt;/strong&gt;라고 불리는 노르에피네프린이라는 물질을 생성시켜 학습에 도움을 주고 기억력을 향상하기도 한다.  &lt;/p&gt;
&lt;p&gt;미술 교육을 통해 새로움을 접하고 무언가를 완성하며 성공하는 기쁨을 아이들에게 가르친다면 이는 다른 어떤 교육보다 뇌의 발달에 중요한 기본이 되는 교육이 될 것이라고 생각한다. &lt;strong&gt;스스로 뭔가를 생각해서 분해하고, 조립하고, 만드는 훈련은 나중에 아이가 자라서 어떤 직업을 선택했을 때 남들보다 뛰어난 성과를 보여줄 수 있게 한다.&lt;/strong&gt; 이것은 내가 대학 교육을 받지 않은 고졸임에도 내 분야에서 뒤처지지 않고 일을 할 수 있는 원동력이라고 생각한다.  &lt;/p&gt;
&lt;p&gt;물론 아이가 원하면 코딩을 가르치겠지만, 그것이 아니라면 나는 아이들에게 코딩이라는 특정 과목을 억지로 가르치기보단 그림을 자유롭게 그리게 한다는지, 종이로 장난감을 만들도록 도와주는 그런 학습이 더 중요하다고 생각하고 있다.  &lt;/p&gt;
&lt;p&gt;=&gt; 큰 성공만을 만들려고 하기 보다는 작은 성공, 작은 성취감을 자주 느끼는게 중요하기 하다. 그래서 목표를 최대한 잘게 쪼개는 것을 중요하게 생각한다. 특히 토이 프로젝트나 특정 목표를 가진 모임을 할 때 막연하기 보다는 구체적으로 최대한 작은 scope으로 설정할 것은 권유하곤 한다.  &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;br&gt;
&lt;br/&gt;&lt;br/&gt;  &lt;/p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/TzP0pBQCzM0&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;  
&lt;br/&gt;&lt;br/&gt;  
&lt;h2&gt;일해주고 욕먹는 사람이 되지 말아라&lt;/h2&gt;
&lt;p&gt;중학교 댄 용돈을 벌기 위해 아버지를 따라가 일을 도왔다. 아버지께서는 항상 나와 형에게 &quot;일해주고 욕먹는 사람이 되지 말아라&quot;라고 말씀하셨다. 이는 &apos;사소한 일이라도 맡아서 하기로 했으면 대충하지 말고 처음부터 끝까지 책임지고 해라&apos;라는 뜻이었다. 아버지의 경험에서 나왔던 이 가르침은 지금도 내 가슴에 남아서 내가 일하는 습관을 만들어줬다. 작은 것 하나를 만들더라도 &lt;code&gt;대충 하지 않고 최선을 다해 만들어내면 그런 모습이 쌓여서 신뢰를 만들고&lt;/code&gt; 나 자신의 가치를 높이는 것이라고 지금도 생각한다. 덕분에 어떤 일을 시켜도 믿고 맡길 수 있는 동료라는 말을 듣고 한다.  &lt;/p&gt;
&lt;h2&gt;짜낸다&lt;/h2&gt;
&lt;p&gt;나는 작업을 할 때 &lt;strong&gt;&apos;짜낸다&apos;&lt;/strong&gt;라는 표현을 쓴다. 한번 만든 것으로 끝내지 않고 더 나은 방향은 없는지 고민하고 고민하는 과정이 마치 머릿속의 생각을 마지막 한 방울까지 짜내는 것과 비슷하기 때문이다. 남들이 보기에 쉬워 보이는 작업도 &apos;짜낸다&apos;라고 말할 만큼 생각에 생각을 거쳐 만들어내는 것들이다.  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;정말 너무 좋은 책을 오랜만에 만났다. &lt;a href=&quot;https://coupa.ng/bVbAJ3&quot;&gt;&amp;#x3C;일은 배신하지 않는다&gt;&lt;/a&gt;는 개발자의 에세이이지만, 개발자가 아닌 다른 일을 하는 모든 이들에게 추천하고 싶다. 겉치레가 아닌 본질에 대한 내용이 많기 때문이다.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://baek.dev/post/39/&quot;&gt;일은 배신하지 않는다(1) - 포트폴리오 하나로 구글 입사 제의를 받은&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://baek.dev/post/40/&quot;&gt;일은 배신하지 않는다(2) - 구글에 가면 행복할까요?&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;References&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://coupa.ng/bVbAJ3&quot;&gt;&amp;#x3C;일은 배신하지 않는다&gt;, 2021 아이스크림미디어&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[포트폴리오 하나로 구글 입사 제의를 받은 - 일은 배신하지 않는다(1)]]></title><description><![CDATA[<ul>
<li><a href="https://baek.dev/post/39/">일은 배신하지 않는다(1) - 포트폴리오 하나로 구글 입사 제의를 받은</a>  </li>
<li><a href="https://baek.dev/post/40/">일은 배신하지 않는다(2) - 구글에 가면 행복할까요?</a></li>
</ul>
<hr>
<p>혹시 <strong>김종민</strong>님을 아시나요?<br>
디자이너, 개발자를 포함해 프론트엔드 분야에 종사한다면 적어도 한 번은 이분의 이름을 들어보았거나 혹은 그의 작업물을 접해보았을 것 같다.  </p>
<p>고등학교를 졸업하고 친구 따라 국비 교육과정을 듣게 된 것이 그의 커리어 시작이었다. 이후 국내에서 웹에이전시 디자이너로 시작해 미국 퍼스트본의 플래시 디벨로퍼를 거쳐 현재는 <code>구글에서 UX Engineer</code>로 재직 중이다. 종민님은 코드로 만드는 애니메이션, 인터랙션, 미니멀한 디자인에 관심이 많아 스스로를 인터렉티브 디벨로퍼라고 칭한다. 관심 있고 좋아하는 내용을 많은 개인 작업으로 풀어내며, 그 결과 Red Dot Design Award, iF Design Award, W3 Award, The FWA 등 다양한 수상을 하기도 했다.  </p>
<p>내가 종민님을 처음 알게 된 계기는 매스미디어를 통해서였다. 평소 다큐 보는 것을 좋아하는 나는 우연히 <a href="http://program.tving.com/tvn/2020tvnshift">tvN의 Shift 6화 - 질문으로 자라는 아이</a>에서 인터뷰이로 참여한 종민님을 처음 알게 되었다.  </p>
<p><br/><br/></p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/BAODHvuHzk8" title="tvN Shift E06 질문으로 자라는 아이" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>  
<br/>
<iframe width="560" height="315" src="https://www.youtube.com/embed/LxFQUk4n8ss" title="EBS 특별기획 - 미래 교육을 묻다" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>  
<p><br/><br/>  </p>
<p>위 유튜브 채널에서 볼 수 있듯 종민님은 <a href="https://www.youtube.com/c/cmiscm/featured">유튜브</a>도 함께 운영하고 있다. 채널을 알게 된 뒤에 업로드된 영상을 처음부터 끝까지 모두 살펴보며 알 수 없는 두근거림과 간지러움이 피어올랐다.  </p>
<blockquote>
<p>그래, 이거다!  </p>
</blockquote>
<p>종민님을 알게 된 시기에 나는 <strong>번아웃</strong>을 겪고 있었고, 커리어에 대한 고민이 많았다. 종민님의 영상, 작업물 등을 통해 간접적으로 도움을 받아 이 고민을 끝내고 결정을 내릴 수 있게 되었다.<br>
그날부터 설레여 잠을 잘 수가 없었던 그 밤들이 아직도 생생하다.  </p>
<br/>  
<p>여하튼 디지털 작업 외에도 오프라인 작업물들도 만드는데 그중 <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=63770885&#x26;start=slayer">인터랙티브 디벨로퍼</a>라는 책도 있었다. 아쉽게 책은 절판이 되어 구할 수 없었다. 책을 다시 찾는 이가 많아지면서 몇 의 가격으로 중고 거래되는 것을 본 종민님은 5년배 만에 책 내용을 보강하여 이번에 다시 출간했다.  </p>
<p>그 책이 바로 <a href="https://coupa.ng/bVbAJ3">&#x3C;일은 배신하지 않는다></a>. 종민님은 일을 굉장히 중요하게 생각하는 사람 중의 한 명이라고 자신을 소개하는 것으로 책을 시작한다.     </p>
<p><a href="https://coupa.ng/bVbAJ3" target="_blank"><img alt="책 - 일은 배신하지 않는다" src="https://image.aladin.co.kr/product/26683/79/cover500/k412730981_1.jpg"></a>  </p>
<p><br/><br/>  </p>
<blockquote>
<p>일은 단순히 돈을 벌고 먹고 살기 위해서 하는 것이 아니라,<br>
정말 본인의 자아발전을 위해서,<br>
또 내가 어떤 사람으로 살아가는가를 정의하는,<br>
삶에 있어서 중요한 부분이라고 생각한다.  </p>
<p>항상 뭔가를 만드는 사람이 되고 싶었고,<br>
나이가 들어서도 계속해서 나만의 일을 하는 그런 모습을 꿈꿨다.<br>
이런 나의 일을 대하는 진지한 자세를 딸에게 혹은 독자에게 들려주고 싶었다.  </p>
</blockquote>
<p><br/><br/>  </p>
<p><img src="https://baek.dev/assets/images/post/2021/2021_039_001.jpg">  </p>
<p><br/><br/>  </p>
<p>이 페이지가 <a href="https://coupa.ng/bVbAJ3">&#x3C;일은 배신하지 않는다></a>의 내용을 한 장으로 정리한 부분이라고 볼 수 있다.  </p>
<ul>
<li>돈을 많이 번다고 해서 나보다 적게 버는 사람보다 그 차액만큼 더 가치가 있는 사람일까.  </li>
<li>나와 대화하는 방법 찾아 내가 좋아하는 것과 하고 싶은 것을 통해 어떤 작업을 만드는 사람이 되고 싶은가에 대한 끊임없이 고민하고 실행해야 함을 강조한다.  </li>
</ul>
<p>이 강조한 부분을 처음 종민님의 작업 설명을 들을 때 느낄 수 있었다. 작업 요소 하나하나 그냥 작업한 것은 단 하나도 없었다. <code>모든 요소에 고민이 있고, 모든 요소에 이유가 있었다.</code>  </p>
<p>이제 아래 내용부터는 <a href="https://coupa.ng/bVbAJ3">&#x3C;일은 배신하지 않는다></a> 책에서 인상 깊은 부분들을 일부 소개한다.  </p>
<h2>나의 작업 철학</h2>
<p>고등학교 졸업 당시 나의 희망 직업은 영화의 미니어처 등에 쓰이는 모형을 만드는 장인이었다. 그때 내 재능에 대해 스스로 진지하게 반문을 해본 적이 있다. 모형을 만드는 장인이 되려면 처음부터 모형을 직접 빚어 내고 완성을 해야 한다고 생각했는데 나는 그러지 못했다. 내 실력은 <code>이미 만들어진 모형을 사서 조립하고 색칠하는 수준</code>밖에 되지 않는다는 것을 깨달았다. 즉, 취미로는 훌륭할지 몰라도 직업이라고 말하기에는 부족했다.  </p>
<p>내가 <code>그 분야의 진짜가 되기 위해선 본질이 되는 작업이 가능</code>해야 한다고 생각했다. 개발의 본질은 개발 코드를 사용해 구조를 설계하고 움직임을 만드는 일이다. 코드에 대한 이해가 없이 툴(Tool)이나 라이브러리만을 사용해 결과물을 만드는 것은 시중에서 모형을 사다가 조립하고 색칠만 하는 취미 정도의 수준과 다르지 않다는 생각이었다.  </p>
<p>모두가 편리한 방법을 찾을 때 나는 어렵고 시간이 걸려도 개발 코드만을 이용해서 움직임을 만들려고 노력했었다. 플래시라는 프로그램의 특정 기능에 의지하지 말고 개발의 본질인 <strong>코드</strong>를 이해해야 한다고 생각해서였다. 사수나 멘토가 없었던 것이 이런 부분에선 장점이 됐다고 생각한다. 누가 가르쳐준 대로만 따라 하지 않고 스스로 생각하고 결정한 방향으로 공부할 수 있었기 때문이다.  </p>
<p>그러므로 코드에 대한 이해 없이 라이브러리에만 의존하는 것은 피해야 한다. 하지 않는 것과 할 수 없는 것엔 큰 차이가 있다. 라이브러리를 사용하는 것이 문제가 되진 않는다. <strong>문제는 라이브러리를 사용해 만들어진 결과물이 자신의 실력이라고 생각</strong>하는 경우다.  </p>
<blockquote>
<p>Collector란?<br>
실력을 쌓는 데 시간을 쓰기 보단 라이브러리를 수집하는 데 더 많은 시간을 보내는 사람들  </p>
</blockquote>
<p>본질에 대한 나의 작업 철학은 구글에서도 빛을 발했다. 처음 구에서 했던 작업은 더 나은 구글 웹사이트를 위해 프로토타입을 만드는 일이었다. 보통은 프로토타입 작업을 위해 편리한 프로토타이핑 툴이나 라이브러리를 사용한다. 하지만 나는 어떤 툴이나 라이브러리를 사용하지 않고 네이티브 언어인 Javascript 코드만으로 프로토타입을 만들었다. 이미 누군가 만들어둔 코드를 사용하는 것이 아니라 각각의 디자인에 최적화된 코드를 만들어서 성능을 높였다. 결과적으로 이런 나의 작업 철학이 모바일에서 부드러운 움직임을 위한 해결책을 생각해내는 원천이 되었다.  </p>
<p>툴이나 라이브러리는 분명 편리한 점이 많지만, 실질적인 코드에 대한 이해가 부족하고, 툴에서 제공하는 한정된 기능만을 사용할 수 있다는 단점이 있다. 어려워도 툴의 도움 없이 개발의 본질인 코드를 이해하고 사용한다면 더 넓은 시야를 가질 수 있다.  </p>
<p><br/><br/>  </p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/cpEeqACsF_Q" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>  
<p><br/><br/>  </p>
<h2>개인 작업의 중요성</h2>
<p>세미나나 이메일로 가장 많이 받는 질문 중의 하나는 '종민님처럼 되려면 어떻게 해야 하나요?'다. 내가 만드는 작업물들처럼 재미있는 것을 만드는 사람이 되고, 그러려면 어떤 방향으로 공부/취직을 해야 하는지 묻는 질문이다. 남들이 봐도 재미있을 것 같은 화려한 비주얼의 작업들'만' 만들면서 회사에서 인정도 받고 돈도 많이 벌면 좋겠지만, 사실 그런 회사는 존재하지 않는다.  </p>
<ul>
<li>나는 이런 재미있는 일을 하고 싶은데 회사에선 재미없는 일만 시킨다  </li>
<li>만약 내가 디자이너인데 개발을 할 줄 안다고 하면 내 업무 이외에도 잡다한 일을 나에게 시켜서 힘들다  </li>
</ul>
<p>라는 질문들도 많이 받는다. 그래서 나는 개인 작업이 중요하다고 말하고 싶다.  </p>
<p><strong>아무리 말로 내가 뭘 잘한다, 뭘 하고 싶다고 말해봐도 그게 먹힐 확률은 굉장히 낮다.</strong> 하지만 작업으로 보여준다면 얘기가 다르다. 이는 내가 개인 작업을 하면서 느낀 부분인데, 내가 만드는 개인 작업물들이 쌓이고 점점 세상에 알려지면서, 회사 내의 사람들까지 나를 그런 작업을 잘하는 사람으로 인식하고 있었다. 자연스럽게 회사에 그런 류의 일이 생겼을 때 나를 중심으로 팀이 꾸려지게 된다. 즉, 회사에서 내가 하고 싶은 부분을 맡겨줄 떄까지 기다릴 것이 아니라, <code>스스로 잘할 수 있는 분야를 개인 작업으로 만들어 세상에 공개하는 것</code>이다.  </p>
<p>회사에서 나에게 정해준 타이틀은 중요하지 않다. 커리어에 대한 고민도 비슷한데, 나는 조심스럽게 내 직업은 내가 만들어가는 것이라고 말해주고 싶다. 눈 앞의 정해진 특정 롤에 맞춰 취업하는 것이 목표가 되기보단 내가 어떤 작업에 더 흥미를 느끼는지를 고민해 볼 필요가 있다.  </p>
<br/>  
<p><img src="https://baek.dev/assets/images/post/2021/2021_039_003.jpg">  </p>
<h2>사수가 없어도 나를 성장 시킬 수 있는 방법</h2>
<p>지금도 새로운 것을 배울 때 즐겨 쓰는 방법인데 <code>책을 한 권만 읽는 것이 아니라 여러 권의 다른 작가가 쓴 책을 읽어보는 것이다.</code> 어떤 책이든지 중요한 부분은 자주 나오기 때문에 중요한 내용일수록 중복되어 읽히므로 기억에 더 잘 남고 이해가 안 가는 부분은 여러 작가의 다양한 설명으로 있으니 이해하기 쉽다.  </p>
<p>그동안 프로젝트를 진행하며 실무에서 느꼈던 부분과 여러 권의 책을 읽으며 이해했던 부분이 더해지면서 실력이 월등하게 늘었다. 이 방법은 이렇다 할 사수나 멘토가 없었던 나를 스스로 성장시키는 데 큰 도움이 되었다. 프래시라는 한 가지 언어가 이해되자 프로그래밍의 규칙이 눈에 보였고 그 후엔 Javascript, Object-C, Java for Android 등 여러 가지 언어를 배울 때 힘들지 않고 빠르게 배울 수 있었다.  </p>
<h2>시대가 바뀌어도 살아남는 방법</h2>
<p>1970년대 미싱사로 일하시던 엄마 생각이 났다. 엄마의 재봉 기술은 시대가 바뀌고 공장의 자동화와 중국의 값싼 생산력 등에 밀려 한국에선 이제 수요가 그다지 없는 기술이 되었다. 그것을 나에게 적용해보니 나 역시 '지금은 풀래시라는 기술로 그럭저럭 먹고살고 있지만, <code>시대가 바뀌어서 이 기술이 필요없어지면 어떡하지?</code>'라는 생각이 들었다. 그때 두 가지 해결책을 생각해서 실천에 옮겼는데 이는 사실 이 책에서 가장 말하고 싶은 부분이기도 하다.  </p>
<p><img src="https://baek.dev/assets/images/post/2021/2021_039_004.jpg">  </p>
<h3>플래시라는 특정 기술이 아닌 나만의 내공을 가지기 위해 노력</h3>
<ul>
<li>초점을 개발 언어에서 콘텐츠로 옮김  </li>
<li>웹사이트의 디자인과 모션의 디테일 수준을 높이기 위해 고민  </li>
</ul>
<p>시장에서 요구하는 기술은 항상 빠르게 변하기 때문에 한 가지 기술에만 의조하는 사람이 되는 것은 위험한 발상이라는 생각이 있었다. 시대가 바뀌어도 변하지 않는 나만의 내공을 가져야겠다고 생각했다.  </p>
<h3>크게 보고 눈앞의 작은 것에 연연하지 말자</h3>
<p>당장 눈 앞의 연봉, 직급 등에 연연해서 스트레스를 받거나 승진을 위해 윗사람에게 아부하는 데 시간을 쓰지 말고, <code>내가 되고자 하는 사람</code>이 될 수 있도록 실력을 쌓고 싶었다. 좁은 시야로 눈 앞의 작은 것을 가지기 위해 에너지를 낭비하지 말고 오직 내가 좋아하는 일에 모든 에너지를 쏟고 싶었다. 일에만 집중하자는 생각은 지금도 변함이 없는데, '현재의 연봉, 직급 등에 연연해서 회사를 쉽게 옮기거나 하지 말자'는 생각을 하게 해주었다.  </p>
<p>회사에서 어떤 일을 하느냐, 혹은 내가 얼마나 성장하느냐가 중요하지 연봉 몇백만 원을 더 받으려고 회사를 옮기는 것이나, 남에게 보이기 위한 내 직급이 무엇인가는 중요하지 않다는 생각이었다. 회사를 옮기게 되면 또다시 새로운 곳에서 적응하고 <strong>신뢰</strong>를 쌓기 위한 시간과 에너지가 낭비된다고 생각했다.  </p>
<h2>감을 늘리는 방법</h2>
<p>모션을 디자인할 땐 해당 디자인에 맞는 모션을 찾기 위해 많은 테스트를 해보는 것이 가장 좋은 방법이다. 그래서 모션감이 중요한데 많은 작업을 통해 쌓인 모션감은 어떤 것이 아름다운지를 구별할 수 있는 눈을 갖게 한다. 모션감을 늘리는 방법은 많이 많들어 보는 것 외엔 없다. <strong>눈으로 볼 땐 쉬워 보여도</strong> 직접 따라 만들어보면 쉽지 않음을 알게 된다. 시간과 가속/감속의 미묘한 차이가 다른 느낌의 모션을 만들어내기 때문이다. </p>
<br/>  
<p><img src="https://baek.dev/assets/images/post/2021/2021_039_005.jpg">  </p>
<h2>외국 회사에서 느끼는 차이점과 조심해야 할 것들</h2>
<h3>겸손은 이제 그만</h3>
<p>퍼스트본에서 일할 때 옆자리의 동료가 모두가 아니오라고 할 때 혼자 '예'라고 한 경우가 있었는데 이게 나에겐 참 생소한 모습이었다. 생각해보면 그동안 나는 <code>내 의견을 말하기보단 상대방의 의사를 살펴 의견을 말하고 동조를 얻어야</code>만 올바른 의견을 말한 것 같은 생각이 들었기 때문이다. 자유로운 의견제시는 자신감 있는 당당한 모습을 말하고 이는 지나친 겸손과 반대된다.  </p>
<p>겸손이 몸에 벤 한국 사람들, 나 역시 '너 정말 잘하는구나!'라는 말을 들을 때면, 겉으론 '야휴 제가 뭐 한거 있나요, 다 된 밥사에 숟가락 얹은 것뿐이죠'라고 대답하곤 했다. 이런 습성때문에 처음 퍼스트본에 와서 '나는 별로 잘하는 것도 없는데 그냥 열심히 한다고 해서 뽑혔다.'라고 했던 적이 있다. 이후 어떤 직원이 나를 표현할 때 내 말을 그대로 인용해 말하는 것을 알게 되었다. 겸손은 분명 세계 어느 나라에서나 통하는 미덕이지만, 지나친 겸손은 미국에선 자신감 부족으로 비칠 수 있다.  </p>
<p>누군가 당신에 대해 칭찬을 해준다면 겸손보단 칭찬에 대해 <strong>고맙다고 대답</strong>하는 것이 좋다고 생각한다.  </p>
<h3>의견은 자유롭게</h3>
<p>미국은 모두들 자기 의견을 내세우는 데 거리낌이 없다. 예를 들어 내가 낸 의견에 격렬하게 반대하다가도 회의가 끝나면 뒤끝 없이 웃으면서 이야기하는 것이 이들의 일상이다. 막 입사한 인턴이 전체 회의에서 자신의 의견을 당당하게 이야기하는 모습을 볼대면, 한국에서 시키는 대로 묵묵히 일했던 내 모습과 비교되어 많은 생각을 하게 한다. 특히 미국에선 회의를 할 때 의견을 내지 않으면 '내 의견에 동조하는 내 편'이 아니라 <code>자신의 생각을 말하지 못하는 '생각이 없는 사람'</code>으로 보일 수 있으니 조심해야 한다.  </p>
<h2>위기는 기회</h2>
<p>시장은 플래시라는 기술보단 HTML5라는 신기술을 선호하기 시작했다. All Flash 사이트를 만드는 것은 웹 표준에 맞지도 않고 스마트폰과 태블릿 PC의 등장으로 플래시 플레이어가 설치되지 않는 디바이스들이 늘어나자 웹어서 플래시는 급격히 내리막길을 걷게 되었다. 이때 많은 플래시 디벨로퍼들에게 위기 상황이었다. HTML5 프로젝트가 하나둘씩 늘어나며 변화에 적응한 사람, 그렇지 못한 사람도 생겨나기 시작했다.<br>
그때 동료의 HTML5 개인 작업물을 보고 HTML5의 가능성을 실감했다. 실력 있는 동료를 보고 자극받아 내 실력을 더 쌓을 수 있는 기회가 많은 것이 <strong>해외 취업의 장점</strong> 중 하나라고 생각한다.  </p>
<br/>  
<p><img src="https://baek.dev/assets/images/post/2021/2021_039_002.jpg">  </p>
<p>그럼 다음 글에 이어서 책을 마저 소개하겠다.   </p>
<ul>
<li><a href="https://baek.dev/post/39/">일은 배신하지 않는다(1) - 포트폴리오 하나로 구글 입사 제의를 받은</a>  </li>
<li><a href="https://baek.dev/post/40/">일은 배신하지 않는다(2) - 구글에 가면 행복할까요?</a></li>
</ul>
<h5>References</h5>
<ul>
<li><a href="https://coupa.ng/bVbAJ3">&#x3C;일은 배신하지 않는다>, 2021 아이스크림미디어</a>  </li>
</ul>]]></description><link>https://baek.dev/post/39/</link><guid isPermaLink="false">https://baek.dev/post/39/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 04 Apr 2021 14:34:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://baek.dev/post/39/&quot;&gt;일은 배신하지 않는다(1) - 포트폴리오 하나로 구글 입사 제의를 받은&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://baek.dev/post/40/&quot;&gt;일은 배신하지 않는다(2) - 구글에 가면 행복할까요?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;혹시 &lt;strong&gt;김종민&lt;/strong&gt;님을 아시나요?&lt;br&gt;
디자이너, 개발자를 포함해 프론트엔드 분야에 종사한다면 적어도 한 번은 이분의 이름을 들어보았거나 혹은 그의 작업물을 접해보았을 것 같다.  &lt;/p&gt;
&lt;p&gt;고등학교를 졸업하고 친구 따라 국비 교육과정을 듣게 된 것이 그의 커리어 시작이었다. 이후 국내에서 웹에이전시 디자이너로 시작해 미국 퍼스트본의 플래시 디벨로퍼를 거쳐 현재는 &lt;code&gt;구글에서 UX Engineer&lt;/code&gt;로 재직 중이다. 종민님은 코드로 만드는 애니메이션, 인터랙션, 미니멀한 디자인에 관심이 많아 스스로를 인터렉티브 디벨로퍼라고 칭한다. 관심 있고 좋아하는 내용을 많은 개인 작업으로 풀어내며, 그 결과 Red Dot Design Award, iF Design Award, W3 Award, The FWA 등 다양한 수상을 하기도 했다.  &lt;/p&gt;
&lt;p&gt;내가 종민님을 처음 알게 된 계기는 매스미디어를 통해서였다. 평소 다큐 보는 것을 좋아하는 나는 우연히 &lt;a href=&quot;http://program.tving.com/tvn/2020tvnshift&quot;&gt;tvN의 Shift 6화 - 질문으로 자라는 아이&lt;/a&gt;에서 인터뷰이로 참여한 종민님을 처음 알게 되었다.  &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/BAODHvuHzk8&quot; title=&quot;tvN Shift E06 질문으로 자라는 아이&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;  
&lt;br/&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/LxFQUk4n8ss&quot; title=&quot;EBS 특별기획 - 미래 교육을 묻다&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;  
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;  &lt;/p&gt;
&lt;p&gt;위 유튜브 채널에서 볼 수 있듯 종민님은 &lt;a href=&quot;https://www.youtube.com/c/cmiscm/featured&quot;&gt;유튜브&lt;/a&gt;도 함께 운영하고 있다. 채널을 알게 된 뒤에 업로드된 영상을 처음부터 끝까지 모두 살펴보며 알 수 없는 두근거림과 간지러움이 피어올랐다.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;그래, 이거다!  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;종민님을 알게 된 시기에 나는 &lt;strong&gt;번아웃&lt;/strong&gt;을 겪고 있었고, 커리어에 대한 고민이 많았다. 종민님의 영상, 작업물 등을 통해 간접적으로 도움을 받아 이 고민을 끝내고 결정을 내릴 수 있게 되었다.&lt;br&gt;
그날부터 설레여 잠을 잘 수가 없었던 그 밤들이 아직도 생생하다.  &lt;/p&gt;
&lt;br/&gt;  
&lt;p&gt;여하튼 디지털 작업 외에도 오프라인 작업물들도 만드는데 그중 &lt;a href=&quot;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=63770885&amp;#x26;start=slayer&quot;&gt;인터랙티브 디벨로퍼&lt;/a&gt;라는 책도 있었다. 아쉽게 책은 절판이 되어 구할 수 없었다. 책을 다시 찾는 이가 많아지면서 몇 의 가격으로 중고 거래되는 것을 본 종민님은 5년배 만에 책 내용을 보강하여 이번에 다시 출간했다.  &lt;/p&gt;
&lt;p&gt;그 책이 바로 &lt;a href=&quot;https://coupa.ng/bVbAJ3&quot;&gt;&amp;#x3C;일은 배신하지 않는다&gt;&lt;/a&gt;. 종민님은 일을 굉장히 중요하게 생각하는 사람 중의 한 명이라고 자신을 소개하는 것으로 책을 시작한다.     &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://coupa.ng/bVbAJ3&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;책 - 일은 배신하지 않는다&quot; src=&quot;https://image.aladin.co.kr/product/26683/79/cover500/k412730981_1.jpg&quot;&gt;&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;일은 단순히 돈을 벌고 먹고 살기 위해서 하는 것이 아니라,&lt;br&gt;
정말 본인의 자아발전을 위해서,&lt;br&gt;
또 내가 어떤 사람으로 살아가는가를 정의하는,&lt;br&gt;
삶에 있어서 중요한 부분이라고 생각한다.  &lt;/p&gt;
&lt;p&gt;항상 뭔가를 만드는 사람이 되고 싶었고,&lt;br&gt;
나이가 들어서도 계속해서 나만의 일을 하는 그런 모습을 꿈꿨다.&lt;br&gt;
이런 나의 일을 대하는 진지한 자세를 딸에게 혹은 독자에게 들려주고 싶었다.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2021/2021_039_001.jpg&quot;&gt;  &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;  &lt;/p&gt;
&lt;p&gt;이 페이지가 &lt;a href=&quot;https://coupa.ng/bVbAJ3&quot;&gt;&amp;#x3C;일은 배신하지 않는다&gt;&lt;/a&gt;의 내용을 한 장으로 정리한 부분이라고 볼 수 있다.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;돈을 많이 번다고 해서 나보다 적게 버는 사람보다 그 차액만큼 더 가치가 있는 사람일까.  &lt;/li&gt;
&lt;li&gt;나와 대화하는 방법 찾아 내가 좋아하는 것과 하고 싶은 것을 통해 어떤 작업을 만드는 사람이 되고 싶은가에 대한 끊임없이 고민하고 실행해야 함을 강조한다.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 강조한 부분을 처음 종민님의 작업 설명을 들을 때 느낄 수 있었다. 작업 요소 하나하나 그냥 작업한 것은 단 하나도 없었다. &lt;code&gt;모든 요소에 고민이 있고, 모든 요소에 이유가 있었다.&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;이제 아래 내용부터는 &lt;a href=&quot;https://coupa.ng/bVbAJ3&quot;&gt;&amp;#x3C;일은 배신하지 않는다&gt;&lt;/a&gt; 책에서 인상 깊은 부분들을 일부 소개한다.  &lt;/p&gt;
&lt;h2&gt;나의 작업 철학&lt;/h2&gt;
&lt;p&gt;고등학교 졸업 당시 나의 희망 직업은 영화의 미니어처 등에 쓰이는 모형을 만드는 장인이었다. 그때 내 재능에 대해 스스로 진지하게 반문을 해본 적이 있다. 모형을 만드는 장인이 되려면 처음부터 모형을 직접 빚어 내고 완성을 해야 한다고 생각했는데 나는 그러지 못했다. 내 실력은 &lt;code&gt;이미 만들어진 모형을 사서 조립하고 색칠하는 수준&lt;/code&gt;밖에 되지 않는다는 것을 깨달았다. 즉, 취미로는 훌륭할지 몰라도 직업이라고 말하기에는 부족했다.  &lt;/p&gt;
&lt;p&gt;내가 &lt;code&gt;그 분야의 진짜가 되기 위해선 본질이 되는 작업이 가능&lt;/code&gt;해야 한다고 생각했다. 개발의 본질은 개발 코드를 사용해 구조를 설계하고 움직임을 만드는 일이다. 코드에 대한 이해가 없이 툴(Tool)이나 라이브러리만을 사용해 결과물을 만드는 것은 시중에서 모형을 사다가 조립하고 색칠만 하는 취미 정도의 수준과 다르지 않다는 생각이었다.  &lt;/p&gt;
&lt;p&gt;모두가 편리한 방법을 찾을 때 나는 어렵고 시간이 걸려도 개발 코드만을 이용해서 움직임을 만들려고 노력했었다. 플래시라는 프로그램의 특정 기능에 의지하지 말고 개발의 본질인 &lt;strong&gt;코드&lt;/strong&gt;를 이해해야 한다고 생각해서였다. 사수나 멘토가 없었던 것이 이런 부분에선 장점이 됐다고 생각한다. 누가 가르쳐준 대로만 따라 하지 않고 스스로 생각하고 결정한 방향으로 공부할 수 있었기 때문이다.  &lt;/p&gt;
&lt;p&gt;그러므로 코드에 대한 이해 없이 라이브러리에만 의존하는 것은 피해야 한다. 하지 않는 것과 할 수 없는 것엔 큰 차이가 있다. 라이브러리를 사용하는 것이 문제가 되진 않는다. &lt;strong&gt;문제는 라이브러리를 사용해 만들어진 결과물이 자신의 실력이라고 생각&lt;/strong&gt;하는 경우다.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Collector란?&lt;br&gt;
실력을 쌓는 데 시간을 쓰기 보단 라이브러리를 수집하는 데 더 많은 시간을 보내는 사람들  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;본질에 대한 나의 작업 철학은 구글에서도 빛을 발했다. 처음 구에서 했던 작업은 더 나은 구글 웹사이트를 위해 프로토타입을 만드는 일이었다. 보통은 프로토타입 작업을 위해 편리한 프로토타이핑 툴이나 라이브러리를 사용한다. 하지만 나는 어떤 툴이나 라이브러리를 사용하지 않고 네이티브 언어인 Javascript 코드만으로 프로토타입을 만들었다. 이미 누군가 만들어둔 코드를 사용하는 것이 아니라 각각의 디자인에 최적화된 코드를 만들어서 성능을 높였다. 결과적으로 이런 나의 작업 철학이 모바일에서 부드러운 움직임을 위한 해결책을 생각해내는 원천이 되었다.  &lt;/p&gt;
&lt;p&gt;툴이나 라이브러리는 분명 편리한 점이 많지만, 실질적인 코드에 대한 이해가 부족하고, 툴에서 제공하는 한정된 기능만을 사용할 수 있다는 단점이 있다. 어려워도 툴의 도움 없이 개발의 본질인 코드를 이해하고 사용한다면 더 넓은 시야를 가질 수 있다.  &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;  &lt;/p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/cpEeqACsF_Q&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;  
&lt;p&gt;&lt;br/&gt;&lt;br/&gt;  &lt;/p&gt;
&lt;h2&gt;개인 작업의 중요성&lt;/h2&gt;
&lt;p&gt;세미나나 이메일로 가장 많이 받는 질문 중의 하나는 &apos;종민님처럼 되려면 어떻게 해야 하나요?&apos;다. 내가 만드는 작업물들처럼 재미있는 것을 만드는 사람이 되고, 그러려면 어떤 방향으로 공부/취직을 해야 하는지 묻는 질문이다. 남들이 봐도 재미있을 것 같은 화려한 비주얼의 작업들&apos;만&apos; 만들면서 회사에서 인정도 받고 돈도 많이 벌면 좋겠지만, 사실 그런 회사는 존재하지 않는다.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;나는 이런 재미있는 일을 하고 싶은데 회사에선 재미없는 일만 시킨다  &lt;/li&gt;
&lt;li&gt;만약 내가 디자이너인데 개발을 할 줄 안다고 하면 내 업무 이외에도 잡다한 일을 나에게 시켜서 힘들다  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;라는 질문들도 많이 받는다. 그래서 나는 개인 작업이 중요하다고 말하고 싶다.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;아무리 말로 내가 뭘 잘한다, 뭘 하고 싶다고 말해봐도 그게 먹힐 확률은 굉장히 낮다.&lt;/strong&gt; 하지만 작업으로 보여준다면 얘기가 다르다. 이는 내가 개인 작업을 하면서 느낀 부분인데, 내가 만드는 개인 작업물들이 쌓이고 점점 세상에 알려지면서, 회사 내의 사람들까지 나를 그런 작업을 잘하는 사람으로 인식하고 있었다. 자연스럽게 회사에 그런 류의 일이 생겼을 때 나를 중심으로 팀이 꾸려지게 된다. 즉, 회사에서 내가 하고 싶은 부분을 맡겨줄 떄까지 기다릴 것이 아니라, &lt;code&gt;스스로 잘할 수 있는 분야를 개인 작업으로 만들어 세상에 공개하는 것&lt;/code&gt;이다.  &lt;/p&gt;
&lt;p&gt;회사에서 나에게 정해준 타이틀은 중요하지 않다. 커리어에 대한 고민도 비슷한데, 나는 조심스럽게 내 직업은 내가 만들어가는 것이라고 말해주고 싶다. 눈 앞의 정해진 특정 롤에 맞춰 취업하는 것이 목표가 되기보단 내가 어떤 작업에 더 흥미를 느끼는지를 고민해 볼 필요가 있다.  &lt;/p&gt;
&lt;br/&gt;  
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2021/2021_039_003.jpg&quot;&gt;  &lt;/p&gt;
&lt;h2&gt;사수가 없어도 나를 성장 시킬 수 있는 방법&lt;/h2&gt;
&lt;p&gt;지금도 새로운 것을 배울 때 즐겨 쓰는 방법인데 &lt;code&gt;책을 한 권만 읽는 것이 아니라 여러 권의 다른 작가가 쓴 책을 읽어보는 것이다.&lt;/code&gt; 어떤 책이든지 중요한 부분은 자주 나오기 때문에 중요한 내용일수록 중복되어 읽히므로 기억에 더 잘 남고 이해가 안 가는 부분은 여러 작가의 다양한 설명으로 있으니 이해하기 쉽다.  &lt;/p&gt;
&lt;p&gt;그동안 프로젝트를 진행하며 실무에서 느꼈던 부분과 여러 권의 책을 읽으며 이해했던 부분이 더해지면서 실력이 월등하게 늘었다. 이 방법은 이렇다 할 사수나 멘토가 없었던 나를 스스로 성장시키는 데 큰 도움이 되었다. 프래시라는 한 가지 언어가 이해되자 프로그래밍의 규칙이 눈에 보였고 그 후엔 Javascript, Object-C, Java for Android 등 여러 가지 언어를 배울 때 힘들지 않고 빠르게 배울 수 있었다.  &lt;/p&gt;
&lt;h2&gt;시대가 바뀌어도 살아남는 방법&lt;/h2&gt;
&lt;p&gt;1970년대 미싱사로 일하시던 엄마 생각이 났다. 엄마의 재봉 기술은 시대가 바뀌고 공장의 자동화와 중국의 값싼 생산력 등에 밀려 한국에선 이제 수요가 그다지 없는 기술이 되었다. 그것을 나에게 적용해보니 나 역시 &apos;지금은 풀래시라는 기술로 그럭저럭 먹고살고 있지만, &lt;code&gt;시대가 바뀌어서 이 기술이 필요없어지면 어떡하지?&lt;/code&gt;&apos;라는 생각이 들었다. 그때 두 가지 해결책을 생각해서 실천에 옮겼는데 이는 사실 이 책에서 가장 말하고 싶은 부분이기도 하다.  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2021/2021_039_004.jpg&quot;&gt;  &lt;/p&gt;
&lt;h3&gt;플래시라는 특정 기술이 아닌 나만의 내공을 가지기 위해 노력&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;초점을 개발 언어에서 콘텐츠로 옮김  &lt;/li&gt;
&lt;li&gt;웹사이트의 디자인과 모션의 디테일 수준을 높이기 위해 고민  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;시장에서 요구하는 기술은 항상 빠르게 변하기 때문에 한 가지 기술에만 의조하는 사람이 되는 것은 위험한 발상이라는 생각이 있었다. 시대가 바뀌어도 변하지 않는 나만의 내공을 가져야겠다고 생각했다.  &lt;/p&gt;
&lt;h3&gt;크게 보고 눈앞의 작은 것에 연연하지 말자&lt;/h3&gt;
&lt;p&gt;당장 눈 앞의 연봉, 직급 등에 연연해서 스트레스를 받거나 승진을 위해 윗사람에게 아부하는 데 시간을 쓰지 말고, &lt;code&gt;내가 되고자 하는 사람&lt;/code&gt;이 될 수 있도록 실력을 쌓고 싶었다. 좁은 시야로 눈 앞의 작은 것을 가지기 위해 에너지를 낭비하지 말고 오직 내가 좋아하는 일에 모든 에너지를 쏟고 싶었다. 일에만 집중하자는 생각은 지금도 변함이 없는데, &apos;현재의 연봉, 직급 등에 연연해서 회사를 쉽게 옮기거나 하지 말자&apos;는 생각을 하게 해주었다.  &lt;/p&gt;
&lt;p&gt;회사에서 어떤 일을 하느냐, 혹은 내가 얼마나 성장하느냐가 중요하지 연봉 몇백만 원을 더 받으려고 회사를 옮기는 것이나, 남에게 보이기 위한 내 직급이 무엇인가는 중요하지 않다는 생각이었다. 회사를 옮기게 되면 또다시 새로운 곳에서 적응하고 &lt;strong&gt;신뢰&lt;/strong&gt;를 쌓기 위한 시간과 에너지가 낭비된다고 생각했다.  &lt;/p&gt;
&lt;h2&gt;감을 늘리는 방법&lt;/h2&gt;
&lt;p&gt;모션을 디자인할 땐 해당 디자인에 맞는 모션을 찾기 위해 많은 테스트를 해보는 것이 가장 좋은 방법이다. 그래서 모션감이 중요한데 많은 작업을 통해 쌓인 모션감은 어떤 것이 아름다운지를 구별할 수 있는 눈을 갖게 한다. 모션감을 늘리는 방법은 많이 많들어 보는 것 외엔 없다. &lt;strong&gt;눈으로 볼 땐 쉬워 보여도&lt;/strong&gt; 직접 따라 만들어보면 쉽지 않음을 알게 된다. 시간과 가속/감속의 미묘한 차이가 다른 느낌의 모션을 만들어내기 때문이다. &lt;/p&gt;
&lt;br/&gt;  
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2021/2021_039_005.jpg&quot;&gt;  &lt;/p&gt;
&lt;h2&gt;외국 회사에서 느끼는 차이점과 조심해야 할 것들&lt;/h2&gt;
&lt;h3&gt;겸손은 이제 그만&lt;/h3&gt;
&lt;p&gt;퍼스트본에서 일할 때 옆자리의 동료가 모두가 아니오라고 할 때 혼자 &apos;예&apos;라고 한 경우가 있었는데 이게 나에겐 참 생소한 모습이었다. 생각해보면 그동안 나는 &lt;code&gt;내 의견을 말하기보단 상대방의 의사를 살펴 의견을 말하고 동조를 얻어야&lt;/code&gt;만 올바른 의견을 말한 것 같은 생각이 들었기 때문이다. 자유로운 의견제시는 자신감 있는 당당한 모습을 말하고 이는 지나친 겸손과 반대된다.  &lt;/p&gt;
&lt;p&gt;겸손이 몸에 벤 한국 사람들, 나 역시 &apos;너 정말 잘하는구나!&apos;라는 말을 들을 때면, 겉으론 &apos;야휴 제가 뭐 한거 있나요, 다 된 밥사에 숟가락 얹은 것뿐이죠&apos;라고 대답하곤 했다. 이런 습성때문에 처음 퍼스트본에 와서 &apos;나는 별로 잘하는 것도 없는데 그냥 열심히 한다고 해서 뽑혔다.&apos;라고 했던 적이 있다. 이후 어떤 직원이 나를 표현할 때 내 말을 그대로 인용해 말하는 것을 알게 되었다. 겸손은 분명 세계 어느 나라에서나 통하는 미덕이지만, 지나친 겸손은 미국에선 자신감 부족으로 비칠 수 있다.  &lt;/p&gt;
&lt;p&gt;누군가 당신에 대해 칭찬을 해준다면 겸손보단 칭찬에 대해 &lt;strong&gt;고맙다고 대답&lt;/strong&gt;하는 것이 좋다고 생각한다.  &lt;/p&gt;
&lt;h3&gt;의견은 자유롭게&lt;/h3&gt;
&lt;p&gt;미국은 모두들 자기 의견을 내세우는 데 거리낌이 없다. 예를 들어 내가 낸 의견에 격렬하게 반대하다가도 회의가 끝나면 뒤끝 없이 웃으면서 이야기하는 것이 이들의 일상이다. 막 입사한 인턴이 전체 회의에서 자신의 의견을 당당하게 이야기하는 모습을 볼대면, 한국에서 시키는 대로 묵묵히 일했던 내 모습과 비교되어 많은 생각을 하게 한다. 특히 미국에선 회의를 할 때 의견을 내지 않으면 &apos;내 의견에 동조하는 내 편&apos;이 아니라 &lt;code&gt;자신의 생각을 말하지 못하는 &apos;생각이 없는 사람&apos;&lt;/code&gt;으로 보일 수 있으니 조심해야 한다.  &lt;/p&gt;
&lt;h2&gt;위기는 기회&lt;/h2&gt;
&lt;p&gt;시장은 플래시라는 기술보단 HTML5라는 신기술을 선호하기 시작했다. All Flash 사이트를 만드는 것은 웹 표준에 맞지도 않고 스마트폰과 태블릿 PC의 등장으로 플래시 플레이어가 설치되지 않는 디바이스들이 늘어나자 웹어서 플래시는 급격히 내리막길을 걷게 되었다. 이때 많은 플래시 디벨로퍼들에게 위기 상황이었다. HTML5 프로젝트가 하나둘씩 늘어나며 변화에 적응한 사람, 그렇지 못한 사람도 생겨나기 시작했다.&lt;br&gt;
그때 동료의 HTML5 개인 작업물을 보고 HTML5의 가능성을 실감했다. 실력 있는 동료를 보고 자극받아 내 실력을 더 쌓을 수 있는 기회가 많은 것이 &lt;strong&gt;해외 취업의 장점&lt;/strong&gt; 중 하나라고 생각한다.  &lt;/p&gt;
&lt;br/&gt;  
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2021/2021_039_002.jpg&quot;&gt;  &lt;/p&gt;
&lt;p&gt;그럼 다음 글에 이어서 책을 마저 소개하겠다.   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://baek.dev/post/39/&quot;&gt;일은 배신하지 않는다(1) - 포트폴리오 하나로 구글 입사 제의를 받은&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://baek.dev/post/40/&quot;&gt;일은 배신하지 않는다(2) - 구글에 가면 행복할까요?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;References&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://coupa.ng/bVbAJ3&quot;&gt;&amp;#x3C;일은 배신하지 않는다&gt;, 2021 아이스크림미디어&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[CSS 사이즈 단위 - 절대 길이와 상대 길이]]></title><description><![CDATA[<p>CSS에서는 길이를 표현하기 위한 단위들이 있다. 이 단위들은 두가지 유형으로 분류 할 수 있는데 항상 동일한 크기를 가지는 <strong>절대 길이 단위</strong>와 <strong>상대 길이 단위</strong>이다.<br>
먼저 상대 길이 단위부터 살펴보자.  </p>
<h2>상대 길이 단위 / Relative length units</h2>
<p>상대 길이 단위는 다른 요소나 부모 또는 창 크기에 비례여 크기가 조정되기 때문에 <code>반응형 사이트의 스타일을 지정</code>하는데 유용하다.
종류로는 em, ex, ch, rem, vw, vh, vmin, vmax 등이 있으며 상대 길이에서도 글꼴과 viewport에 따라 유형을 분류할 수 있다.  </p>
<h3>글꼴 상대 길이 단위</h3>
<table>
<thead>
<tr>
<th>Units</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>em</td>
<td><ul><li>현재 글꼴 크기에 상대적</li><li>원래는 현재 서체 대문자 "M"을 기반으로한 활자체 측정</li><li>font-family를 바꾼다고 해서 영향 받지 않으며</li><li>font-size 변경시 같이 변경됨</li><li>css가 전혀 없다면,<br/>1em == 16px == 0.17in == 12pt == 1pc == 4.2mm == 0.42cm</li></ul></td>
</tr>
<tr>
<td>rem</td>
<td><ul><li>root em</li><li>루트 요소의 글꼴 크기</li><li>em과 같은 상대 길이 단위이지만</li><li>계단식을 사용하지 않고 항상 root 요소(예로, html)에 상대적인 em임</li><li>이 개념은 상대 길이 단위 작업을 크게 단순화함</li><li>font-size 뿐만 아니라 grid system에도 사용 가능</li></ul></td>
</tr>
<tr>
<td>pt</td>
<td><ul><li>points</li><li>1pt == 1/72in에 대한 물리적 측정</li><li>css외부에서 유형의 크기를 조정하는 가장 일반적인 방법</li></ul></td>
</tr>
<tr>
<td>pc</td>
<td><ul><li>pica</li><li>pt와 같은 같은 기능을 하며</li><li>1pc == 12pt</li></ul></td>
</tr>
<tr>
<td>ex</td>
<td><ul><li>현재 글꼴 x문자의 height를 기반으로 한 측정</li></ul></td>
</tr>
<tr>
<td>ch</td>
<td><ul><li>x-height와 유사</li><li>ch만 x 문자의 높이 대신 숫자 "0" 문자의 너비를 기준으로 함</li><li>글꼴 모음이 변경됨에 따라 변경됨</li></ul></td>
</tr>
</tbody>
</table>
<h4>em &#x26; rem</h4>
<p>아래와 같이 em 을 사용하여 css를 정의한다고 가정해보자.  </p>
<pre><code class="language-css">body {
  font-size: 14px;
}
div {
  font-size: 1.4em; // 1.2배의 폰트 사이즈로 표현 -> 14px * 1.4em = 19.6px 
}
</code></pre>
<p>그럼 아래 html이 계층 구조를 가지도록 준비할 경우 각 모든 요소의 font-size는 19.6px을 기대할 수 있을까?  </p>
<pre><code class="language-html">&#x3C;body>
  &#x3C;span>Hello, rem!&#x3C;/span>
  &#x3C;div class="container">
    &#x3C;div class="head">Head&#x3C;/div>
    &#x3C;div class="contents">
      &#x3C;span>Contents&#x3C;/span>
      &#x3C;div class="main">Main&#x3C;/div>
      &#x3C;div class="aside">Aside&#x3C;/div>
    &#x3C;/div>  
  &#x3C;/div>
&#x3C;/body>
</code></pre>
<p>실제로는 각각의 div는 각 부모의 font-size를 <code>상속</code>받아 점점 커지게 된다. 그래서 em은 때때로 값을 계산하기 매우 <strong>번거롭다</strong>.  </p>
<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="html,result" data-user="baek-dev" data-slug-hash="eYBqQmv" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="eYBqQmv">
  <span>See the Pen <a href="https://codepen.io/baek-dev/pen/eYBqQmv">
  eYBqQmv</a> by BAEKDEV (<a href="https://codepen.io/baek-dev">@baek-dev</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>  
<p>이제 위 표에서 상대 길이 단위 작업을 크게 단순화한다고 한 rem의 예제를 살펴보자.
<strong>rem은 root를 기준으로 계산</strong>하니 상속 여부와 상관없이 14px을 기준으로 1.4배를 적용하게 된다.</p>
<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="html,result" data-user="baek-dev" data-slug-hash="YzpmJMj" data-preview="true" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Sample - CSS rem">
  <span>See the Pen <a href="https://codepen.io/baek-dev/pen/YzpmJMj">
  Sample - CSS rem</a> by BAEKDEV (<a href="https://codepen.io/baek-dev">@baek-dev</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>  
<p>앞서 글꼴 상대 길이 단위를 살펴보았고 이제는 viewport에 대응하는 상대 길이를 살펴보자.  </p>
<h3>Viewport 상대 길이 단위</h3>
<p>단위를 살펴보기 전에 필수 개념인 viewport를 먼저 확인해보자.  </p>
<p><strong>viewport란?</strong>  </p>
<blockquote>
<p>현재 화면에 보여지고 있는 다각형(보통 직사각형)의 영역을 뜻하며,<br>
웹 브라우에서는 현재 창에서 문서를 볼 수 있는 부분을 말한다.  </p>
</blockquote>
<p>뷰포트의 바깥의 콘텐츠를 스크롤하기 전엔 보이지 않고, 뷰포트 중에서도 지금 볼 수 있는 부분을 Visual Viewport라고 부른다. 특히 스마트폰에서 사용자가 화면을 <strong>확대(Scale)</strong>했을 때와 같은 특정 상황에서 Layout Viewport의 크기는 변하지 않지만 Visual View는 더 작아진다.  </p>
<p><img src="https://baek.dev/assets/images/post/2021/2021_038_001.png" alt="viewport 예시">  </p>
<p><code>보통 viewport는 device-width와 initial-scale=1.0</code>로 많이 설정하며 관련한 내용은 다른 글에 이어서 다뤄볼 예정이다. 요즘에는 Mobile first가 많다보니 viewport가 디바이스 화면 크기라고 이해하면 쉬울 것 같다.   </p>
<table>
<thead>
<tr>
<th>Units</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>vw</td>
<td><ul><li>viewport 너비의 1%</li><li>백분율과 비슷하지만</li><li>부모 요소 또는 부모 요소 너비에 관계없이 모든 요소에 대해 값이 일관적으로 유지됨</li><li>rem이 항상 루트에 상대적인 방식과 비슷</li></ul></td>
</tr>
<tr>
<td>vh</td>
<td><ul><li>viewport 높이의 1%</li><li>vw 단위와 동일하나 뷰포트 높이를 기반으로 함</li></ul></td>
</tr>
<tr>
<td>vmin</td>
<td><ul><li>viewport 의 작은 치수의 1%</li><li>vw 또는 vh 중 더 작은 값</li></ul></td>
</tr>
<tr>
<td>vmax</td>
<td><ul><li>viewport 의 큰 치수의 1%</li><li>vw 또는 vh 중 더 큰 값</li></ul></td>
</tr>
</tbody>
</table>
 <p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="css,result" data-user="baek-dev" data-slug-hash="bGBXzqO" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Sample - CSS viewport units">
   <span>See the Pen <a href="https://codepen.io/baek-dev/pen/bGBXzqO">
   Sample - CSS viewport units</a> by BAEKDEV (<a href="https://codepen.io/baek-dev">@baek-dev</a>)
   on <a href="https://codepen.io">CodePen</a>.</span>
 </p>
<h2>절대 길이 단위 / Absolute length units</h2>
<p>절대 길이 단위는 상위 요소 또는 창 크기에 관계없이 <code>동일한 크기</code>를 의미한다. 절대 길이 단위는 반응형을 고려하지 않는 작업에 유용하며 주로 <strong>인쇄물</strong>에서 많이 사용되는 방법이다. 또한 상속 된 다른 CSS로부터 영향을 받지 않는다. 그래서 포지셔닝과 간격에 보편적으로 사용된다. 반응형이 아닌 경우는 크기를 조정할 수 없는 키오스크 혹은 데스크톱이어도 반응형일 필요가 없는 앱이 그 대상일 수 있다.  </p>
<table>
<thead>
<tr>
<th>Units</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>px</td>
<td><ul><li>화면을 구성하는 가장 기본이 되는 단위로, 모니터의 1dot = 1pixel을 의미</li><li>때문에 pixel은 해상도에 따라 상대적인 크기를 갖음</li><li>상속 된 다른 CSS로부터 영향을 받지 않음</li></ul></td>
</tr>
<tr>
<td>in</td>
<td><ul><li>inch</li><li>인치는 물리적 측정이지만, CSS에서는 pixel에 직접 매칭됨</li><li>1in == 96px</li></ul></td>
</tr>
<tr>
<td>cm</td>
<td><ul><li>대부분의 세계에서 센티미터는 물리적 측정으로 더 친숙하고 유용함</li><li>역시 css에 매핑됨</li><li>1cm == 37.8px</li></ul></td>
</tr>
<tr>
<td>mm</td>
<td><ul><li>1mm == 0.1cm == 3.78px</li></ul></td>
</tr>
</tbody>
</table>
<p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="css,result" data-user="SitePoint" data-slug-hash="ZGmGVR" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Demo using different absolute units in CSS">
  <span>See the Pen <a href="https://codepen.io/SitePoint/pen/ZGmGVR">
  Demo using different absolute units in CSS</a> by SitePoint (<a href="https://codepen.io/SitePoint">@SitePoint</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.iohttps://baek.dev/assets/embed/ei.js"></script>   
<p>출처 : <a href="https://www.sitepoint.com/look-at-length-units-in-css/">A Look at Length Units in CSS</a></p>
<h2>마치며</h2>
<p>px과 em을 계산할 때 <a href="http://pxtoem.com/">pixel to em</a>를 이용하면 많은 도움이 될 수도 있다. 더불어 특정 단위를 사용할 때는 브라우저 지원이 가능한지 반드시 확인을 해야한다. <a href="https://caniuse.com/viewport-units">Can I Use - Viewport units</a>를 통해 꼭 확인하자.  </p>
<h5>References</h5>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units">CSS values and units</a>  </li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API">Visual Viewport API</a>  </li>
<li><a href="https://www.quirksmode.org/mobile/viewports2.html">Viewport</a>  </li>
<li><a href="https://webdesign.tutsplus.com/articles/7-css-units-you-might-not-know-about--cms-22573?ec_unit=translation-info-language">7 CSS Units You Might Not Know About</a>    </li>
</ul>
<div class="footnotes">
<hr>
<ol>
<li id="fn-1">
<p>상위 요소의 글꼴 크기 또는 viewport  </p>
<a href="#fnref-1" class="footnote-backref">↩</a>
</li>
</ol>
</div>]]></description><link>https://baek.dev/post/38/</link><guid isPermaLink="false">https://baek.dev/post/38/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 21 Mar 2021 12:22:00 GMT</pubDate><content:encoded>&lt;p&gt;CSS에서는 길이를 표현하기 위한 단위들이 있다. 이 단위들은 두가지 유형으로 분류 할 수 있는데 항상 동일한 크기를 가지는 &lt;strong&gt;절대 길이 단위&lt;/strong&gt;와 &lt;strong&gt;상대 길이 단위&lt;/strong&gt;이다.&lt;br&gt;
먼저 상대 길이 단위부터 살펴보자.  &lt;/p&gt;
&lt;h2&gt;상대 길이 단위 / Relative length units&lt;/h2&gt;
&lt;p&gt;상대 길이 단위는 다른 요소나 부모 또는 창 크기에 비례여 크기가 조정되기 때문에 &lt;code&gt;반응형 사이트의 스타일을 지정&lt;/code&gt;하는데 유용하다.
종류로는 em, ex, ch, rem, vw, vh, vmin, vmax 등이 있으며 상대 길이에서도 글꼴과 viewport에 따라 유형을 분류할 수 있다.  &lt;/p&gt;
&lt;h3&gt;글꼴 상대 길이 단위&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Units&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;em&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;현재 글꼴 크기에 상대적&lt;/li&gt;&lt;li&gt;원래는 현재 서체 대문자 &quot;M&quot;을 기반으로한 활자체 측정&lt;/li&gt;&lt;li&gt;font-family를 바꾼다고 해서 영향 받지 않으며&lt;/li&gt;&lt;li&gt;font-size 변경시 같이 변경됨&lt;/li&gt;&lt;li&gt;css가 전혀 없다면,&lt;br/&gt;1em == 16px == 0.17in == 12pt == 1pc == 4.2mm == 0.42cm&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rem&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;root em&lt;/li&gt;&lt;li&gt;루트 요소의 글꼴 크기&lt;/li&gt;&lt;li&gt;em과 같은 상대 길이 단위이지만&lt;/li&gt;&lt;li&gt;계단식을 사용하지 않고 항상 root 요소(예로, html)에 상대적인 em임&lt;/li&gt;&lt;li&gt;이 개념은 상대 길이 단위 작업을 크게 단순화함&lt;/li&gt;&lt;li&gt;font-size 뿐만 아니라 grid system에도 사용 가능&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pt&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;points&lt;/li&gt;&lt;li&gt;1pt == 1/72in에 대한 물리적 측정&lt;/li&gt;&lt;li&gt;css외부에서 유형의 크기를 조정하는 가장 일반적인 방법&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pc&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;pica&lt;/li&gt;&lt;li&gt;pt와 같은 같은 기능을 하며&lt;/li&gt;&lt;li&gt;1pc == 12pt&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ex&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;현재 글꼴 x문자의 height를 기반으로 한 측정&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ch&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;x-height와 유사&lt;/li&gt;&lt;li&gt;ch만 x 문자의 높이 대신 숫자 &quot;0&quot; 문자의 너비를 기준으로 함&lt;/li&gt;&lt;li&gt;글꼴 모음이 변경됨에 따라 변경됨&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;em &amp;#x26; rem&lt;/h4&gt;
&lt;p&gt;아래와 같이 em 을 사용하여 css를 정의한다고 가정해보자.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;body {
  font-size: 14px;
}
div {
  font-size: 1.4em; // 1.2배의 폰트 사이즈로 표현 -&gt; 14px * 1.4em = 19.6px 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그럼 아래 html이 계층 구조를 가지도록 준비할 경우 각 모든 요소의 font-size는 19.6px을 기대할 수 있을까?  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;#x3C;body&gt;
  &amp;#x3C;span&gt;Hello, rem!&amp;#x3C;/span&gt;
  &amp;#x3C;div class=&quot;container&quot;&gt;
    &amp;#x3C;div class=&quot;head&quot;&gt;Head&amp;#x3C;/div&gt;
    &amp;#x3C;div class=&quot;contents&quot;&gt;
      &amp;#x3C;span&gt;Contents&amp;#x3C;/span&gt;
      &amp;#x3C;div class=&quot;main&quot;&gt;Main&amp;#x3C;/div&gt;
      &amp;#x3C;div class=&quot;aside&quot;&gt;Aside&amp;#x3C;/div&gt;
    &amp;#x3C;/div&gt;  
  &amp;#x3C;/div&gt;
&amp;#x3C;/body&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;실제로는 각각의 div는 각 부모의 font-size를 &lt;code&gt;상속&lt;/code&gt;받아 점점 커지게 된다. 그래서 em은 때때로 값을 계산하기 매우 &lt;strong&gt;번거롭다&lt;/strong&gt;.  &lt;/p&gt;
&lt;p class=&quot;codepen&quot; data-height=&quot;265&quot; data-theme-id=&quot;dark&quot; data-default-tab=&quot;html,result&quot; data-user=&quot;baek-dev&quot; data-slug-hash=&quot;eYBqQmv&quot; style=&quot;height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;&quot; data-pen-title=&quot;eYBqQmv&quot;&gt;
  &lt;span&gt;See the Pen &lt;a href=&quot;https://codepen.io/baek-dev/pen/eYBqQmv&quot;&gt;
  eYBqQmv&lt;/a&gt; by BAEKDEV (&lt;a href=&quot;https://codepen.io/baek-dev&quot;&gt;@baek-dev&lt;/a&gt;)
  on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/span&gt;
&lt;/p&gt;  
&lt;p&gt;이제 위 표에서 상대 길이 단위 작업을 크게 단순화한다고 한 rem의 예제를 살펴보자.
&lt;strong&gt;rem은 root를 기준으로 계산&lt;/strong&gt;하니 상속 여부와 상관없이 14px을 기준으로 1.4배를 적용하게 된다.&lt;/p&gt;
&lt;p class=&quot;codepen&quot; data-height=&quot;265&quot; data-theme-id=&quot;dark&quot; data-default-tab=&quot;html,result&quot; data-user=&quot;baek-dev&quot; data-slug-hash=&quot;YzpmJMj&quot; data-preview=&quot;true&quot; style=&quot;height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;&quot; data-pen-title=&quot;Sample - CSS rem&quot;&gt;
  &lt;span&gt;See the Pen &lt;a href=&quot;https://codepen.io/baek-dev/pen/YzpmJMj&quot;&gt;
  Sample - CSS rem&lt;/a&gt; by BAEKDEV (&lt;a href=&quot;https://codepen.io/baek-dev&quot;&gt;@baek-dev&lt;/a&gt;)
  on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/span&gt;
&lt;/p&gt;  
&lt;p&gt;앞서 글꼴 상대 길이 단위를 살펴보았고 이제는 viewport에 대응하는 상대 길이를 살펴보자.  &lt;/p&gt;
&lt;h3&gt;Viewport 상대 길이 단위&lt;/h3&gt;
&lt;p&gt;단위를 살펴보기 전에 필수 개념인 viewport를 먼저 확인해보자.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;viewport란?&lt;/strong&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;현재 화면에 보여지고 있는 다각형(보통 직사각형)의 영역을 뜻하며,&lt;br&gt;
웹 브라우에서는 현재 창에서 문서를 볼 수 있는 부분을 말한다.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;뷰포트의 바깥의 콘텐츠를 스크롤하기 전엔 보이지 않고, 뷰포트 중에서도 지금 볼 수 있는 부분을 Visual Viewport라고 부른다. 특히 스마트폰에서 사용자가 화면을 &lt;strong&gt;확대(Scale)&lt;/strong&gt;했을 때와 같은 특정 상황에서 Layout Viewport의 크기는 변하지 않지만 Visual View는 더 작아진다.  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2021/2021_038_001.png&quot; alt=&quot;viewport 예시&quot;&gt;  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;보통 viewport는 device-width와 initial-scale=1.0&lt;/code&gt;로 많이 설정하며 관련한 내용은 다른 글에 이어서 다뤄볼 예정이다. 요즘에는 Mobile first가 많다보니 viewport가 디바이스 화면 크기라고 이해하면 쉬울 것 같다.   &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Units&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;vw&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;viewport 너비의 1%&lt;/li&gt;&lt;li&gt;백분율과 비슷하지만&lt;/li&gt;&lt;li&gt;부모 요소 또는 부모 요소 너비에 관계없이 모든 요소에 대해 값이 일관적으로 유지됨&lt;/li&gt;&lt;li&gt;rem이 항상 루트에 상대적인 방식과 비슷&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vh&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;viewport 높이의 1%&lt;/li&gt;&lt;li&gt;vw 단위와 동일하나 뷰포트 높이를 기반으로 함&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vmin&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;viewport 의 작은 치수의 1%&lt;/li&gt;&lt;li&gt;vw 또는 vh 중 더 작은 값&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vmax&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;viewport 의 큰 치수의 1%&lt;/li&gt;&lt;li&gt;vw 또는 vh 중 더 큰 값&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
 &lt;p class=&quot;codepen&quot; data-height=&quot;265&quot; data-theme-id=&quot;dark&quot; data-default-tab=&quot;css,result&quot; data-user=&quot;baek-dev&quot; data-slug-hash=&quot;bGBXzqO&quot; style=&quot;height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;&quot; data-pen-title=&quot;Sample - CSS viewport units&quot;&gt;
   &lt;span&gt;See the Pen &lt;a href=&quot;https://codepen.io/baek-dev/pen/bGBXzqO&quot;&gt;
   Sample - CSS viewport units&lt;/a&gt; by BAEKDEV (&lt;a href=&quot;https://codepen.io/baek-dev&quot;&gt;@baek-dev&lt;/a&gt;)
   on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/span&gt;
 &lt;/p&gt;
&lt;h2&gt;절대 길이 단위 / Absolute length units&lt;/h2&gt;
&lt;p&gt;절대 길이 단위는 상위 요소 또는 창 크기에 관계없이 &lt;code&gt;동일한 크기&lt;/code&gt;를 의미한다. 절대 길이 단위는 반응형을 고려하지 않는 작업에 유용하며 주로 &lt;strong&gt;인쇄물&lt;/strong&gt;에서 많이 사용되는 방법이다. 또한 상속 된 다른 CSS로부터 영향을 받지 않는다. 그래서 포지셔닝과 간격에 보편적으로 사용된다. 반응형이 아닌 경우는 크기를 조정할 수 없는 키오스크 혹은 데스크톱이어도 반응형일 필요가 없는 앱이 그 대상일 수 있다.  &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Units&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;px&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;화면을 구성하는 가장 기본이 되는 단위로, 모니터의 1dot = 1pixel을 의미&lt;/li&gt;&lt;li&gt;때문에 pixel은 해상도에 따라 상대적인 크기를 갖음&lt;/li&gt;&lt;li&gt;상속 된 다른 CSS로부터 영향을 받지 않음&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;inch&lt;/li&gt;&lt;li&gt;인치는 물리적 측정이지만, CSS에서는 pixel에 직접 매칭됨&lt;/li&gt;&lt;li&gt;1in == 96px&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cm&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;대부분의 세계에서 센티미터는 물리적 측정으로 더 친숙하고 유용함&lt;/li&gt;&lt;li&gt;역시 css에 매핑됨&lt;/li&gt;&lt;li&gt;1cm == 37.8px&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mm&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;1mm == 0.1cm == 3.78px&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p class=&quot;codepen&quot; data-height=&quot;265&quot; data-theme-id=&quot;dark&quot; data-default-tab=&quot;css,result&quot; data-user=&quot;SitePoint&quot; data-slug-hash=&quot;ZGmGVR&quot; style=&quot;height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;&quot; data-pen-title=&quot;Demo using different absolute units in CSS&quot;&gt;
  &lt;span&gt;See the Pen &lt;a href=&quot;https://codepen.io/SitePoint/pen/ZGmGVR&quot;&gt;
  Demo using different absolute units in CSS&lt;/a&gt; by SitePoint (&lt;a href=&quot;https://codepen.io/SitePoint&quot;&gt;@SitePoint&lt;/a&gt;)
  on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/span&gt;
&lt;/p&gt;
&lt;script async src=&quot;https://cpwebassets.codepen.iohttps://baek.dev/assets/embed/ei.js&quot;&gt;&lt;/script&gt;   
&lt;p&gt;출처 : &lt;a href=&quot;https://www.sitepoint.com/look-at-length-units-in-css/&quot;&gt;A Look at Length Units in CSS&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;마치며&lt;/h2&gt;
&lt;p&gt;px과 em을 계산할 때 &lt;a href=&quot;http://pxtoem.com/&quot;&gt;pixel to em&lt;/a&gt;를 이용하면 많은 도움이 될 수도 있다. 더불어 특정 단위를 사용할 때는 브라우저 지원이 가능한지 반드시 확인을 해야한다. &lt;a href=&quot;https://caniuse.com/viewport-units&quot;&gt;Can I Use - Viewport units&lt;/a&gt;를 통해 꼭 확인하자.  &lt;/p&gt;
&lt;h5&gt;References&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units&quot;&gt;CSS values and units&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API&quot;&gt;Visual Viewport API&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.quirksmode.org/mobile/viewports2.html&quot;&gt;Viewport&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://webdesign.tutsplus.com/articles/7-css-units-you-might-not-know-about--cms-22573?ec_unit=translation-info-language&quot;&gt;7 CSS Units You Might Not Know About&lt;/a&gt;    &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;상위 요소의 글꼴 크기 또는 viewport  &lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[자바스크립의 실행 컨텍스트]]></title><description><![CDATA[<h2>실행 컨텍스트(execution context)</h2>
<ul>
<li>실행할 코드에 제공할 환경 정보들을 모아놓은 객체</li>
<li>동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성</li>
<li>이 구성을 call stack에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하여 전체 코드의 환경과 순서를 보장</li>
<li>
<p>구성방법은 전역공간, eval() 함수, 함수 등이 있어 거의 함수를 실행하는 것으로 구성이 가능</p>
<ul>
<li>ES6에서는 블록에 의해서도 새로운 실행 컨텍스트가 생성됨</li>
</ul>
</li>
<li>이 객체는 브라우저 엔진이 활용할 목적으로 생성할 뿐 개발자가 코드를 통해 확인할 수는 없음</li>
</ul>
<p><img src="https://baek.dev/assets/images/post/2021/2021_036_001.png" alt="call stack">  </p>
<p>다음은 실행 컨텍스트의 수집 정보들이다.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>VariableEnvironment</td>
<td>environmentRecord(snapshot) <br/>outerEnvironment(snapshot)</td>
</tr>
<tr>
<td>LexicalEnvironment</td>
<td>environmentRecord <br/>outerEnvironment</td>
</tr>
<tr>
<td>ThisBinding</td>
<td>-</td>
</tr>
</tbody>
</table>
<h2>VariableEnviroment</h2>
<ul>
<li>현재 컨텍스트 내의 식별자들에 대한 정보 및 외부 환경 정보</li>
<li>선언 시점의 LexicalEnvironment의 snapshot으로, 변경 사항은 반영되지 않음</li>
<li>
<p>실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음</p>
<ul>
<li>이를 그대로 복사해서 LexicalEnvironment를 만들고</li>
<li>이후에는 주로 LexicalEnvironment를 주로 활용함</li>
</ul>
</li>
<li>일반 추상 개념 variable environment를 자바스크립트에서 구현한 구체적 대상이 VariableEnvironment</li>
</ul>
<h2>LexicalEnvironment</h2>
<ul>
<li>수시로 변하는 환경 정보</li>
<li>
<p>컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아놓은 것</p>
<ul>
<li>예로 현재 컨텍스트의 내부에는 a, b, c와 같은 식별자들이 있고 그 외부 정보는 D를 참조하도록 구성</li>
</ul>
</li>
<li>일반 추상 개념 lexical environment를 자바스크립트에서 구현한 구체적 대상이 LexicalEnvironment</li>
<li>처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨</li>
</ul>
<h3>environmentRecord</h3>
<ul>
<li>
<p>현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장됨</p>
<ul>
<li>매개변수의 이름 : 컨텍스트를 구성하는 함수에 지정된 매개변수 식별자</li>
<li>함수 선언 : 선안한 함수가 있는 경우 함수 그 자체</li>
<li>변수명 : var로 선언된 변수의 식별자</li>
</ul>
</li>
<li>
<p>컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 순서대로 수집</p>
<ul>
<li>수집을 마쳤다하더라도 아직 코드들은 실행되기 전 상태이지만</li>
<li>이미 해당 환경에 속한 코드의 변수명들을 모두 알게 되는 셈</li>
</ul>
</li>
</ul>
<h3>hoisting</h3>
<ul>
<li>
<p>엔진의 실제 동작 방식 대신에 '자바스크립트 엔진은 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다'라고 생각한다면</p>
<ul>
<li>변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상의 개념</li>
</ul>
</li>
<li>
<p>자바스크립트 엔진이 실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간주하자</p>
<ul>
<li>변수 혹은 함수 선언부만 끌어올려지며</li>
<li>할당부는 그 자리에 그대로 유지됨</li>
</ul>
</li>
<li>
<p>함수도 호이스팅 됨</p>
<ul>
<li>자바스크립트의 창시자인 브랜든 아이크가 자바스크립트를 유연하고 배우기 쉬운 언어로 만들고자 해서 탄생한 개념</li>
<li>덕분에 함수를 선언한 위치와 무관한게 그 함수를 실행할 수 있게 됐지만 오히려 이로 인해 더 많은 혼란을 야기하기도 함</li>
</ul>
</li>
</ul>
<p>호이스팅은 이 글 - <a href="https://baek.dev/post/36/">예제로 만나보는 자바스크립트 호이스팅</a>에서 자세히 살펴 볼 수 있다.  </p>
<h3>Scope Chain</h3>
<ul>
<li>
<p>스코프  </p>
<ul>
<li>식별자에 대한 유효범위  </li>
<li>어떤 경계 A의 외부에서 선언한 변수 A의 외부에서 접근 가능</li>
<li>A의 내부에서도 접근이 가능</li>
<li>A의 내부에서 선언한 변수는 오직 A의 내부에서만 접근 가능  </li>
</ul>
</li>
<li>
<p>스코프 체인</p>
<ul>
<li>식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것  </li>
<li>특정 함수 안에서 새로운 함수를 선언했다면 2번째 함수는 outerEnvironmentReference는 바깥에 있는 함수의 LexicalEnviromnet를 참조</li>
<li>이런식으로 현재 함수가 선언된 함수들의 outerEnvironment가 연결리스트 형태를 띄게 됨</li>
<li>선언 시점의 LexicalEnvironment를 계속 찾아 올가라면 결국 최상위에는 전역 컨텍스트의 LexicalEnvironment가 있을 것  </li>
</ul>
</li>
</ul>
<h5>References</h5>
<ul>
<li><a href="https://coupa.ng/bQhYRC">코어 자바스크립트</a>  </li>
<li><a href="https://poiemaweb.com/js-execution-context">실행 컨텍스트와 자바스크립트의 동작 원리</a>  </li>
</ul>]]></description><link>https://baek.dev/post/37/</link><guid isPermaLink="false">https://baek.dev/post/37/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 07 Feb 2021 07:14:00 GMT</pubDate><content:encoded>&lt;h2&gt;실행 컨텍스트(execution context)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;실행할 코드에 제공할 환경 정보들을 모아놓은 객체&lt;/li&gt;
&lt;li&gt;동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성&lt;/li&gt;
&lt;li&gt;이 구성을 call stack에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하여 전체 코드의 환경과 순서를 보장&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구성방법은 전역공간, eval() 함수, 함수 등이 있어 거의 함수를 실행하는 것으로 구성이 가능&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ES6에서는 블록에 의해서도 새로운 실행 컨텍스트가 생성됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이 객체는 브라우저 엔진이 활용할 목적으로 생성할 뿐 개발자가 코드를 통해 확인할 수는 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2021/2021_036_001.png&quot; alt=&quot;call stack&quot;&gt;  &lt;/p&gt;
&lt;p&gt;다음은 실행 컨텍스트의 수집 정보들이다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;VariableEnvironment&lt;/td&gt;
&lt;td&gt;environmentRecord(snapshot) &lt;br/&gt;outerEnvironment(snapshot)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LexicalEnvironment&lt;/td&gt;
&lt;td&gt;environmentRecord &lt;br/&gt;outerEnvironment&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ThisBinding&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;VariableEnviroment&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;현재 컨텍스트 내의 식별자들에 대한 정보 및 외부 환경 정보&lt;/li&gt;
&lt;li&gt;선언 시점의 LexicalEnvironment의 snapshot으로, 변경 사항은 반영되지 않음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이를 그대로 복사해서 LexicalEnvironment를 만들고&lt;/li&gt;
&lt;li&gt;이후에는 주로 LexicalEnvironment를 주로 활용함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;일반 추상 개념 variable environment를 자바스크립트에서 구현한 구체적 대상이 VariableEnvironment&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;LexicalEnvironment&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;수시로 변하는 환경 정보&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아놓은 것&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;예로 현재 컨텍스트의 내부에는 a, b, c와 같은 식별자들이 있고 그 외부 정보는 D를 참조하도록 구성&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;일반 추상 개념 lexical environment를 자바스크립트에서 구현한 구체적 대상이 LexicalEnvironment&lt;/li&gt;
&lt;li&gt;처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;environmentRecord&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장됨&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;매개변수의 이름 : 컨텍스트를 구성하는 함수에 지정된 매개변수 식별자&lt;/li&gt;
&lt;li&gt;함수 선언 : 선안한 함수가 있는 경우 함수 그 자체&lt;/li&gt;
&lt;li&gt;변수명 : var로 선언된 변수의 식별자&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 순서대로 수집&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;수집을 마쳤다하더라도 아직 코드들은 실행되기 전 상태이지만&lt;/li&gt;
&lt;li&gt;이미 해당 환경에 속한 코드의 변수명들을 모두 알게 되는 셈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;hoisting&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;엔진의 실제 동작 방식 대신에 &apos;자바스크립트 엔진은 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다&apos;라고 생각한다면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상의 개념&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;자바스크립트 엔진이 실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간주하자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;변수 혹은 함수 선언부만 끌어올려지며&lt;/li&gt;
&lt;li&gt;할당부는 그 자리에 그대로 유지됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;함수도 호이스팅 됨&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자바스크립트의 창시자인 브랜든 아이크가 자바스크립트를 유연하고 배우기 쉬운 언어로 만들고자 해서 탄생한 개념&lt;/li&gt;
&lt;li&gt;덕분에 함수를 선언한 위치와 무관한게 그 함수를 실행할 수 있게 됐지만 오히려 이로 인해 더 많은 혼란을 야기하기도 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;호이스팅은 이 글 - &lt;a href=&quot;https://baek.dev/post/36/&quot;&gt;예제로 만나보는 자바스크립트 호이스팅&lt;/a&gt;에서 자세히 살펴 볼 수 있다.  &lt;/p&gt;
&lt;h3&gt;Scope Chain&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;스코프  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;식별자에 대한 유효범위  &lt;/li&gt;
&lt;li&gt;어떤 경계 A의 외부에서 선언한 변수 A의 외부에서 접근 가능&lt;/li&gt;
&lt;li&gt;A의 내부에서도 접근이 가능&lt;/li&gt;
&lt;li&gt;A의 내부에서 선언한 변수는 오직 A의 내부에서만 접근 가능  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스코프 체인&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것  &lt;/li&gt;
&lt;li&gt;특정 함수 안에서 새로운 함수를 선언했다면 2번째 함수는 outerEnvironmentReference는 바깥에 있는 함수의 LexicalEnviromnet를 참조&lt;/li&gt;
&lt;li&gt;이런식으로 현재 함수가 선언된 함수들의 outerEnvironment가 연결리스트 형태를 띄게 됨&lt;/li&gt;
&lt;li&gt;선언 시점의 LexicalEnvironment를 계속 찾아 올가라면 결국 최상위에는 전역 컨텍스트의 LexicalEnvironment가 있을 것  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;References&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://coupa.ng/bQhYRC&quot;&gt;코어 자바스크립트&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://poiemaweb.com/js-execution-context&quot;&gt;실행 컨텍스트와 자바스크립트의 동작 원리&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[예제로 만나보는 자바스크립트 호이스팅(hoisting)]]></title><description><![CDATA[<h2>코드를 변경하지 않는 호이스팅</h2>
<p>호이스팅은 ECMAScript 2015 및 그 이전 표준 명세에서 사용된 적이 없는 용어이다. hoist라는 영단어 뜻이 끌어올린다라는 의미에서 유추해볼 수 있듯 hoisting은 변수와 함수를 최상단으로 끌어올린다고 <strong>개괄적</strong>으로 정의할 수 있다. 이에 호이스팅은 변수 및 함수 선언이 물리적으로 작성한 코드의 상단으로 옮겨지는 것으로 알려져 있지만, 실제로는 <code>컴파일 단계에서 메모리에 저장될 뿐, 코드 안에서는 그대로 유지</code>된다.</p>
<p>호이스팅이 개념이 나오게 된 배경은 자바스크립트가 함수를 실행하기 전에 반드시 선언되어야 한다는 여타 언어들과 달리 이 순서를 지키지 않아도 무방하도록 설계한 데서 유래한다. 정의되지 않은 함수를 어떻게 호출할 수 있는 것인지, 자바스크립트에는 마법이라도 있는 것일까?</p>
<h2>실행 컨텍스트와 절친인 호이스팅</h2>
<p>변수나 함수를 뒤늦게 정의해도 사용이 가능한 이유는 실행 컨텍스트에서 현재 컨텍스트 내의 식별자들에 대한 정보 및 외부 환경 정보를 스캔하기 때문이다. 실행 컨텍스트는 다음 포스팅에서 자세히 알아볼 예정이고, 지금은 실행할 코드에 제공할 <strong>환경 정보들을 모아놓는 객체</strong>로 기억해두고, 이 환경 정보들을 어떻게 수집하는지 간단히 살펴봄으로써 호이스팅을 좀 더 이해할 수 있다.</p>
<ul>
<li>
<p>현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장됨</p>
<ul>
<li>매개변수의 이름 : 컨텍스트를 구성하는 함수에 지정된 매개변수 식별자</li>
<li>함수 선언 : 선안한 함수가 있는 경우 함수 그 자체</li>
<li>변수명 : var로 선언된 변수의 식별자</li>
</ul>
</li>
<li>
<p><code>컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 순서대로 수집</code></p>
<ul>
<li>수집을 마쳤다하더라도 아직 코드들은 실행되기 전 상태이지만</li>
<li><strong>이미 해당 환경에 속한 코드의 변수명들을 모두 알게 되는 셈</strong></li>
</ul>
</li>
</ul>
<h2>다시 정리해본 호이스팅</h2>
<ul>
<li>
<p>엔진의 실제 동작 방식 대신에 <code>자바스크립트 엔진은 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다</code>라고 생각한다면</p>
<ul>
<li>변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상의 개념</li>
</ul>
</li>
<li>
<p>자바스크립트 엔진이 실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간주하자</p>
<ul>
<li><strong>변수 혹은 함수 선언부만 끌어올려지며</strong></li>
<li><strong>할당부는 그 자리에 그대로 유지됨</strong></li>
</ul>
</li>
<li>
<p>함수도 호이스팅 됨</p>
<ul>
<li>자바스크립트의 창시자인 브랜든 아이크가 자바스크립트를 유연하고 배우기 쉬운 언어로 만들고자 해서 탄생한 개념</li>
<li>덕분에 함수를 선언한 위치와 무관한게 그 함수를 실행할 수 있게 됐지만 오히려 이로 인해 더 많은 혼란을 야기하기도 함</li>
</ul>
</li>
</ul>
<h2>예제를 통해 만나본 호이스팅</h2>
<h3>기본 코드를 호이스팅으로 변환해보기</h3>
<p>코드를 직접 실행해보기 전에 머릿속으로 시뮬레이션 해보자.</p>
<p>&#x3C;예제1 - 호이스팅이 발생할 것 같은 샘플 코드></p>
<pre><code class="language-javascript">function hello() {
    console.log(1, world); // 예상하건데 world?
    var world = "world";
    console.log(2, world); // 예상하건데 world?
    function world() {
        console.log("hello world");
    }
    console.log(3, world); // 예상하건데 f world()?
}
hello();
</code></pre>
<p>예제1을 실행하면 코드내 주석처럼 예상해볼 수 있을 것 같지만, 실행 결과는 완전히 다르다!</p>
<p>&#x3C;결과1></p>
<pre><code class="language-javascript">1 ƒ world() { window.runnerWindow.proxyConsole.log("hello world");}
2 world
3 world
</code></pre>
<p>위 예제1을 실제로 코드가 변하지는 않지만 호이스팅된 것으로 예제2처럼 재표현하여 이해를 도울 수 있다.</p>
<p>&#x3C;예제2 - 호이스팅으로 재표현한 예제1></p>
<pre><code class="language-javascript">function hello() {
    var world;
    var world = function world() {
        console.log("hello world");
    }; // 실행 컨텍스트 수집 대상
    console.log(1, world); // 출력 : f world()
    world = "world"; // 변수 할당 부는 그대로 유지
    console.log(2, world); // 출력 : world
    console.log(3, world); // 출력 : world
}
hello();
</code></pre>
<h3>함수를 선언하는 다양한 방법 - 함수 선언문과 함수 표현식</h3>
<p>함수를 선언하는 방법에 따라 호이스팅의 결과도 다를 수 있다. 먼저 다양한 함수 선언 방법을 살펴보자.</p>
<p>&#x3C;예제3 - 다양한 함수 선언 방법></p>
<pre><code class="language-javascript">// 함수 선언문
function sayHello() {
    console.log("Hello");
}
sayHello();

// 익명 함수 표현식
var sayWorld = function () {
    console.log("World");
};
sayWorld();

// 기명 함수 표현식
var sayWelcome = function welcome() {
    console.log("Welcome");
};
sayWelcome();
</code></pre>
<p>예제3에서 보듯 함수를 새롭게 정의할 땐 크게 2가지 방식이 있다.</p>
<ul>
<li>
<p><code>함수 선언문</code></p>
<ul>
<li>함수를 선언하기만 하고 별도로 호출하지 않음</li>
<li>함수명이 반드시 정의되야 함</li>
</ul>
</li>
<li>
<p><code>함수 표현식</code></p>
<ul>
<li>정의한 함수를 별도의 변수에 할당하는 것</li>
<li>함수명이 없는 익명 함수 혹은 기명 함수로 정의 가능</li>
</ul>
</li>
</ul>
<h3>함수 선언문과 함수 표현식의 호이스팅 차이</h3>
<p>&#x3C;예제4 - 함수 선언 방법별 호이스팅을 예측해보기></p>
<pre><code class="language-javascript">console.log(sum(1, 2));
console.log(multiply(3, 4));

// 함수 선언문으로 sum() 를 선언
function sum(a, b) {
    return a + b;
}

// 함수 표현식으로 multiply() 를 선언
var multiply = function (a, b) {
    return a * b;
};
</code></pre>
<p>함수 선언문과 함수 표현식으로 정의한 예제4를 실행하면 sum()과 multiply()가 잘 실행될까? 결과2를 확인해보자.</p>
<p>&#x3C;결과2></p>
<pre><code class="language-javascript">VM388:2 Uncaught TypeError: multiply is not a function
    at &#x3C;anonymous>:2:13
</code></pre>
<p>어째서 multiply는 함수가 아니라는 오류가 발생한 것일까? sum()도 동일하게 코드상 호출부분 이후에 정의했는데 말이다. 그건 바로 <code>호이스팅</code>때문이다. 다음 예제5는 예제4를 호이스팅으로 재표현한 코드다.</p>
<p>&#x3C;예제5 - 함수 선언 방법별 호이스팅으로 재표현한 예제4></p>
<pre><code class="language-javascript">// 함수 선언문은 전체를 호이스팅 한다.
var sum = function sum(a, b) {
    return a + b;
};

// 함수 표현식은 변수만 호이스팅하고,
var multiply;

console.log(sum(1, 2));
console.log(multiply(3, 4));

// 함수 표현식에서 할당부는 제 위치에 유지한다.
multiply = function (a, b) {
    return a * b;
};
</code></pre>
<p>호이스팅으로 재표현한 예제5를 보면 함수 역시도 변수와 마찬가지로 선언부는 맨 위로 올리지만, 할당부는 원래 선언한 위치에 유지한다. 그래서 이 <code>console.log(multiply(3, 4));</code> 부분에서 선언만 하고 함수가 할당되기 전인 변수 multiply를 함수처럼 호출해서 에러가 발생하게 된다. 위 예제5는 함수 선언문과 함수 표현식이 어떤 차이가 있는지 보여준다. 한가지 더 예제6을 살펴보자.</p>
<h3>함수 선언문의 호이스팅 사이드 이펙트</h3>
<p>같은 함수를 하나의 컨텍스트에서 함수 선언문 형태로 중복 선언 한 경우 어떤 영향이 있을까? 예제6을 통해 살펴보자.</p>
<p>&#x3C;예제6 - 같은 이름으로 중복 정의한 함수 선언문></p>
<pre><code class="language-javascript">console.log(sum(1, 2)); // return 3?

// 첫번째 sum 함수 선언문
function sum(a, b) {
    return a + b;
}

// ... (중략)

console.log(sum(3, 4)); // return 7?
// 두번째 sum 함수 선언문
function sum(a, b) {
    return `${a} + ${b} = ${a + b}`;
}
</code></pre>
<p>예제6의 경우 순서대로 호이스팅되면서 나중에 선언한 두번째 sum()으로 overriding된다. 흔한 케이스는 아니지만 코드가 어떻게 작성되어있는지에 따라 이 경우 오류 없이 지나칠 수 있고 찾기 힘든 버그로 둔갑할 수도 있다.</p>
<p>&#x3C;예제7 - 호이스팅으로 재표현한 예제6></p>
<pre><code class="language-javascript">var sum = function sum(a, b) {
    return a + b;
};
var sum = function sum(a, b) {
    return `${a} + ${b} = ${a + b}`;
};

console.log(sum(1, 2));
console.log(sum(3, 4));
</code></pre>
<p>&#x3C;결과3></p>
<pre><code class="language-javascript">1 + 2 = 3
3 + 4 = 7
</code></pre>
<hr>
<p>막연히 변수를 위로 끌어올린다고만 알고 있었던 호이스팅을 직접 예제를 통해 정리하니 명쾌해졌다. 호이스팅은 앞서 언급한 대로 혼자서 단독 작동하는 것이 아니라 실행 컨텍스트로 인해 움직인다. 다음에는 이 실행 컨텍스트에 대해 공유할 예정이다 :)</p>
<h5>References</h5>
<ul>
<li><a href="https://developer.mozilla.org/ko/docs/Glossary/Hoisting">Hoisting | MDN</a></li>
<li><a href="https://coupa.ng/bQhYRC">코어 자바스크립트</a></li>
</ul>]]></description><link>https://baek.dev/post/36/</link><guid isPermaLink="false">https://baek.dev/post/36/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Mon, 25 Jan 2021 16:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;코드를 변경하지 않는 호이스팅&lt;/h2&gt;
&lt;p&gt;호이스팅은 ECMAScript 2015 및 그 이전 표준 명세에서 사용된 적이 없는 용어이다. hoist라는 영단어 뜻이 끌어올린다라는 의미에서 유추해볼 수 있듯 hoisting은 변수와 함수를 최상단으로 끌어올린다고 &lt;strong&gt;개괄적&lt;/strong&gt;으로 정의할 수 있다. 이에 호이스팅은 변수 및 함수 선언이 물리적으로 작성한 코드의 상단으로 옮겨지는 것으로 알려져 있지만, 실제로는 &lt;code&gt;컴파일 단계에서 메모리에 저장될 뿐, 코드 안에서는 그대로 유지&lt;/code&gt;된다.&lt;/p&gt;
&lt;p&gt;호이스팅이 개념이 나오게 된 배경은 자바스크립트가 함수를 실행하기 전에 반드시 선언되어야 한다는 여타 언어들과 달리 이 순서를 지키지 않아도 무방하도록 설계한 데서 유래한다. 정의되지 않은 함수를 어떻게 호출할 수 있는 것인지, 자바스크립트에는 마법이라도 있는 것일까?&lt;/p&gt;
&lt;h2&gt;실행 컨텍스트와 절친인 호이스팅&lt;/h2&gt;
&lt;p&gt;변수나 함수를 뒤늦게 정의해도 사용이 가능한 이유는 실행 컨텍스트에서 현재 컨텍스트 내의 식별자들에 대한 정보 및 외부 환경 정보를 스캔하기 때문이다. 실행 컨텍스트는 다음 포스팅에서 자세히 알아볼 예정이고, 지금은 실행할 코드에 제공할 &lt;strong&gt;환경 정보들을 모아놓는 객체&lt;/strong&gt;로 기억해두고, 이 환경 정보들을 어떻게 수집하는지 간단히 살펴봄으로써 호이스팅을 좀 더 이해할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장됨&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;매개변수의 이름 : 컨텍스트를 구성하는 함수에 지정된 매개변수 식별자&lt;/li&gt;
&lt;li&gt;함수 선언 : 선안한 함수가 있는 경우 함수 그 자체&lt;/li&gt;
&lt;li&gt;변수명 : var로 선언된 변수의 식별자&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 순서대로 수집&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;수집을 마쳤다하더라도 아직 코드들은 실행되기 전 상태이지만&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이미 해당 환경에 속한 코드의 변수명들을 모두 알게 되는 셈&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;다시 정리해본 호이스팅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;엔진의 실제 동작 방식 대신에 &lt;code&gt;자바스크립트 엔진은 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다&lt;/code&gt;라고 생각한다면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상의 개념&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;자바스크립트 엔진이 실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간주하자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;변수 혹은 함수 선언부만 끌어올려지며&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;할당부는 그 자리에 그대로 유지됨&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;함수도 호이스팅 됨&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자바스크립트의 창시자인 브랜든 아이크가 자바스크립트를 유연하고 배우기 쉬운 언어로 만들고자 해서 탄생한 개념&lt;/li&gt;
&lt;li&gt;덕분에 함수를 선언한 위치와 무관한게 그 함수를 실행할 수 있게 됐지만 오히려 이로 인해 더 많은 혼란을 야기하기도 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;예제를 통해 만나본 호이스팅&lt;/h2&gt;
&lt;h3&gt;기본 코드를 호이스팅으로 변환해보기&lt;/h3&gt;
&lt;p&gt;코드를 직접 실행해보기 전에 머릿속으로 시뮬레이션 해보자.&lt;/p&gt;
&lt;p&gt;&amp;#x3C;예제1 - 호이스팅이 발생할 것 같은 샘플 코드&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function hello() {
    console.log(1, world); // 예상하건데 world?
    var world = &quot;world&quot;;
    console.log(2, world); // 예상하건데 world?
    function world() {
        console.log(&quot;hello world&quot;);
    }
    console.log(3, world); // 예상하건데 f world()?
}
hello();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예제1을 실행하면 코드내 주석처럼 예상해볼 수 있을 것 같지만, 실행 결과는 완전히 다르다!&lt;/p&gt;
&lt;p&gt;&amp;#x3C;결과1&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;1 ƒ world() { window.runnerWindow.proxyConsole.log(&quot;hello world&quot;);}
2 world
3 world
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 예제1을 실제로 코드가 변하지는 않지만 호이스팅된 것으로 예제2처럼 재표현하여 이해를 도울 수 있다.&lt;/p&gt;
&lt;p&gt;&amp;#x3C;예제2 - 호이스팅으로 재표현한 예제1&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function hello() {
    var world;
    var world = function world() {
        console.log(&quot;hello world&quot;);
    }; // 실행 컨텍스트 수집 대상
    console.log(1, world); // 출력 : f world()
    world = &quot;world&quot;; // 변수 할당 부는 그대로 유지
    console.log(2, world); // 출력 : world
    console.log(3, world); // 출력 : world
}
hello();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;함수를 선언하는 다양한 방법 - 함수 선언문과 함수 표현식&lt;/h3&gt;
&lt;p&gt;함수를 선언하는 방법에 따라 호이스팅의 결과도 다를 수 있다. 먼저 다양한 함수 선언 방법을 살펴보자.&lt;/p&gt;
&lt;p&gt;&amp;#x3C;예제3 - 다양한 함수 선언 방법&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 함수 선언문
function sayHello() {
    console.log(&quot;Hello&quot;);
}
sayHello();

// 익명 함수 표현식
var sayWorld = function () {
    console.log(&quot;World&quot;);
};
sayWorld();

// 기명 함수 표현식
var sayWelcome = function welcome() {
    console.log(&quot;Welcome&quot;);
};
sayWelcome();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예제3에서 보듯 함수를 새롭게 정의할 땐 크게 2가지 방식이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;함수 선언문&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;함수를 선언하기만 하고 별도로 호출하지 않음&lt;/li&gt;
&lt;li&gt;함수명이 반드시 정의되야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;함수 표현식&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;정의한 함수를 별도의 변수에 할당하는 것&lt;/li&gt;
&lt;li&gt;함수명이 없는 익명 함수 혹은 기명 함수로 정의 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;함수 선언문과 함수 표현식의 호이스팅 차이&lt;/h3&gt;
&lt;p&gt;&amp;#x3C;예제4 - 함수 선언 방법별 호이스팅을 예측해보기&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;console.log(sum(1, 2));
console.log(multiply(3, 4));

// 함수 선언문으로 sum() 를 선언
function sum(a, b) {
    return a + b;
}

// 함수 표현식으로 multiply() 를 선언
var multiply = function (a, b) {
    return a * b;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;함수 선언문과 함수 표현식으로 정의한 예제4를 실행하면 sum()과 multiply()가 잘 실행될까? 결과2를 확인해보자.&lt;/p&gt;
&lt;p&gt;&amp;#x3C;결과2&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;VM388:2 Uncaught TypeError: multiply is not a function
    at &amp;#x3C;anonymous&gt;:2:13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;어째서 multiply는 함수가 아니라는 오류가 발생한 것일까? sum()도 동일하게 코드상 호출부분 이후에 정의했는데 말이다. 그건 바로 &lt;code&gt;호이스팅&lt;/code&gt;때문이다. 다음 예제5는 예제4를 호이스팅으로 재표현한 코드다.&lt;/p&gt;
&lt;p&gt;&amp;#x3C;예제5 - 함수 선언 방법별 호이스팅으로 재표현한 예제4&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 함수 선언문은 전체를 호이스팅 한다.
var sum = function sum(a, b) {
    return a + b;
};

// 함수 표현식은 변수만 호이스팅하고,
var multiply;

console.log(sum(1, 2));
console.log(multiply(3, 4));

// 함수 표현식에서 할당부는 제 위치에 유지한다.
multiply = function (a, b) {
    return a * b;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;호이스팅으로 재표현한 예제5를 보면 함수 역시도 변수와 마찬가지로 선언부는 맨 위로 올리지만, 할당부는 원래 선언한 위치에 유지한다. 그래서 이 &lt;code&gt;console.log(multiply(3, 4));&lt;/code&gt; 부분에서 선언만 하고 함수가 할당되기 전인 변수 multiply를 함수처럼 호출해서 에러가 발생하게 된다. 위 예제5는 함수 선언문과 함수 표현식이 어떤 차이가 있는지 보여준다. 한가지 더 예제6을 살펴보자.&lt;/p&gt;
&lt;h3&gt;함수 선언문의 호이스팅 사이드 이펙트&lt;/h3&gt;
&lt;p&gt;같은 함수를 하나의 컨텍스트에서 함수 선언문 형태로 중복 선언 한 경우 어떤 영향이 있을까? 예제6을 통해 살펴보자.&lt;/p&gt;
&lt;p&gt;&amp;#x3C;예제6 - 같은 이름으로 중복 정의한 함수 선언문&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;console.log(sum(1, 2)); // return 3?

// 첫번째 sum 함수 선언문
function sum(a, b) {
    return a + b;
}

// ... (중략)

console.log(sum(3, 4)); // return 7?
// 두번째 sum 함수 선언문
function sum(a, b) {
    return `${a} + ${b} = ${a + b}`;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;예제6의 경우 순서대로 호이스팅되면서 나중에 선언한 두번째 sum()으로 overriding된다. 흔한 케이스는 아니지만 코드가 어떻게 작성되어있는지에 따라 이 경우 오류 없이 지나칠 수 있고 찾기 힘든 버그로 둔갑할 수도 있다.&lt;/p&gt;
&lt;p&gt;&amp;#x3C;예제7 - 호이스팅으로 재표현한 예제6&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var sum = function sum(a, b) {
    return a + b;
};
var sum = function sum(a, b) {
    return `${a} + ${b} = ${a + b}`;
};

console.log(sum(1, 2));
console.log(sum(3, 4));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;#x3C;결과3&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;1 + 2 = 3
3 + 4 = 7
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;막연히 변수를 위로 끌어올린다고만 알고 있었던 호이스팅을 직접 예제를 통해 정리하니 명쾌해졌다. 호이스팅은 앞서 언급한 대로 혼자서 단독 작동하는 것이 아니라 실행 컨텍스트로 인해 움직인다. 다음에는 이 실행 컨텍스트에 대해 공유할 예정이다 :)&lt;/p&gt;
&lt;h5&gt;References&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Glossary/Hoisting&quot;&gt;Hoisting | MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://coupa.ng/bQhYRC&quot;&gt;코어 자바스크립트&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[뉴노멀 중심에서 하는 2020 회고]]></title><description><![CDATA[<h2>코로나가 가져다준 기회</h2>
<h3>문서 정리</h3>
<p>연초에 참여한 TF가 꽤 기억에 남는다. 정량화된 목표를 달성하는 것은 매우 재밌었고 스릴 넘쳤다. 하지만 그만큼 매우 힘들었던 것은 안 비밀. 그래도 이 프로젝트 덕분에 <code>문서의 중요성</code>을 알게 되었고, 어떤 일을 하든 꼭 문서화한다. 코로나 전에는 모두 모여서 일을 하니 그때그때 바로 궁금한 것을 확인하면 되지만, 아무래도 비동기로 일을 하다 보니 즉각적인 확인에 어려움이 있다. 그리고 같은 이야기를 하고 있는 것 같지만 의외로 싱크가 안 맞는 경우도 있다. 그래서 문서 작성에 대해 매우 중요하게 생각하게 되었다. 예전에는 '개발에 문서가 왜 필요할까? 문서 작성이 병목이 돼선 안된다'고 생각했던 시절도 있었는데, 이건 정말 <del>경기도</del> 오산이었다.  </p>
<p>물론 코드를 형상관리(svn, git) 하지만 코드에 담을 수 있는 내용엔 한계가 있다. 해당 피처가 시작된 백그라운드, 의사 결정, 엣지 케이스, 다음 단계에 대한 계획 등 코드가 품을 수 없는 이상의 것들이 있다. 또한 개발자가 커뮤니케이션할 땐 코드로 말하지 않는 비개발의 직군들도 많기 때문이다. 그리고 여러 도구를 이용해 일어나는 대화를 한곳으로 모아주는 역할도 한다. 누군가 내게 질문하면 해당 문서의 링크만 전달해 주면 되는 것이다.<br>
문서를 휘황찬란하게 만들 필요는 없으나, 다른 동료가 이 문서 하나로 앞뒤 사정을 파악할 수 있도록 정리하는 것에 개발자들이 동참하면 좋겠다.  </p>
<h3>코로나 블루와 소중함</h3>
<p>코로나로 인해 의무 재택이 연초부터 시작됐다. 그 재택은 아직도 진행 중. 원래 재택근무 제도가 있었고 매우 잘 이용하고 있었지만, 강제로 하는 재택은 쉽지만은 않았다. 처음에는 신명 나게 재택을 했지만 이제는 재택이 나를 하는 것 같다(?) 카페를 갈 수도 없으니 타의에 의해 오로지 집에서만 하는 일은 쉽지 않고, 종종 시켜 먹는 배달음식은 마치 사식을 받는 것 같다. 코로나, 대체 누구냐 넌?!    </p>
<p>코로나 유행 초반, <code>코로나 블루</code>라는 단어가 처음 나왔다. 남일인 줄로만 알았는데 지금은 내가 그걸 겪고 있는 게 아닌가 싶다. 특히 뉴스를 보면 감염되는 사람들은 주체할 수없이 늘어나고 심지어 꾸준하다. 나는 이렇게 집에만 콕 박혀있는데.. 사람들은 어딜 그렇게 다니는 걸까라며 오히려 집에만 있는 내가 바보가 된 건 아닐까 하는 박탈감을 느끼기도 한다.  </p>
<p>과도한 업무와 시도 때도 없이 울려대는 서비스 얼럿들을 확인하고 팔로업하다보니 삶과 일의 경계가 모호한 직업이라 더 박탈감이 심한 것 같다. 그래도 한 편으로는 이런 민감하고 위험한 시국에도 업을 계속 이어갈 수 있다는 게 얼마나 다행이며 감사한지 되돌아 보게 된다.  </p>
<h3>새로운 도전</h3>
<p>작년부터 쉼 없이 달려오기도 했고, 과도한 업무가 겹쳐 번아웃이 왔다. 어떤 미팅을 들어가도 회의에 그 자체에 집중할 수 없고, 내용을 머릿속으로 그릴 수가 없었다. 그래서 처음으로 휴직을 했었다. 육아휴직 혹은 출산휴직이 아닌 이상 휴직하면 하늘이 두 쪽 나는 줄 알았지만, 주변에는 리프레시용으로 휴직을 했던 분들이 계셔서 용기를 내 휴직했다. 짧은 기간이었지만 이 시간 동안 나를 많이 돌아봤다. 번아웃이 오게 된 배경은 무엇일까부터 시작해서 미래를 다시 그려보는 재정비를 했다.  </p>
<p>재정비 끝에 <code>큰 결심</code>을 내렸다. 먼길을 돌아온 것 같지만, 이 길이 맞지 싶다. 확신이 섰다. 이 썰은 내년에 풀어봐야겠다.  </p>
<h3>경제적 자유</h3>
<p>쉬는 동안 재테크에도 많은 관심을 갖고 돌아보게 되었다. 늘 경제 분야는 어렵고, 삶이 바쁘단 이유로 재테크를 너무 등한시한 것에 반성하며 지금이라도 눈을 뜬 게 얼마나 다행인가.  </p>
<p>이제 돈을 바라보는 시각이 많이 바뀌었다. 한국에선 돈이라는 주제를 드러내놓고 말하면 사람들은 속물 취급을 한다. 하지만 돈이 많은 사람을 경외하곤 한다. 앞뒤가 맞을 수가 없다. 자본주의 사회에서 돈 없이 할 수 있는게 무엇일까? 돈이 있다고 해서 반드시 행복한 것은 아니고 인생의 전부는 아니지만, 돈이 없으면 적어도 힘들지 않을 순 없는 것이 사실이다.  </p>
<p>단순히 돈을 열심히 벌고 아끼고 저축하는 것만이 유일한 수단이었던 월급쟁이가 어떻게 미래를 그릴 수 있겠는가. 날로 무섭게 치솟는 아파트 가격을 보면 이 세상 이야기가 아닌 것 같다. 그런데 재테크를 시작하면서부터 꿈을 크게 그리게 되었다. <code>경제적 자유</code>가 내 이야기가 될 수 있다는 그림을 그릴 수 있게 됐다. 재테크에 관한 이야기는 주제를 나눈 다른 블로그를 통해 연재할 계획이다.  </p>
<h2>블로그 회고</h2>
<p>1년 동안 작성한 글은 총 16개로 한 달 평균 1.3개씩 작성했으므로 선방했다. 작년 2019년엔 총 14개를 작성했었다. 다음은 2020년에 작성한 글들 중 조회수가 높은 글들 몇 개 추려봤다.   </p>
<p>털어놓기 어려웠던 개발자로서 고민을 해결해준 책, 함께 자라기  </p>
<ul>
<li><a href="https://baek.dev/post/16/">https://baek.dev/post/16/</a>  </li>
<li>개발자를 넘어 인생 책이라고 소개하고 싶은 포스팅  </li>
<li>슬럼프 혹은 더딘 발전이 고민이라면 추천하고 싶다.  </li>
</ul>
<p>둘리 &#x26; 도우너 어서오고 짤 생성기 회고  </p>
<ul>
<li><a href="https://baek.dev/post/33/">https://baek.dev/post/33/</a>  </li>
<li>하고 싶었던 짤 생성기 프로젝트에 대한 회고 포스팅이다.  </li>
<li>짭짤한 트래픽 맛을 보게 해준 프로젝트를 어떻게 만들게 되었는지 공유했다.  </li>
</ul>
<p>자동으로 스터디 모집 글을 모아 알림을 주는 파이썬 크롤러 만들기(with Github Actions)  </p>
<ul>
<li><a href="https://baek.dev/post/17/">https://baek.dev/post/17/</a>  </li>
<li>설날에 뚝딱 만들었던 크롤러 프로젝트  </li>
<li>당시 깃헙액션이 나온 지 얼마 되지 않았을 때 만들어본 것이라 재밌었고 현재까지도 잘 쓰고 있다.  </li>
</ul>
<p>객체지향을 한 단어로 설명한다면 그것은 클래스가 아니라 메시지이다  </p>
<ul>
<li><a href="https://baek.dev/post/22/">https://baek.dev/post/22/</a>  </li>
<li>유명한 토끼 책에서 핵심이라고 생각된 부분을 짧게 포스팅했다.  </li>
<li>물론 책이 워낙 좋아서 무엇 하나 포기할 수 없지만, 하나를 꼽자면 객체지향의 사실과 오해 5장 &#x3C;책임과 메시지>다.   </li>
</ul>
<p>Apache Kafka - 높은 처리량과 실시간으로 대량의 데이터를 취급하는 카프카  </p>
<ul>
<li><a href="https://baek.dev/post/20/">https://baek.dev/post/20/</a>  </li>
<li>대용량 스트림엔 카프카만 한 것이 있을까 싶다.  </li>
<li>카프카 셋팅으로 고생하고 작성해서 꼭 필요한 부분 위주로 요약했다. </li>
</ul>
<p>찾기 힘든 버그를 유발하는 Java DTO 컨버팅 노가다, 리팩토링하기  </p>
<ul>
<li><a href="https://baek.dev/post/15/">https://baek.dev/post/15/</a>  </li>
<li>현재는 ModelMapper는 Deprecated하고 MapStruct를 사용하고 있다.  </li>
</ul>
<p>이어 10월에는 블로그를 Jekyll에서 <strong>Gatsby로</strong> 전환했다. 정적 사이트 블로그이지만 포스팅에 좀 더 다이나믹한 효과를 주고 싶어서 결정하게 된 Gatsby. 포팅 할 때 가장 중요하게 생각했던 건 기존 블로그와의 url 호환이었다. React와 Node가 익숙치 않아 고생을 좀 했지만, 그래도 성공!. Gatsby 포팅 관련 포스팅도 조만간 준비해야겠다.  </p>
<h2>내년에는요</h2>
<p>재정비 끝에 내린 큰 결심을 진행하는 해이다. 이 부분이 가장 큰 메인 스트림이라 여기에 집중해야 한다. 코로나 때문에 활동에 많은 제약이 따르지만 내년엔 더 다양한 활동을 할 수 있으리라 기대해본다.   </p>
<p>그리고 책 읽기가 절대적으로 너무 부족하다. 좀 더 의식적으로 책을 읽으려고 하는데 잘 안된다. 그러다 우연히 본 회고 포스팅 중 읽은 책들을 짦게 독후감을 쓰는 것을 보고 그렇게라도 꾸준히 해봐야겠다 다짐했다. 52주 동안 1권씩 읽기를 많이들 하지만 힘든 것이 자명하니 최소 한 달에 한 권은 비 개발 서적 읽기를 목표로 삼았다.   </p>
<p>끝으로 건강관리다. 하고 싶은 일을 하기 위해서는 체력이 따라줘야 한다. 활동량이 적다 보니 살이 찐 느낌인데, 몸무게는 거의 비슷하다. 근육이 빠지고 지방이 더 찐 것이다. 태생이 근육이 많은 편인데, 근육이 빠지니 충격을 받았다! 이 와중에 팀원분이 링피트를 샀다고하고, 얼마 전 재밌게 본 발표에서도 자동화를 통해 링피트를 꾸준히 한다고 하는 경험담을 보고 이 참에 나도 링피트를 들였다. 꾸준히 해서 소중한 근육 지켜야지!  </p>
<hr>
<p>내년에도 집콕하겠지만 잘 견뎌내 코로나를 피하고, 백신 맞으러 가야겠다 :)</p>
<p>이미지 출처 : <a href="https://blog.naver.com/minumworld/222180449907">민음사 인생일력</a><br>
</p>]]></description><link>https://baek.dev/post/34/</link><guid isPermaLink="false">https://baek.dev/post/34/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 27 Dec 2020 12:14:00 GMT</pubDate><content:encoded>&lt;h2&gt;코로나가 가져다준 기회&lt;/h2&gt;
&lt;h3&gt;문서 정리&lt;/h3&gt;
&lt;p&gt;연초에 참여한 TF가 꽤 기억에 남는다. 정량화된 목표를 달성하는 것은 매우 재밌었고 스릴 넘쳤다. 하지만 그만큼 매우 힘들었던 것은 안 비밀. 그래도 이 프로젝트 덕분에 &lt;code&gt;문서의 중요성&lt;/code&gt;을 알게 되었고, 어떤 일을 하든 꼭 문서화한다. 코로나 전에는 모두 모여서 일을 하니 그때그때 바로 궁금한 것을 확인하면 되지만, 아무래도 비동기로 일을 하다 보니 즉각적인 확인에 어려움이 있다. 그리고 같은 이야기를 하고 있는 것 같지만 의외로 싱크가 안 맞는 경우도 있다. 그래서 문서 작성에 대해 매우 중요하게 생각하게 되었다. 예전에는 &apos;개발에 문서가 왜 필요할까? 문서 작성이 병목이 돼선 안된다&apos;고 생각했던 시절도 있었는데, 이건 정말 &lt;del&gt;경기도&lt;/del&gt; 오산이었다.  &lt;/p&gt;
&lt;p&gt;물론 코드를 형상관리(svn, git) 하지만 코드에 담을 수 있는 내용엔 한계가 있다. 해당 피처가 시작된 백그라운드, 의사 결정, 엣지 케이스, 다음 단계에 대한 계획 등 코드가 품을 수 없는 이상의 것들이 있다. 또한 개발자가 커뮤니케이션할 땐 코드로 말하지 않는 비개발의 직군들도 많기 때문이다. 그리고 여러 도구를 이용해 일어나는 대화를 한곳으로 모아주는 역할도 한다. 누군가 내게 질문하면 해당 문서의 링크만 전달해 주면 되는 것이다.&lt;br&gt;
문서를 휘황찬란하게 만들 필요는 없으나, 다른 동료가 이 문서 하나로 앞뒤 사정을 파악할 수 있도록 정리하는 것에 개발자들이 동참하면 좋겠다.  &lt;/p&gt;
&lt;h3&gt;코로나 블루와 소중함&lt;/h3&gt;
&lt;p&gt;코로나로 인해 의무 재택이 연초부터 시작됐다. 그 재택은 아직도 진행 중. 원래 재택근무 제도가 있었고 매우 잘 이용하고 있었지만, 강제로 하는 재택은 쉽지만은 않았다. 처음에는 신명 나게 재택을 했지만 이제는 재택이 나를 하는 것 같다(?) 카페를 갈 수도 없으니 타의에 의해 오로지 집에서만 하는 일은 쉽지 않고, 종종 시켜 먹는 배달음식은 마치 사식을 받는 것 같다. 코로나, 대체 누구냐 넌?!    &lt;/p&gt;
&lt;p&gt;코로나 유행 초반, &lt;code&gt;코로나 블루&lt;/code&gt;라는 단어가 처음 나왔다. 남일인 줄로만 알았는데 지금은 내가 그걸 겪고 있는 게 아닌가 싶다. 특히 뉴스를 보면 감염되는 사람들은 주체할 수없이 늘어나고 심지어 꾸준하다. 나는 이렇게 집에만 콕 박혀있는데.. 사람들은 어딜 그렇게 다니는 걸까라며 오히려 집에만 있는 내가 바보가 된 건 아닐까 하는 박탈감을 느끼기도 한다.  &lt;/p&gt;
&lt;p&gt;과도한 업무와 시도 때도 없이 울려대는 서비스 얼럿들을 확인하고 팔로업하다보니 삶과 일의 경계가 모호한 직업이라 더 박탈감이 심한 것 같다. 그래도 한 편으로는 이런 민감하고 위험한 시국에도 업을 계속 이어갈 수 있다는 게 얼마나 다행이며 감사한지 되돌아 보게 된다.  &lt;/p&gt;
&lt;h3&gt;새로운 도전&lt;/h3&gt;
&lt;p&gt;작년부터 쉼 없이 달려오기도 했고, 과도한 업무가 겹쳐 번아웃이 왔다. 어떤 미팅을 들어가도 회의에 그 자체에 집중할 수 없고, 내용을 머릿속으로 그릴 수가 없었다. 그래서 처음으로 휴직을 했었다. 육아휴직 혹은 출산휴직이 아닌 이상 휴직하면 하늘이 두 쪽 나는 줄 알았지만, 주변에는 리프레시용으로 휴직을 했던 분들이 계셔서 용기를 내 휴직했다. 짧은 기간이었지만 이 시간 동안 나를 많이 돌아봤다. 번아웃이 오게 된 배경은 무엇일까부터 시작해서 미래를 다시 그려보는 재정비를 했다.  &lt;/p&gt;
&lt;p&gt;재정비 끝에 &lt;code&gt;큰 결심&lt;/code&gt;을 내렸다. 먼길을 돌아온 것 같지만, 이 길이 맞지 싶다. 확신이 섰다. 이 썰은 내년에 풀어봐야겠다.  &lt;/p&gt;
&lt;h3&gt;경제적 자유&lt;/h3&gt;
&lt;p&gt;쉬는 동안 재테크에도 많은 관심을 갖고 돌아보게 되었다. 늘 경제 분야는 어렵고, 삶이 바쁘단 이유로 재테크를 너무 등한시한 것에 반성하며 지금이라도 눈을 뜬 게 얼마나 다행인가.  &lt;/p&gt;
&lt;p&gt;이제 돈을 바라보는 시각이 많이 바뀌었다. 한국에선 돈이라는 주제를 드러내놓고 말하면 사람들은 속물 취급을 한다. 하지만 돈이 많은 사람을 경외하곤 한다. 앞뒤가 맞을 수가 없다. 자본주의 사회에서 돈 없이 할 수 있는게 무엇일까? 돈이 있다고 해서 반드시 행복한 것은 아니고 인생의 전부는 아니지만, 돈이 없으면 적어도 힘들지 않을 순 없는 것이 사실이다.  &lt;/p&gt;
&lt;p&gt;단순히 돈을 열심히 벌고 아끼고 저축하는 것만이 유일한 수단이었던 월급쟁이가 어떻게 미래를 그릴 수 있겠는가. 날로 무섭게 치솟는 아파트 가격을 보면 이 세상 이야기가 아닌 것 같다. 그런데 재테크를 시작하면서부터 꿈을 크게 그리게 되었다. &lt;code&gt;경제적 자유&lt;/code&gt;가 내 이야기가 될 수 있다는 그림을 그릴 수 있게 됐다. 재테크에 관한 이야기는 주제를 나눈 다른 블로그를 통해 연재할 계획이다.  &lt;/p&gt;
&lt;h2&gt;블로그 회고&lt;/h2&gt;
&lt;p&gt;1년 동안 작성한 글은 총 16개로 한 달 평균 1.3개씩 작성했으므로 선방했다. 작년 2019년엔 총 14개를 작성했었다. 다음은 2020년에 작성한 글들 중 조회수가 높은 글들 몇 개 추려봤다.   &lt;/p&gt;
&lt;p&gt;털어놓기 어려웠던 개발자로서 고민을 해결해준 책, 함께 자라기  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://baek.dev/post/16/&quot;&gt;https://baek.dev/post/16/&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;개발자를 넘어 인생 책이라고 소개하고 싶은 포스팅  &lt;/li&gt;
&lt;li&gt;슬럼프 혹은 더딘 발전이 고민이라면 추천하고 싶다.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;둘리 &amp;#x26; 도우너 어서오고 짤 생성기 회고  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://baek.dev/post/33/&quot;&gt;https://baek.dev/post/33/&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;하고 싶었던 짤 생성기 프로젝트에 대한 회고 포스팅이다.  &lt;/li&gt;
&lt;li&gt;짭짤한 트래픽 맛을 보게 해준 프로젝트를 어떻게 만들게 되었는지 공유했다.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;자동으로 스터디 모집 글을 모아 알림을 주는 파이썬 크롤러 만들기(with Github Actions)  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://baek.dev/post/17/&quot;&gt;https://baek.dev/post/17/&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;설날에 뚝딱 만들었던 크롤러 프로젝트  &lt;/li&gt;
&lt;li&gt;당시 깃헙액션이 나온 지 얼마 되지 않았을 때 만들어본 것이라 재밌었고 현재까지도 잘 쓰고 있다.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;객체지향을 한 단어로 설명한다면 그것은 클래스가 아니라 메시지이다  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://baek.dev/post/22/&quot;&gt;https://baek.dev/post/22/&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;유명한 토끼 책에서 핵심이라고 생각된 부분을 짧게 포스팅했다.  &lt;/li&gt;
&lt;li&gt;물론 책이 워낙 좋아서 무엇 하나 포기할 수 없지만, 하나를 꼽자면 객체지향의 사실과 오해 5장 &amp;#x3C;책임과 메시지&gt;다.   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Apache Kafka - 높은 처리량과 실시간으로 대량의 데이터를 취급하는 카프카  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://baek.dev/post/20/&quot;&gt;https://baek.dev/post/20/&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;대용량 스트림엔 카프카만 한 것이 있을까 싶다.  &lt;/li&gt;
&lt;li&gt;카프카 셋팅으로 고생하고 작성해서 꼭 필요한 부분 위주로 요약했다. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;찾기 힘든 버그를 유발하는 Java DTO 컨버팅 노가다, 리팩토링하기  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://baek.dev/post/15/&quot;&gt;https://baek.dev/post/15/&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;현재는 ModelMapper는 Deprecated하고 MapStruct를 사용하고 있다.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이어 10월에는 블로그를 Jekyll에서 &lt;strong&gt;Gatsby로&lt;/strong&gt; 전환했다. 정적 사이트 블로그이지만 포스팅에 좀 더 다이나믹한 효과를 주고 싶어서 결정하게 된 Gatsby. 포팅 할 때 가장 중요하게 생각했던 건 기존 블로그와의 url 호환이었다. React와 Node가 익숙치 않아 고생을 좀 했지만, 그래도 성공!. Gatsby 포팅 관련 포스팅도 조만간 준비해야겠다.  &lt;/p&gt;
&lt;h2&gt;내년에는요&lt;/h2&gt;
&lt;p&gt;재정비 끝에 내린 큰 결심을 진행하는 해이다. 이 부분이 가장 큰 메인 스트림이라 여기에 집중해야 한다. 코로나 때문에 활동에 많은 제약이 따르지만 내년엔 더 다양한 활동을 할 수 있으리라 기대해본다.   &lt;/p&gt;
&lt;p&gt;그리고 책 읽기가 절대적으로 너무 부족하다. 좀 더 의식적으로 책을 읽으려고 하는데 잘 안된다. 그러다 우연히 본 회고 포스팅 중 읽은 책들을 짦게 독후감을 쓰는 것을 보고 그렇게라도 꾸준히 해봐야겠다 다짐했다. 52주 동안 1권씩 읽기를 많이들 하지만 힘든 것이 자명하니 최소 한 달에 한 권은 비 개발 서적 읽기를 목표로 삼았다.   &lt;/p&gt;
&lt;p&gt;끝으로 건강관리다. 하고 싶은 일을 하기 위해서는 체력이 따라줘야 한다. 활동량이 적다 보니 살이 찐 느낌인데, 몸무게는 거의 비슷하다. 근육이 빠지고 지방이 더 찐 것이다. 태생이 근육이 많은 편인데, 근육이 빠지니 충격을 받았다! 이 와중에 팀원분이 링피트를 샀다고하고, 얼마 전 재밌게 본 발표에서도 자동화를 통해 링피트를 꾸준히 한다고 하는 경험담을 보고 이 참에 나도 링피트를 들였다. 꾸준히 해서 소중한 근육 지켜야지!  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;내년에도 집콕하겠지만 잘 견뎌내 코로나를 피하고, 백신 맞으러 가야겠다 :)&lt;/p&gt;
&lt;p&gt;이미지 출처 : &lt;a href=&quot;https://blog.naver.com/minumworld/222180449907&quot;&gt;민음사 인생일력&lt;/a&gt;&lt;br&gt;
&lt;/p&gt;</content:encoded></item><item><title><![CDATA[둘리 & 도우너 어서오고 짤 생성기 회고]]></title><description><![CDATA[<p>그간 해보고 싶었던 사이드 프로젝트 중 <code>짤(Meme) 생성기</code>를 만들었다. 짤 생성기는 적은 시간 투자 대비 만족도와 활용도가 높은 편이라 꼭 해보고 싶었던 사이드 프로젝트 중 하나다.  </p>
<p>웹툰 중 '도우너 어서오고' 컷이 많은 베리에이션으로 화제가 되고 있는 와중에,
어떤 온라인 커뮤니티에서 한 유저가 문구 수정을 아이폰 단축키를 이용하여 번거롭게 그리고 예쁘지 않게 만드는 것을 보고 주제를 정하게 되었다.  </p>
<br/>
<br/>
<div style="width: 100%; text-align: center;">
<img src="https://baek.dev/assets/images/post/2020/2020_033_001.png" width="400px" alt="둘리 & 도우너 어서오고 짤 생성기"/>
</div>   
<br/>
<br/>
<p>결과 부터 공유하면 <a href="https://baek.dev/doolys-welcome">https://baek.dev/doolys-welcome</a>를 통해 운영 중이다!
현재는 총 4종류이고, 템플릿화했기 때문에 데이터 프리셋에 값만 추가 해주면 반복적인 코드 작업없이 생성 되도록 만들었다.
모든 코드는 <a href="https://github.com/baekdev/doolys-welcome">github@baek.dev/doolys-welcome</a>에 공개되어 있다.   </p>
<p>그럼 이 과정에서 어떤 고민이 있었고 어떻게 해결했는지 회고를 통해 공유하려고 한다 :)  </p>
<div style="width: 100%; text-align: center; ">  
<img src="https://baek.dev/assets/images/post/2020/2020_033_010.png" /><br/>
<p>( 동접수 실화? +_+ )</p>  
</div>  
<h2>시작은 미미하지만, 일단 시작해보자!</h2>
<p>프론트 초보인 나는(!) 소위 프론트엔드 프레임워크나 라이브러리를 써서 만들기에는 아는 것보다 모르는게 더 많아서 그 자체가 <strong>프로젝트 병목</strong>이 될 것이 자명했다.
그래서 조금 할 줄 아는 Vanilla.js로 일단 만들어보는 것이 1차 목표였다.  </p>
<ul>
<li>짤은 캔버스를 이용하는 것 같아 캔버스 사용법을 찾아보고</li>
<li>input에서 타이핑하는 메시지가 캔버스에 바로바로 그려지는지 먼저 확인했다.  </li>
<li>이때 화자가 2명이므로 input을 2개로 설정했다.  </li>
<li>이어서 캔버스를 이미지 다운로드 하도록 기능을 추가했다.  </li>
</ul>
<p>이렇게 가장 메인이 되는 첫번째 어서오고 짤 생성기를 만들었다.   </p>
<p>이후 React를 공부하면서 바로 적용해볼 수 있는 것들은 점차 적용하기 시작했다. 그래서 현재는 CRA를 이용해 React로 포팅했고, 운영에도 반영했다.
만약 내가 처음부터 React를 이용해서 만들려고 했다면, 분명 React를 잘 알지 못해 작동하지 않는 부분에서 나는 수없이 좌절했을 것이고 작동하는 early work<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>를 만들지 못하고 끝냈을 수도 있을 것이다.  </p>
<br>
<br>
<div style="width: 100%; text-align: center; ">  
  <img src="https://baek.dev/assets/images/post/2020/2020_033_006.gif">
</div>  
<br>
<br>
<h2>주요 개발 포인트</h2>
<h3>다양한 화자들을 고려한 데이터셋 정의하기</h3>
<p>애기 공룡 만화 컷에는 둘리와 도우너가 같이 나오는 2명의 화자가 있는 컷, 혹은 혼자 나오는 1인 화자 컷이 있다.
화자가 몇명인지, 각각의 화자는 어떤 기본 데이터를 갖게 하고 싶은지 JSON으로 정의한다.
이렇게 하는 이유는 컴포넌트를 재사용 가능하도록 분리하고, 가변적일 수 있는 데이터는 로직에서 분리하도록 하기 위함이다.   </p>
<p>아래 코드를 보면 4개의 짤 유형별로 Actors.js에서 오브젝트를 불러오고 BuildMeme에 데이터를 던지기만 하면 자동 반복 생성된다.  </p>
<pre><code class="language-javascript">import {Welcome, Hoi, Smoke, Over} from '../data/Actors.js';
import BuildMeme from './BuildMeme';

const DoolysWelcome = () => {

  const actors = [Welcome, Hoi, Smoke, Over];

  return (
    &#x3C;div>
      {actors.map((actor, index) => {
        return &#x3C;BuildMeme key={`actor-${index}`} actorConst={actor} />;
      })}
    &#x3C;/div>
  );
};
</code></pre>
<p>그럼 첫번째 Welcome 데이터가 '도우너 어서오고'의 프리셋인데, 이것으로 프리셋 구조를 소개해보려 한다.      </p>
<pre><code class="language-javascript">// Actors.js  

const Welcome = {
    title: "어서오고",      // 짤 제목
    source: {
        imageSrc: "bg_1.png", // 배경 이미지 파일
        imageWidth: 519,      // 배경 이미지 가로 크기 
        imageHeight: 606,     // 배경 이미지 세로 크기 

        twoLineTextId: "inputWelcomeStranger", // input name
        threeLineTextId: "inputWelcomeDooly",  // input name

        filename: "doolys-welcome", // 이미지 저장 파일 명
    },
    presets: {
        twoLineConst: { // 최대 2줄을 갖는 화자의 프리셋
            placeholder: "어이 둘리.", // input placeholder
            maxMessageLength: 12, // input에 입력 가능한 max length
            lineLimitLength: { // 2줄 중 각 라인별 최대 글자 수
                first: 7,
                second: 5,
            },
            positions: { // 라인 별 x, y 좌표 값 
                init: {
                    x: 100,
                    y: 70,
                },
                firstRow: {
                    x: 70,
                    y: 55,
                },
                secondRow: {
                    x: 70,
                    y: 90,
                },
            },
            countForMove: 4, // 이 글자수 이상 입력되면 왼쪽으로 메시지 이동을 시작 
            lineHeight: 20,
        },
        threeLineConst: { // 최대 3줄을 갖는 화자의 프리셋
            // twoLineConst의 하위 프리셋과 구조가 동일하여 생략  
        },
    },
}
</code></pre>
<p>위 Welcome은 도우너 어서오고에 주입할 데이터이며, 이어서 초능력 맛 좀 볼래, 선넘네 등도 동일한 구조로 값을 각각에 맞게 추가 정의하면 된다.  </p>
<h3>글자수에 따른 x, y 좌표 포지션 계산하기</h3>
<p>유저가 화자의 메시지를 입력할 때마다 바로바로 캔버스에 동적으로 그려주면 좀 더 만드는 재미가 생길 것 같아 프로젝트 처음부터 생각했던 부분이다.
단순히 20자 정도 되는 메시지를 말풍선에 한줄로 표현하진 않아야 한다. <code>만화를 보면 개행이 이뤄지기 때문에 그것을 반영하기로 했다.</code> 그러기 위해선 글자가 입력될 때마다 <strong>동적 좌표</strong>가 필요했다.  </p>
<p>앞서 소개한 위 Actors.js에서 <strong>presets > positions</strong> 이 말풍선 안에 메시지를 위치시키기 위한 좌표이다. 각 이미지마다 말풍선의 위치는 다르므로 각각의 화자가 다른 좌표를 갖는 것이다.  </p>
<br/>
<br/>
<p><img src="https://baek.dev/assets/images/post/2020/2020_033_007.gif" alt="좌표가 변하는 예시">  </p>
<br/>
<br/>
<p>첫줄 안에서도 일정 개수 만큼 메시지가 입력되면 말풍선이 왼쪽으로 움직이도록 좌표를 업데이트 한다. 이후 2번째 줄에서도 계속 메시지는 움직이게 된다.
위 presets > positions 에서 정의된 좌표들은 메시지가 <strong>왼쪽으로 이동하는 한계</strong>를 뜻하기도 한다.  </p>
<p>입력받은 메시지는 각 라인별 최대 길이 맞게 slice하고 좌표를 계산하는 정제를 수행한다.
slice한 메시지와 그 메시지에 맞는 좌표는 오브젝트에 각각 프로퍼티 text와 x,y를 갖는 pos로 구성하여 배열로 리턴한다.  </p>
<pre><code class="language-javascript">[
  { text: '메시지1', 
    pos: {
      x: 100, y: 100
  }}
]
</code></pre>
<p>로직은 일정 값 이상이 되면 왼쪽으로 이동하도록 좌표를 계산하는 포인트와 말풍선의 각 라인에 맞게 메시지를 자르는 것이다.  </p>
<pre><code class="language-javascript">  // ThreeLineText.js 중 일부   
    
  // 첫번째 라인의 최대 개수로 메시지 처음을 자르고 
  const messageHead = inputText.slice(0, lineLimitLength.second);
  // 나머지 메시지는 두번째 라인에 넣을 것  
  const messageTail = inputText.slice(lineLimitLength.second);   

  // countForMove는 메시지가 이 숫자 이상 입력되기 시작하면 왼쪽으로 이동하도록 셋팅한 값이다.  
  // 왼쪽으로 이동한다는 것은 x좌표가 점점 줄어드는 것을 의미하므로 늘어나는 개수만큼 x 좌표를 줄여준다. 
  const secondPosX = positions.init.x - lineHeight * (messageTail.length - countForMove &#x3C; 0 ? 0 : messageTail.length - countForMove);
  const positionMessageTail = {
    // 하지만 말풍선을 넘도록 좌표를 줄일 순 없으므로 셋팅된 x좌표 한계에 다다르면 더 이상 줄이지 않는다.  
    x: secondPosX &#x3C; positions.thirdRow.x ? positions.thirdRow.x : secondPosX,
    y: positions.secondRow.y + 20,
  };

  // split된 메시지를 배열에 담아 리턴한다.
  let result = [];   
  result.push({
    text: messageHead,
    pos: { x: positions.secondRow.x, y: positions.secondRow.y - lineHeight },
  });
  result.push({ text: messageTail, pos: positionMessageTail });
  return result;
</code></pre>
<h3>유저 입력 메시지를 실시간으로 캔버스에 업데이트 하기</h3>
<p>이제 말풍선 메시지는 적절히 나누면서 좌표까지 가졌으니 캔버스에 그리기만 하면 된다.
input에 keyup 이벤트를 추가해주고 input의 value를 setState로 업데이트 해준 뒤 캔버스에 이 메시지로 텍스트 좌표를 지정하면 끝!    </p>
<p>처음에는 input 컴포넌트는 메인 컴포넌트에 함께 있었지만 점차 리팩토링하면서 분리를 했다.
이로인해 리액트에서 자식 컴포넌트가 부모 컴포넌트로 데이터를 전달하도록 부모 함수를 props로 전달받아 호출하도록 구성했다.
부모로 부터 전달 받은 함수 onKeyUp에 필요한 데이터를 담아 호출하면 onKeyUp의 구현부인 부모는 필요한 데이터를 setState하고 캔버스는 이 데이터를 갖고 rerendering 된다.  </p>
<pre><code class="language-javascript">  // ActorsMessage.js 중 일부  
  
  const inputRef = useRef();
  useEffect( () => {
    inputRef.current.addEventListener('keyup', handleChange);
    return () => {
      inputRef.current.removeEventListener('keyup', handleChange);
    };
  });

  const handleChange = (e) => {
    // onKeyUp은 부모의 함수
    props.onKeyUp({'name': e.target.name, 'value': e.target.value});
  };

  return (

    &#x3C;div>
      &#x3C;input
        type="text"
        name={inputName}
        ref={inputRef}
        placeholder={placeholder}
        onKeyUp={handleChange}
        maxLength={maxLength}
      />

    &#x3C;/div>

  );
</code></pre>
<pre><code class="language-javascript">  // DrawingCanvas.js 
 
  const canvasRef = useRef();  
  const initCanvas = () => {
    const canvas = canvasRef.current;  
    const items = props.items; // 좌표를 갖는 split된 메시지 배열
    // 중략   

    const bgImage = new Image();
    bgImage.src = selectBackgroundImg(source.imageSrc);
    bgImage.onload = function () {
      // 이미지가 준비되면 캔버스에 업데이트 한다.
      drawPreviewImage(canvas, bgImage, items);  
    };
  };

  const drawPreviewImage = (canvas, bgImage, items) => {
    // 중략 
    items.forEach((v) => {   
      drawTextWithPostion(ctx, v.text, v.pos);
    });
  };

  const drawTextWithPostion = (ctx, text, position) => {
    // 중략
    ctx.fillText(text, position.x, position.y);
  };

  return (
      &#x3C;div>
        &#x3C;canvas ref={canvasRef} 
                width={source.imageWidth} height={source.imageHeight} />
      &#x3C;/div>
  );
</code></pre>
<h3>컴포넌트 분리하기</h3>
<p>초기에는 거의 단일 파일에 코드를 작성해서 일단 돌아가는(?)것이 목표였다. 기능 구현이 다 되고 난 이후는 컴포넌트 분리가 필요했다.
기능과 역할 별로 적절히 구성을 나눴고, 이에 코드도 변경이 필요했다. 예로 앞서 소개한 input과 canvas 분리가 가장 큰 분리였던 것 같다.   </p>
<pre><code class="language-text">src
 ㄴ components
    ㄴ download
       ㄴ DownloadImage.js
    ㄴ draw
       ㄴ ActorMessage.js
       ㄴ DrawingCanvas.js
    ㄴ layout
       ㄴ Footer.js
       ㄴ Header.js
       ㄴ Menu.js
    ㄴ util
       ㄴ ThreeLineText.js
       ㄴ TwoLineText.js
    ㄴ BuildMeme.js
    ㄴ DoolysWelcome.js
 ㄴ data
    ㄴ Actors.js
 ㄴ images
    ㄴ bg_1.png
 ㄴ style
    ㄴ style.scss
App.js
</code></pre>
<h2>처음부터 자동차를 만들지 마세요</h2>
<p>나는 최소한 속도를 낼 수 있는 작은 바뀌 두개와 두개 발을 올릴 수 있는 나무 판 한개로 구성된 작은 보드 한개를 만들었다.
직접 바퀴를 깎았고, 직접 나무 판을 구해서 손수 조립했다.  </p>
<p>이후 리액트를 공부하면서 공부한 내용을 바로바로 적용하면서 리액트 앱으로 포팅했다.<br>
처음엔 리액트로 기능 그 자체를 만드는 것에 의미를 두었고, 이후에 모듈 분리를 하면서 필요한 코드 리팩토링을 점진적으로 적용했다.  </p>
<p>물론 리액트 고수 분들이 보면 내 둘리짤 생성기는 한 없이 작고 귀여운 스파게티일지도 모른다.<br>
하지만 이것은 베이비 스텝일 뿐이다.  </p>
<p>이 짤 생성기를 고도화해서 좀 더 자동화하고 싶은 욕심이 있다.<br>
그것은 좀 더 리액트를 익혀본 이후에 도전해봐야겠다 :)  </p>
<ul>
<li><a href="https://baek.dev/doolys-welcome">https://baek.dev/doolys-welcome</a>    </li>
<li><a href="https://github.com/baekdev/doolys-welcome">github@baek.dev/doolys-welcome</a>     </li>
</ul>
<div class="footnotes">
<hr>
<ol>
<li id="fn-1">
<p><a href="http://paulgraham.com/early.html">http://paulgraham.com/early.html</a>  </p>
<a href="#fnref-1" class="footnote-backref">↩</a>
</li>
</ol>
</div>]]></description><link>https://baek.dev/post/33/</link><guid isPermaLink="false">https://baek.dev/post/33/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 29 Nov 2020 13:30:00 GMT</pubDate><content:encoded>&lt;p&gt;그간 해보고 싶었던 사이드 프로젝트 중 &lt;code&gt;짤(Meme) 생성기&lt;/code&gt;를 만들었다. 짤 생성기는 적은 시간 투자 대비 만족도와 활용도가 높은 편이라 꼭 해보고 싶었던 사이드 프로젝트 중 하나다.  &lt;/p&gt;
&lt;p&gt;웹툰 중 &apos;도우너 어서오고&apos; 컷이 많은 베리에이션으로 화제가 되고 있는 와중에,
어떤 온라인 커뮤니티에서 한 유저가 문구 수정을 아이폰 단축키를 이용하여 번거롭게 그리고 예쁘지 않게 만드는 것을 보고 주제를 정하게 되었다.  &lt;/p&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;div style=&quot;width: 100%; text-align: center;&quot;&gt;
&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_033_001.png&quot; width=&quot;400px&quot; alt=&quot;둘리 &amp; 도우너 어서오고 짤 생성기&quot;/&gt;
&lt;/div&gt;   
&lt;br/&gt;
&lt;br/&gt;
&lt;p&gt;결과 부터 공유하면 &lt;a href=&quot;https://baek.dev/doolys-welcome&quot;&gt;https://baek.dev/doolys-welcome&lt;/a&gt;를 통해 운영 중이다!
현재는 총 4종류이고, 템플릿화했기 때문에 데이터 프리셋에 값만 추가 해주면 반복적인 코드 작업없이 생성 되도록 만들었다.
모든 코드는 &lt;a href=&quot;https://github.com/baekdev/doolys-welcome&quot;&gt;github@baek.dev/doolys-welcome&lt;/a&gt;에 공개되어 있다.   &lt;/p&gt;
&lt;p&gt;그럼 이 과정에서 어떤 고민이 있었고 어떻게 해결했는지 회고를 통해 공유하려고 한다 :)  &lt;/p&gt;
&lt;div style=&quot;width: 100%; text-align: center; &quot;&gt;  
&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_033_010.png&quot; /&gt;&lt;br/&gt;
&lt;p&gt;( 동접수 실화? +_+ )&lt;/p&gt;  
&lt;/div&gt;  
&lt;h2&gt;시작은 미미하지만, 일단 시작해보자!&lt;/h2&gt;
&lt;p&gt;프론트 초보인 나는(!) 소위 프론트엔드 프레임워크나 라이브러리를 써서 만들기에는 아는 것보다 모르는게 더 많아서 그 자체가 &lt;strong&gt;프로젝트 병목&lt;/strong&gt;이 될 것이 자명했다.
그래서 조금 할 줄 아는 Vanilla.js로 일단 만들어보는 것이 1차 목표였다.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;짤은 캔버스를 이용하는 것 같아 캔버스 사용법을 찾아보고&lt;/li&gt;
&lt;li&gt;input에서 타이핑하는 메시지가 캔버스에 바로바로 그려지는지 먼저 확인했다.  &lt;/li&gt;
&lt;li&gt;이때 화자가 2명이므로 input을 2개로 설정했다.  &lt;/li&gt;
&lt;li&gt;이어서 캔버스를 이미지 다운로드 하도록 기능을 추가했다.  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이렇게 가장 메인이 되는 첫번째 어서오고 짤 생성기를 만들었다.   &lt;/p&gt;
&lt;p&gt;이후 React를 공부하면서 바로 적용해볼 수 있는 것들은 점차 적용하기 시작했다. 그래서 현재는 CRA를 이용해 React로 포팅했고, 운영에도 반영했다.
만약 내가 처음부터 React를 이용해서 만들려고 했다면, 분명 React를 잘 알지 못해 작동하지 않는 부분에서 나는 수없이 좌절했을 것이고 작동하는 early work&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;를 만들지 못하고 끝냈을 수도 있을 것이다.  &lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;div style=&quot;width: 100%; text-align: center; &quot;&gt;  
  &lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_033_006.gif&quot;&gt;
&lt;/div&gt;  
&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;주요 개발 포인트&lt;/h2&gt;
&lt;h3&gt;다양한 화자들을 고려한 데이터셋 정의하기&lt;/h3&gt;
&lt;p&gt;애기 공룡 만화 컷에는 둘리와 도우너가 같이 나오는 2명의 화자가 있는 컷, 혹은 혼자 나오는 1인 화자 컷이 있다.
화자가 몇명인지, 각각의 화자는 어떤 기본 데이터를 갖게 하고 싶은지 JSON으로 정의한다.
이렇게 하는 이유는 컴포넌트를 재사용 가능하도록 분리하고, 가변적일 수 있는 데이터는 로직에서 분리하도록 하기 위함이다.   &lt;/p&gt;
&lt;p&gt;아래 코드를 보면 4개의 짤 유형별로 Actors.js에서 오브젝트를 불러오고 BuildMeme에 데이터를 던지기만 하면 자동 반복 생성된다.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import {Welcome, Hoi, Smoke, Over} from &apos;../data/Actors.js&apos;;
import BuildMeme from &apos;./BuildMeme&apos;;

const DoolysWelcome = () =&gt; {

  const actors = [Welcome, Hoi, Smoke, Over];

  return (
    &amp;#x3C;div&gt;
      {actors.map((actor, index) =&gt; {
        return &amp;#x3C;BuildMeme key={`actor-${index}`} actorConst={actor} /&gt;;
      })}
    &amp;#x3C;/div&gt;
  );
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그럼 첫번째 Welcome 데이터가 &apos;도우너 어서오고&apos;의 프리셋인데, 이것으로 프리셋 구조를 소개해보려 한다.      &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Actors.js  

const Welcome = {
    title: &quot;어서오고&quot;,      // 짤 제목
    source: {
        imageSrc: &quot;bg_1.png&quot;, // 배경 이미지 파일
        imageWidth: 519,      // 배경 이미지 가로 크기 
        imageHeight: 606,     // 배경 이미지 세로 크기 

        twoLineTextId: &quot;inputWelcomeStranger&quot;, // input name
        threeLineTextId: &quot;inputWelcomeDooly&quot;,  // input name

        filename: &quot;doolys-welcome&quot;, // 이미지 저장 파일 명
    },
    presets: {
        twoLineConst: { // 최대 2줄을 갖는 화자의 프리셋
            placeholder: &quot;어이 둘리.&quot;, // input placeholder
            maxMessageLength: 12, // input에 입력 가능한 max length
            lineLimitLength: { // 2줄 중 각 라인별 최대 글자 수
                first: 7,
                second: 5,
            },
            positions: { // 라인 별 x, y 좌표 값 
                init: {
                    x: 100,
                    y: 70,
                },
                firstRow: {
                    x: 70,
                    y: 55,
                },
                secondRow: {
                    x: 70,
                    y: 90,
                },
            },
            countForMove: 4, // 이 글자수 이상 입력되면 왼쪽으로 메시지 이동을 시작 
            lineHeight: 20,
        },
        threeLineConst: { // 최대 3줄을 갖는 화자의 프리셋
            // twoLineConst의 하위 프리셋과 구조가 동일하여 생략  
        },
    },
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 Welcome은 도우너 어서오고에 주입할 데이터이며, 이어서 초능력 맛 좀 볼래, 선넘네 등도 동일한 구조로 값을 각각에 맞게 추가 정의하면 된다.  &lt;/p&gt;
&lt;h3&gt;글자수에 따른 x, y 좌표 포지션 계산하기&lt;/h3&gt;
&lt;p&gt;유저가 화자의 메시지를 입력할 때마다 바로바로 캔버스에 동적으로 그려주면 좀 더 만드는 재미가 생길 것 같아 프로젝트 처음부터 생각했던 부분이다.
단순히 20자 정도 되는 메시지를 말풍선에 한줄로 표현하진 않아야 한다. &lt;code&gt;만화를 보면 개행이 이뤄지기 때문에 그것을 반영하기로 했다.&lt;/code&gt; 그러기 위해선 글자가 입력될 때마다 &lt;strong&gt;동적 좌표&lt;/strong&gt;가 필요했다.  &lt;/p&gt;
&lt;p&gt;앞서 소개한 위 Actors.js에서 &lt;strong&gt;presets &gt; positions&lt;/strong&gt; 이 말풍선 안에 메시지를 위치시키기 위한 좌표이다. 각 이미지마다 말풍선의 위치는 다르므로 각각의 화자가 다른 좌표를 갖는 것이다.  &lt;/p&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_033_007.gif&quot; alt=&quot;좌표가 변하는 예시&quot;&gt;  &lt;/p&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;p&gt;첫줄 안에서도 일정 개수 만큼 메시지가 입력되면 말풍선이 왼쪽으로 움직이도록 좌표를 업데이트 한다. 이후 2번째 줄에서도 계속 메시지는 움직이게 된다.
위 presets &gt; positions 에서 정의된 좌표들은 메시지가 &lt;strong&gt;왼쪽으로 이동하는 한계&lt;/strong&gt;를 뜻하기도 한다.  &lt;/p&gt;
&lt;p&gt;입력받은 메시지는 각 라인별 최대 길이 맞게 slice하고 좌표를 계산하는 정제를 수행한다.
slice한 메시지와 그 메시지에 맞는 좌표는 오브젝트에 각각 프로퍼티 text와 x,y를 갖는 pos로 구성하여 배열로 리턴한다.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;[
  { text: &apos;메시지1&apos;, 
    pos: {
      x: 100, y: 100
  }}
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;로직은 일정 값 이상이 되면 왼쪽으로 이동하도록 좌표를 계산하는 포인트와 말풍선의 각 라인에 맞게 메시지를 자르는 것이다.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  // ThreeLineText.js 중 일부   
    
  // 첫번째 라인의 최대 개수로 메시지 처음을 자르고 
  const messageHead = inputText.slice(0, lineLimitLength.second);
  // 나머지 메시지는 두번째 라인에 넣을 것  
  const messageTail = inputText.slice(lineLimitLength.second);   

  // countForMove는 메시지가 이 숫자 이상 입력되기 시작하면 왼쪽으로 이동하도록 셋팅한 값이다.  
  // 왼쪽으로 이동한다는 것은 x좌표가 점점 줄어드는 것을 의미하므로 늘어나는 개수만큼 x 좌표를 줄여준다. 
  const secondPosX = positions.init.x - lineHeight * (messageTail.length - countForMove &amp;#x3C; 0 ? 0 : messageTail.length - countForMove);
  const positionMessageTail = {
    // 하지만 말풍선을 넘도록 좌표를 줄일 순 없으므로 셋팅된 x좌표 한계에 다다르면 더 이상 줄이지 않는다.  
    x: secondPosX &amp;#x3C; positions.thirdRow.x ? positions.thirdRow.x : secondPosX,
    y: positions.secondRow.y + 20,
  };

  // split된 메시지를 배열에 담아 리턴한다.
  let result = [];   
  result.push({
    text: messageHead,
    pos: { x: positions.secondRow.x, y: positions.secondRow.y - lineHeight },
  });
  result.push({ text: messageTail, pos: positionMessageTail });
  return result;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;유저 입력 메시지를 실시간으로 캔버스에 업데이트 하기&lt;/h3&gt;
&lt;p&gt;이제 말풍선 메시지는 적절히 나누면서 좌표까지 가졌으니 캔버스에 그리기만 하면 된다.
input에 keyup 이벤트를 추가해주고 input의 value를 setState로 업데이트 해준 뒤 캔버스에 이 메시지로 텍스트 좌표를 지정하면 끝!    &lt;/p&gt;
&lt;p&gt;처음에는 input 컴포넌트는 메인 컴포넌트에 함께 있었지만 점차 리팩토링하면서 분리를 했다.
이로인해 리액트에서 자식 컴포넌트가 부모 컴포넌트로 데이터를 전달하도록 부모 함수를 props로 전달받아 호출하도록 구성했다.
부모로 부터 전달 받은 함수 onKeyUp에 필요한 데이터를 담아 호출하면 onKeyUp의 구현부인 부모는 필요한 데이터를 setState하고 캔버스는 이 데이터를 갖고 rerendering 된다.  &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  // ActorsMessage.js 중 일부  
  
  const inputRef = useRef();
  useEffect( () =&gt; {
    inputRef.current.addEventListener(&apos;keyup&apos;, handleChange);
    return () =&gt; {
      inputRef.current.removeEventListener(&apos;keyup&apos;, handleChange);
    };
  });

  const handleChange = (e) =&gt; {
    // onKeyUp은 부모의 함수
    props.onKeyUp({&apos;name&apos;: e.target.name, &apos;value&apos;: e.target.value});
  };

  return (

    &amp;#x3C;div&gt;
      &amp;#x3C;input
        type=&quot;text&quot;
        name={inputName}
        ref={inputRef}
        placeholder={placeholder}
        onKeyUp={handleChange}
        maxLength={maxLength}
      /&gt;

    &amp;#x3C;/div&gt;

  );
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;  // DrawingCanvas.js 
 
  const canvasRef = useRef();  
  const initCanvas = () =&gt; {
    const canvas = canvasRef.current;  
    const items = props.items; // 좌표를 갖는 split된 메시지 배열
    // 중략   

    const bgImage = new Image();
    bgImage.src = selectBackgroundImg(source.imageSrc);
    bgImage.onload = function () {
      // 이미지가 준비되면 캔버스에 업데이트 한다.
      drawPreviewImage(canvas, bgImage, items);  
    };
  };

  const drawPreviewImage = (canvas, bgImage, items) =&gt; {
    // 중략 
    items.forEach((v) =&gt; {   
      drawTextWithPostion(ctx, v.text, v.pos);
    });
  };

  const drawTextWithPostion = (ctx, text, position) =&gt; {
    // 중략
    ctx.fillText(text, position.x, position.y);
  };

  return (
      &amp;#x3C;div&gt;
        &amp;#x3C;canvas ref={canvasRef} 
                width={source.imageWidth} height={source.imageHeight} /&gt;
      &amp;#x3C;/div&gt;
  );
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;컴포넌트 분리하기&lt;/h3&gt;
&lt;p&gt;초기에는 거의 단일 파일에 코드를 작성해서 일단 돌아가는(?)것이 목표였다. 기능 구현이 다 되고 난 이후는 컴포넌트 분리가 필요했다.
기능과 역할 별로 적절히 구성을 나눴고, 이에 코드도 변경이 필요했다. 예로 앞서 소개한 input과 canvas 분리가 가장 큰 분리였던 것 같다.   &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;src
 ㄴ components
    ㄴ download
       ㄴ DownloadImage.js
    ㄴ draw
       ㄴ ActorMessage.js
       ㄴ DrawingCanvas.js
    ㄴ layout
       ㄴ Footer.js
       ㄴ Header.js
       ㄴ Menu.js
    ㄴ util
       ㄴ ThreeLineText.js
       ㄴ TwoLineText.js
    ㄴ BuildMeme.js
    ㄴ DoolysWelcome.js
 ㄴ data
    ㄴ Actors.js
 ㄴ images
    ㄴ bg_1.png
 ㄴ style
    ㄴ style.scss
App.js
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;처음부터 자동차를 만들지 마세요&lt;/h2&gt;
&lt;p&gt;나는 최소한 속도를 낼 수 있는 작은 바뀌 두개와 두개 발을 올릴 수 있는 나무 판 한개로 구성된 작은 보드 한개를 만들었다.
직접 바퀴를 깎았고, 직접 나무 판을 구해서 손수 조립했다.  &lt;/p&gt;
&lt;p&gt;이후 리액트를 공부하면서 공부한 내용을 바로바로 적용하면서 리액트 앱으로 포팅했다.&lt;br&gt;
처음엔 리액트로 기능 그 자체를 만드는 것에 의미를 두었고, 이후에 모듈 분리를 하면서 필요한 코드 리팩토링을 점진적으로 적용했다.  &lt;/p&gt;
&lt;p&gt;물론 리액트 고수 분들이 보면 내 둘리짤 생성기는 한 없이 작고 귀여운 스파게티일지도 모른다.&lt;br&gt;
하지만 이것은 베이비 스텝일 뿐이다.  &lt;/p&gt;
&lt;p&gt;이 짤 생성기를 고도화해서 좀 더 자동화하고 싶은 욕심이 있다.&lt;br&gt;
그것은 좀 더 리액트를 익혀본 이후에 도전해봐야겠다 :)  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://baek.dev/doolys-welcome&quot;&gt;https://baek.dev/doolys-welcome&lt;/a&gt;    &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/baekdev/doolys-welcome&quot;&gt;github@baek.dev/doolys-welcome&lt;/a&gt;     &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://paulgraham.com/early.html&quot;&gt;http://paulgraham.com/early.html&lt;/a&gt;  &lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[다시 또 글또를 시작하게 된 2가지 이유]]></title><description><![CDATA[<p>글또에 지난 4기에 이어 5기로 다시 참여한다.<br>
왜 다시 참여하게 되었는지 2가지 이유와 함께 출사표를 던져본다.</p>
<h2>첫번째 이유, 글을 단 1개도 쓰지 않았다.</h2>
<p>지난 9월 초, 글또 4기가 마무리된 이후 단 1개의 글도 쓰지 않았다(!)</p>
<p>글또 4기가 마치면서 이제 글 쓰는 습관이 좀 잡혔을까 싶었으나 <del>바쁘다 바빠 현대사회에서 우선순위가 높지 않은</del> 글쓰기는 어느새 새까맣게 잊혀졌다.
그래서 글쓰기 모임은 예치금 사수라는 미션이 있으니 아무래도 텐션이 생기는 것 같아 다시 시작하게 되었다.</p>
<p>물론 2주마다 글을 쓴다는 건 사실 직장인에게 쉽지 않다.
업무로 야근 한두 번 하면 평일은 후루룩 지나가게 되고 주말에도 공부를 하거나 휴식을 취하게 되면 정말 2주가 금방이다.
6개월 동안 매 2주에 한 번씩 미션을 치야 하는 것은 스트레스도 크고 울며 겨자 먹기로 썼던 적도 몇 번 있었기에 솔직히 그다음엔 참여하지 않으려 했다.</p>
<p>하지만, <code>글은 꾸준히 쓰고 싶고 무엇인가를 남기고 싶은 욕심은 있기에 이것을 이루려면 그 무게를 견뎌야 하는 것이 인지상정 아니겠는가.</code>
그 무게를 함께 견디는 다른 참가자들이 있어 알게 모르게 의지가 되고, 힘이 된다.</p>
<h2>두번째 이유, 같은 직군의 커뮤니티</h2>
<p>글또는 직군 별로 참가자들이 그룹핑되고 그 안에서 글쓰기 미션과 피드백이라는 상호작용이 이뤄진다.<br>
그룹은 머신러닝 엔지니어, 데이터 엔지니어, 데이터 분석, 백엔드 개발, 프론트엔드 개발, 클라이언트 개발 정도로 나뉜다.
이 안에서 직군 내의 관심사가 공유되기도 하고 질문이 오고 가니 건설적이다.</p>
<p>특히 나는 새로운 도전을 앞두고 기존과 다른 포지션으로 지원을 했다.
그래서 <code>아는 것보다 모르는 게 더 많은 나의 부족한 점을 기존 선배들에게 더 빠르게 피드백 받을 수 있는 점도 기대</code>가 된다.</p>
<p>아쉽게도 지난 4기에는 코로나 유행이 시작된 직후에 글또도 시작되어 모임이 거의 없었지만, 이번 5기에는 온오프등 다양한 방법으로 더 많은 대화를 나눌 수 있었으면 좋겠다!</p>
<h2>에헴, 출사표요</h2>
<p>지난 4기때는 공부한 내용을 정리하고 작성하는 유형으로 많이 진행했는데, 개인적으로 요약정리집을 만들기만 한다는 것이 크게 성취감이 들진 않았다.</p>
<p>이번 5기에는 최소 절반 이상은 <code>빠르고 작게 토이 프로젝트를 만들어서 그 후기를 정리하는 형태로 진행</code>해보려 한다. 쉽지 않을 것이고 내겐 엄청난 도전이지만 이 기회를 빌어 많은 성장을 할 수 있을 것이다.</p>
<p>어느 날 SNS에서 본 아래 내용이 인상 깊었다.</p>
<blockquote>
<p>야근으로 늦게까지 일하고 피곤해도<br>
내가 좋아하는 걸 잠깐이라도 해야 그날 하루가 보람차다고 느낀다.</p>
</blockquote>
<p>나는 올해 일밖에 한 게 없었다. 그래서 블랙아웃 된 것 같다고 종종 말한다. 허나 위 글을 본 이후부터는 가능하면 내 것을 단 30분이라도 하고 하루를 마무리하려고 한다.</p>
<p>지금 글또 다짐 글을 쓰기 전까지 1개의 토이 프로젝트를 진행했다. 야근이 있었던 날도 업무를 마치고 프로젝트를 진행했다. 너무 피곤하지만 단 한 줄이라도 내 코딩을 하니 뿌듯하게 마무리할 수 있었다.</p>
<blockquote>
<p><a href="https://baek.dev/doolys-welcome">"도우너 어서오고 짤 만들기"</a></p>
</blockquote>
<p>이 글의 대표 이미지도 이 프로젝트를 통해 간단히 생성했다. 간단하고 사소하지만 그동안 짤 만들기 해보고 싶었던 작은 목표를 이루었다.<br>
다음 글은 <a href="https://baek.dev/doolys-welcome">"도우너 어서오고 짤 만들기"</a> 토이 플젝을 소개하고 프로젝트를 진행하면서 고민한 부분과 향후 더 발전시킬 부분에 대해 이야기해보려고 한다.</p>
<p>그럼 글또 5기 화이팅!</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_029_001.png" alt="도우너 어서오고 짤 생성기"></p>]]></description><link>https://baek.dev/post/29/</link><guid isPermaLink="false">https://baek.dev/post/29/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 15 Nov 2020 11:30:00 GMT</pubDate><content:encoded>&lt;p&gt;글또에 지난 4기에 이어 5기로 다시 참여한다.&lt;br&gt;
왜 다시 참여하게 되었는지 2가지 이유와 함께 출사표를 던져본다.&lt;/p&gt;
&lt;h2&gt;첫번째 이유, 글을 단 1개도 쓰지 않았다.&lt;/h2&gt;
&lt;p&gt;지난 9월 초, 글또 4기가 마무리된 이후 단 1개의 글도 쓰지 않았다(!)&lt;/p&gt;
&lt;p&gt;글또 4기가 마치면서 이제 글 쓰는 습관이 좀 잡혔을까 싶었으나 &lt;del&gt;바쁘다 바빠 현대사회에서 우선순위가 높지 않은&lt;/del&gt; 글쓰기는 어느새 새까맣게 잊혀졌다.
그래서 글쓰기 모임은 예치금 사수라는 미션이 있으니 아무래도 텐션이 생기는 것 같아 다시 시작하게 되었다.&lt;/p&gt;
&lt;p&gt;물론 2주마다 글을 쓴다는 건 사실 직장인에게 쉽지 않다.
업무로 야근 한두 번 하면 평일은 후루룩 지나가게 되고 주말에도 공부를 하거나 휴식을 취하게 되면 정말 2주가 금방이다.
6개월 동안 매 2주에 한 번씩 미션을 치야 하는 것은 스트레스도 크고 울며 겨자 먹기로 썼던 적도 몇 번 있었기에 솔직히 그다음엔 참여하지 않으려 했다.&lt;/p&gt;
&lt;p&gt;하지만, &lt;code&gt;글은 꾸준히 쓰고 싶고 무엇인가를 남기고 싶은 욕심은 있기에 이것을 이루려면 그 무게를 견뎌야 하는 것이 인지상정 아니겠는가.&lt;/code&gt;
그 무게를 함께 견디는 다른 참가자들이 있어 알게 모르게 의지가 되고, 힘이 된다.&lt;/p&gt;
&lt;h2&gt;두번째 이유, 같은 직군의 커뮤니티&lt;/h2&gt;
&lt;p&gt;글또는 직군 별로 참가자들이 그룹핑되고 그 안에서 글쓰기 미션과 피드백이라는 상호작용이 이뤄진다.&lt;br&gt;
그룹은 머신러닝 엔지니어, 데이터 엔지니어, 데이터 분석, 백엔드 개발, 프론트엔드 개발, 클라이언트 개발 정도로 나뉜다.
이 안에서 직군 내의 관심사가 공유되기도 하고 질문이 오고 가니 건설적이다.&lt;/p&gt;
&lt;p&gt;특히 나는 새로운 도전을 앞두고 기존과 다른 포지션으로 지원을 했다.
그래서 &lt;code&gt;아는 것보다 모르는 게 더 많은 나의 부족한 점을 기존 선배들에게 더 빠르게 피드백 받을 수 있는 점도 기대&lt;/code&gt;가 된다.&lt;/p&gt;
&lt;p&gt;아쉽게도 지난 4기에는 코로나 유행이 시작된 직후에 글또도 시작되어 모임이 거의 없었지만, 이번 5기에는 온오프등 다양한 방법으로 더 많은 대화를 나눌 수 있었으면 좋겠다!&lt;/p&gt;
&lt;h2&gt;에헴, 출사표요&lt;/h2&gt;
&lt;p&gt;지난 4기때는 공부한 내용을 정리하고 작성하는 유형으로 많이 진행했는데, 개인적으로 요약정리집을 만들기만 한다는 것이 크게 성취감이 들진 않았다.&lt;/p&gt;
&lt;p&gt;이번 5기에는 최소 절반 이상은 &lt;code&gt;빠르고 작게 토이 프로젝트를 만들어서 그 후기를 정리하는 형태로 진행&lt;/code&gt;해보려 한다. 쉽지 않을 것이고 내겐 엄청난 도전이지만 이 기회를 빌어 많은 성장을 할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;어느 날 SNS에서 본 아래 내용이 인상 깊었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;야근으로 늦게까지 일하고 피곤해도&lt;br&gt;
내가 좋아하는 걸 잠깐이라도 해야 그날 하루가 보람차다고 느낀다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;나는 올해 일밖에 한 게 없었다. 그래서 블랙아웃 된 것 같다고 종종 말한다. 허나 위 글을 본 이후부터는 가능하면 내 것을 단 30분이라도 하고 하루를 마무리하려고 한다.&lt;/p&gt;
&lt;p&gt;지금 글또 다짐 글을 쓰기 전까지 1개의 토이 프로젝트를 진행했다. 야근이 있었던 날도 업무를 마치고 프로젝트를 진행했다. 너무 피곤하지만 단 한 줄이라도 내 코딩을 하니 뿌듯하게 마무리할 수 있었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://baek.dev/doolys-welcome&quot;&gt;&quot;도우너 어서오고 짤 만들기&quot;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 글의 대표 이미지도 이 프로젝트를 통해 간단히 생성했다. 간단하고 사소하지만 그동안 짤 만들기 해보고 싶었던 작은 목표를 이루었다.&lt;br&gt;
다음 글은 &lt;a href=&quot;https://baek.dev/doolys-welcome&quot;&gt;&quot;도우너 어서오고 짤 만들기&quot;&lt;/a&gt; 토이 플젝을 소개하고 프로젝트를 진행하면서 고민한 부분과 향후 더 발전시킬 부분에 대해 이야기해보려고 한다.&lt;/p&gt;
&lt;p&gt;그럼 글또 5기 화이팅!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_029_001.png&quot; alt=&quot;도우너 어서오고 짤 생성기&quot;&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[개발자의 사이드 프로젝트 - 커리어 스킬(2)]]></title><description><![CDATA[<ul>
<li><a href="/post/26/">경력을 발전시키고 싶다면 - 커리어 스킬(1)</a></li>
<li><a href="/post/28/">개발자의 사이드 프로젝트 - 커리어 스킬(2)</a></li>
</ul>
<h2>인생의 변곡점</h2>
<p>사이드 프로젝트를 해보겠다고 한 번도 생각하지 않은 소프트웨어 개발자는 본 적이 없다. 나만해도 사이드 프로젝트를 많이 해왔다. 아, 좀 더 명확히 말하면 사이드 프로젝트를 많이 시작했다. <strong>솔직히 말해서 시작한 프로젝트 중 끝낸 건 별로 없다.</strong><br>
꿈과 목표 사이에는 큰 차이가 있다. 꿈은 쫓는 것이고 목표는 행동해서 실현하는 것이다. 과거에는 나도 꿈을 꾸는 사람이었다. 그때는 아이디어와 꿈을 좇아 다녔다. 항상 사이드 프로젝트를 진행했지만 그렇다고 늘 최선을 다한건 아니었다.</p>
<blockquote>
<p>내 인생과 경력을 돌이켜봤을 때 모든 게 극적으로 변한 한 순간, 변곡점이 하나 존재한다.<br>
그 변곡점은 내가 사이드 프로젝트를 처음으로 마무리한 순간이었다.</p>
</blockquote>
<p>사이드 프로젝트를 하다가 중간에 지루해져서 별 생각없이 진행하고 있던 어느 날, 지루함을 견뎌보기로 하고 이 프로젝트만큼은 마무리하기로 결심했다. 시간이 얼마가 걸리든 상관없이 마무리 될 떄까지 적어도 하루에 한 시간씩 이 사이드 프로젝트를 진행하기로 했다.<br>
<code>그 순간 모든게 바뀌었다. 그날부터 무슨 일이든 마무리했다.</code><br>
사이드 프로젝트 하나를 마무리한 후에 다른 기회와 사이드 프로젝트가 꼬리를 물고 찾아왔다. 그래서 과거의 나로서는 상상하지 못했던 일을 지금은 하고 있다. 책을 쓰고 동영상을 만들고 회사를 세우고 실질적 은퇴를 이뤘다. 그 전에 쌓은 15년 정도의 경력보다 <strong>끝내 마무리 지은 하나의 작은 사이드 프로젝트가 내 경력과 삶에 더 큰 영향을 미쳤다.</strong></p>
<h2>장점</h2>
<blockquote>
<p>사이드 프로젝트는 소프트웨어 개발자가 경력을 발전시킬 좋은 방법이다.</p>
</blockquote>
<ul>
<li>사이드 프로젝트로 대단한 수익을 올린 건 아니지만 그 덕에 내 경력 큰 도움이 되는 다양한 기술을 배움</li>
<li>무엇보다 값진 수확은 내 프로그래밍 능력에 자신감을 갖게 되며, 바로 이게 <strong>사이드 프로젝트의 힘</strong></li>
<li>새로운 기술을 배우고 알던 기술을 연습할 기회를 줌</li>
<li>새로운 영역에 도전해보면서 자신의 능력에 대한 자신감도 키울 수 있음</li>
<li>6개월짜리 사이드 프로젝트 하나가 9시부터 5시까지 근무하는 회사에 몇 년간 다녀야 배울 수 있는 경험을 하게 해줌</li>
</ul>
<h2>목표</h2>
<p>완벽한 아이디어를 떠올리겠다는 일념에 사로잡히면 결국 아무것도 못 하고 끝날 수 있기에 목표가 되려면 구체적인 내용이 있어야 한다.</p>
<ul>
<li>처음에는 아주 쉽게 완료할 수 있다고 생각하는 아주 간단한 사이드 프로젝트로 시작</li>
<li>
<p><code>한두 주 혹은 길어도 한 달 정도면 마칠 수 있는 것을 선택</code></p>
<ul>
<li>사람들은 자기 자신과의 약속을 지키지 않는 데 익숙해서 스스로를 믿지 못함</li>
<li>무리해서 뭔가를 하려고 하다가는 결국 실패하거나 포기</li>
<li>점차 <strong>자신을 믿지 못하기 때문에</strong> 스스로를 계속 내리막길로 가게 두는 패턴이 만들어짐</li>
</ul>
</li>
<li>야망을 덜어내고 아주 작은 사이드 프로젝트를 시작하고 확실히 마무리할 자신이 있는 것으로 고를 것</li>
<li>
<p>처음 진행하는 사이드 프로젝트 주제로 <strong>클론 코딩</strong>을 추천</p>
<ul>
<li>베낀다고 걱정하지 말고 이건 표절과 다름</li>
<li>작고 쉬운 사이드 프로젝트를 완성해서 자신에 대한 신뢰가 굳건해지면 조금 더 욕심을 내도 좋음</li>
<li>적어도 3개월 내에 첫 번째 버전을 출시할 수 있어야 함</li>
</ul>
</li>
</ul>
<h2>두 가지 이상의 효과를 기대</h2>
<p>아주 작은 프로젝트를 하더라도 최대한 많은 목적을 달성할 방법을 생각하라.<br>
사이드 프로젝트를 통해 다음 목적 중 여러 개를 한꺼번에 달성할수도 있다.</p>
<ul>
<li>새로운 프로그래밍 언어 / 프레임워크 배우기</li>
<li>이미 알고 있는 기술을 숙달하기</li>
<li>자신의 문제 / 다른 사람의 문제를 해결할 앱 만들기</li>
<li>추가 수입원 만들기</li>
<li>면접용 포트폴리오로 쓰기</li>
<li>블로그 콘텐츠로 쓰기</li>
<li>사이드 프로젝트를 주제로 동영상 콘텐츠 만들기</li>
<li>프로젝트를 활용해서 다른 사람의 멘토 역학을 하거나 멘토로 부터 조언을 받기</li>
<li>절제력을 키우고 새로운 시간 관리 기법 써보기</li>
<li>새 친구를 만들고 관심있는 분야에 대해 배우기</li>
<li>대학교 과제 마치기 등등</li>
</ul>
<p><img src="https://baek.dev/assets/images/post/2020/2020_028_001.jpg" alt="수 백번의 이상적인 생각보다 한 번의 실행이 변화의 시작이다 - 셰릴 샌드버그"></p>
<h2>기준 수립</h2>
<p>사실 무슨 일이든 시작하기 전에 어떤 일을 할 것이고 최종 목표는 무엇인지 계획을 세워두어야 한다.<br>
필수 요소인 다음 세 가지가 없어서 프로젝트가 미완으로 끝나는 일이 종종 있다.</p>
<ul>
<li>
<p><strong>목표 혹은 '완료'의 기준</strong></p>
<ul>
<li>프로젝트의 성공적인 완료를 가늠할 최소 기능 세트나 기준을 정의하라</li>
</ul>
</li>
<li>
<p><strong>마감</strong></p>
<ul>
<li>공격적으로 하되 과하지 않게 주의</li>
<li>약간의 여유를 두고 지킬 수 있는 마감을 정하되 여유를 너무 많이 잡지 말 것</li>
</ul>
</li>
<li>
<p><strong>체계 혹은 프로젝트 작업 시간 정하기</strong></p>
<ul>
<li>프로젝트를 위해 매일 혹은 매주 얼마의 시간을 쓸 것인지 명확히 정의</li>
<li>정의한 시간이 정확히 언제인가를 정의</li>
<li>작업 진도와 해야 할 일을 추적할 수 있는 절차를 정의</li>
</ul>
</li>
</ul>
<h2>마무리</h2>
<p>사이드 프로젝트를 완료하고 거기에서 이득을 취하기 위해 실제로 당신이 지켜야 할 아주 중요한 사항이 있다. 그건 바로 <code>일관성</code>이다. 즉, 마음이 내킬 때만 해서는 안 된다는 말이다. 마음이 내키지 않을 때가 너무 많기 때문이다. 사이드 프로젝트 작업 일정을 정했으면 어떤 어려움이 있어도 그 일정을 지켜야 한다.</p>
<p>더불어 무슨 일이든 마무리하는 습관을 기르는 게 좋다. 나도 마무리하는 습관을 기른 후에 인생이 바뀌었다. 시작해서 끝을 보지 못한 일이 누구에게나 있다. 어떤 프로젝트든지 아무리 마음에 들지 않아도 시작했으면 마무리하라. 그 프로젝트 때문에 죽을 것만 같아도 지켜라.</p>
<p><code>99퍼센트 완성했어도 출시하지 못했다면 가치는 0퍼센트다.</code></p>
<p>완벽한 해결책을 찾지 못했다는 이유로, 막혔다고 손을 놓아버리는 것보다는 어떻게든 강행행서 진전을 보는 게 거의 언제나 더 낫다.<br>
그럼 이제 당장 시작하라. 작게 시작하고 일정을 지켜서 마무리하기만 하면 아무 문제가 없을 것이다.</p>
<blockquote>
<p>꿈은 좇는 것이고 목표는 행동해서 실현하는 것이다.</p>
</blockquote>
<hr>
<p>출처 - <a href="https://coupa.ng/bHkYTv">커리스 스킬 / 존 손메즈 지음</a> 중 사이드 프로젝트에 대해 요약 정리한 내용입니다.</p>]]></description><link>https://baek.dev/post/28/</link><guid isPermaLink="false">https://baek.dev/post/28/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 06 Sep 2020 06:44:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/post/26/&quot;&gt;경력을 발전시키고 싶다면 - 커리어 스킬(1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/28/&quot;&gt;개발자의 사이드 프로젝트 - 커리어 스킬(2)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;인생의 변곡점&lt;/h2&gt;
&lt;p&gt;사이드 프로젝트를 해보겠다고 한 번도 생각하지 않은 소프트웨어 개발자는 본 적이 없다. 나만해도 사이드 프로젝트를 많이 해왔다. 아, 좀 더 명확히 말하면 사이드 프로젝트를 많이 시작했다. &lt;strong&gt;솔직히 말해서 시작한 프로젝트 중 끝낸 건 별로 없다.&lt;/strong&gt;&lt;br&gt;
꿈과 목표 사이에는 큰 차이가 있다. 꿈은 쫓는 것이고 목표는 행동해서 실현하는 것이다. 과거에는 나도 꿈을 꾸는 사람이었다. 그때는 아이디어와 꿈을 좇아 다녔다. 항상 사이드 프로젝트를 진행했지만 그렇다고 늘 최선을 다한건 아니었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;내 인생과 경력을 돌이켜봤을 때 모든 게 극적으로 변한 한 순간, 변곡점이 하나 존재한다.&lt;br&gt;
그 변곡점은 내가 사이드 프로젝트를 처음으로 마무리한 순간이었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;사이드 프로젝트를 하다가 중간에 지루해져서 별 생각없이 진행하고 있던 어느 날, 지루함을 견뎌보기로 하고 이 프로젝트만큼은 마무리하기로 결심했다. 시간이 얼마가 걸리든 상관없이 마무리 될 떄까지 적어도 하루에 한 시간씩 이 사이드 프로젝트를 진행하기로 했다.&lt;br&gt;
&lt;code&gt;그 순간 모든게 바뀌었다. 그날부터 무슨 일이든 마무리했다.&lt;/code&gt;&lt;br&gt;
사이드 프로젝트 하나를 마무리한 후에 다른 기회와 사이드 프로젝트가 꼬리를 물고 찾아왔다. 그래서 과거의 나로서는 상상하지 못했던 일을 지금은 하고 있다. 책을 쓰고 동영상을 만들고 회사를 세우고 실질적 은퇴를 이뤘다. 그 전에 쌓은 15년 정도의 경력보다 &lt;strong&gt;끝내 마무리 지은 하나의 작은 사이드 프로젝트가 내 경력과 삶에 더 큰 영향을 미쳤다.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;장점&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;사이드 프로젝트는 소프트웨어 개발자가 경력을 발전시킬 좋은 방법이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;사이드 프로젝트로 대단한 수익을 올린 건 아니지만 그 덕에 내 경력 큰 도움이 되는 다양한 기술을 배움&lt;/li&gt;
&lt;li&gt;무엇보다 값진 수확은 내 프로그래밍 능력에 자신감을 갖게 되며, 바로 이게 &lt;strong&gt;사이드 프로젝트의 힘&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;새로운 기술을 배우고 알던 기술을 연습할 기회를 줌&lt;/li&gt;
&lt;li&gt;새로운 영역에 도전해보면서 자신의 능력에 대한 자신감도 키울 수 있음&lt;/li&gt;
&lt;li&gt;6개월짜리 사이드 프로젝트 하나가 9시부터 5시까지 근무하는 회사에 몇 년간 다녀야 배울 수 있는 경험을 하게 해줌&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;목표&lt;/h2&gt;
&lt;p&gt;완벽한 아이디어를 떠올리겠다는 일념에 사로잡히면 결국 아무것도 못 하고 끝날 수 있기에 목표가 되려면 구체적인 내용이 있어야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;처음에는 아주 쉽게 완료할 수 있다고 생각하는 아주 간단한 사이드 프로젝트로 시작&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;한두 주 혹은 길어도 한 달 정도면 마칠 수 있는 것을 선택&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사람들은 자기 자신과의 약속을 지키지 않는 데 익숙해서 스스로를 믿지 못함&lt;/li&gt;
&lt;li&gt;무리해서 뭔가를 하려고 하다가는 결국 실패하거나 포기&lt;/li&gt;
&lt;li&gt;점차 &lt;strong&gt;자신을 믿지 못하기 때문에&lt;/strong&gt; 스스로를 계속 내리막길로 가게 두는 패턴이 만들어짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;야망을 덜어내고 아주 작은 사이드 프로젝트를 시작하고 확실히 마무리할 자신이 있는 것으로 고를 것&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;처음 진행하는 사이드 프로젝트 주제로 &lt;strong&gt;클론 코딩&lt;/strong&gt;을 추천&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;베낀다고 걱정하지 말고 이건 표절과 다름&lt;/li&gt;
&lt;li&gt;작고 쉬운 사이드 프로젝트를 완성해서 자신에 대한 신뢰가 굳건해지면 조금 더 욕심을 내도 좋음&lt;/li&gt;
&lt;li&gt;적어도 3개월 내에 첫 번째 버전을 출시할 수 있어야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;두 가지 이상의 효과를 기대&lt;/h2&gt;
&lt;p&gt;아주 작은 프로젝트를 하더라도 최대한 많은 목적을 달성할 방법을 생각하라.&lt;br&gt;
사이드 프로젝트를 통해 다음 목적 중 여러 개를 한꺼번에 달성할수도 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;새로운 프로그래밍 언어 / 프레임워크 배우기&lt;/li&gt;
&lt;li&gt;이미 알고 있는 기술을 숙달하기&lt;/li&gt;
&lt;li&gt;자신의 문제 / 다른 사람의 문제를 해결할 앱 만들기&lt;/li&gt;
&lt;li&gt;추가 수입원 만들기&lt;/li&gt;
&lt;li&gt;면접용 포트폴리오로 쓰기&lt;/li&gt;
&lt;li&gt;블로그 콘텐츠로 쓰기&lt;/li&gt;
&lt;li&gt;사이드 프로젝트를 주제로 동영상 콘텐츠 만들기&lt;/li&gt;
&lt;li&gt;프로젝트를 활용해서 다른 사람의 멘토 역학을 하거나 멘토로 부터 조언을 받기&lt;/li&gt;
&lt;li&gt;절제력을 키우고 새로운 시간 관리 기법 써보기&lt;/li&gt;
&lt;li&gt;새 친구를 만들고 관심있는 분야에 대해 배우기&lt;/li&gt;
&lt;li&gt;대학교 과제 마치기 등등&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_028_001.jpg&quot; alt=&quot;수 백번의 이상적인 생각보다 한 번의 실행이 변화의 시작이다 - 셰릴 샌드버그&quot;&gt;&lt;/p&gt;
&lt;h2&gt;기준 수립&lt;/h2&gt;
&lt;p&gt;사실 무슨 일이든 시작하기 전에 어떤 일을 할 것이고 최종 목표는 무엇인지 계획을 세워두어야 한다.&lt;br&gt;
필수 요소인 다음 세 가지가 없어서 프로젝트가 미완으로 끝나는 일이 종종 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;목표 혹은 &apos;완료&apos;의 기준&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트의 성공적인 완료를 가늠할 최소 기능 세트나 기준을 정의하라&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;마감&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;공격적으로 하되 과하지 않게 주의&lt;/li&gt;
&lt;li&gt;약간의 여유를 두고 지킬 수 있는 마감을 정하되 여유를 너무 많이 잡지 말 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;체계 혹은 프로젝트 작업 시간 정하기&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트를 위해 매일 혹은 매주 얼마의 시간을 쓸 것인지 명확히 정의&lt;/li&gt;
&lt;li&gt;정의한 시간이 정확히 언제인가를 정의&lt;/li&gt;
&lt;li&gt;작업 진도와 해야 할 일을 추적할 수 있는 절차를 정의&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;마무리&lt;/h2&gt;
&lt;p&gt;사이드 프로젝트를 완료하고 거기에서 이득을 취하기 위해 실제로 당신이 지켜야 할 아주 중요한 사항이 있다. 그건 바로 &lt;code&gt;일관성&lt;/code&gt;이다. 즉, 마음이 내킬 때만 해서는 안 된다는 말이다. 마음이 내키지 않을 때가 너무 많기 때문이다. 사이드 프로젝트 작업 일정을 정했으면 어떤 어려움이 있어도 그 일정을 지켜야 한다.&lt;/p&gt;
&lt;p&gt;더불어 무슨 일이든 마무리하는 습관을 기르는 게 좋다. 나도 마무리하는 습관을 기른 후에 인생이 바뀌었다. 시작해서 끝을 보지 못한 일이 누구에게나 있다. 어떤 프로젝트든지 아무리 마음에 들지 않아도 시작했으면 마무리하라. 그 프로젝트 때문에 죽을 것만 같아도 지켜라.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;99퍼센트 완성했어도 출시하지 못했다면 가치는 0퍼센트다.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;완벽한 해결책을 찾지 못했다는 이유로, 막혔다고 손을 놓아버리는 것보다는 어떻게든 강행행서 진전을 보는 게 거의 언제나 더 낫다.&lt;br&gt;
그럼 이제 당장 시작하라. 작게 시작하고 일정을 지켜서 마무리하기만 하면 아무 문제가 없을 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;꿈은 좇는 것이고 목표는 행동해서 실현하는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;출처 - &lt;a href=&quot;https://coupa.ng/bHkYTv&quot;&gt;커리스 스킬 / 존 손메즈 지음&lt;/a&gt; 중 사이드 프로젝트에 대해 요약 정리한 내용입니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[블로그를 하면 가장 좋은 점은]]></title><description><![CDATA[<h2>블로그를 하면 가장 좋은 점은</h2>
<p>얼마 전 지인으로부터 도움받은 글이라며 링크 하나를 공유해 줬다. <a href="/post/2/">개발자 이력서 작성하는 방법 - 99콘 이력서 후기</a>라는 내가 지난해 작성한 글로, 조회 수 및 다른 블로그에 많이 링크된 글이지만 포스팅 후 나조차도 상세 내용을 잊고 있었다. 헌데 요즘 내가 고민 중인 내용의 답이 이 포스팅 안에 있었다.<br>
슬럼프가 온 어느 날, 아무것도 해낼 수 없을 것 같은 땐 내가 작성했던 <a href="/post/16">털어놓기 어려웠던 개발자로서 고민을 해결해 준 책, 함께 자라기</a>를 다시 읽어 보고 마음을 다 잡는다.</p>
<blockquote>
<p>삶은 마치 특정한 사이클로 흐름이 반복되는 것 같다.</p>
<ul>
<li>무엇이든지 할 수 있을 것 같이 흥하는 시기</li>
<li>어떤 길로도 더 이상 나아갈 수 없을 것 같이 좌절하는 시기</li>
</ul>
</blockquote>
<p>이 시기들을 겪으면서 고민하고 답을 찾고 나를 알아가는 과정이 필요하다. 이때 그 고민과 답을 찾아가는 길을 기록하는 것은 미래의 같은 사이클을 또 경험 나에게 매우 도움 된다. 그래서 블로그를 하면 가장 좋은 점은 그 누구도 아닌 바로 나, 내게 도움된다. 기술 포스팅은 물론이고, 기술 이외에 개발자와 관련한 어떤 포스팅이든지.<br>
한 가지 더, 물론 내 블로그는 현시점에 많은 글들이 있지도 않고, 글 솜씨가 유려하지도 않지만 보너스처럼 면접 제안도 종종 온다.</p>
<p>지인에게 혹은 다른 이들에게 내 글이 도움이 되는 것도 좋지만, <code>결국 나에게 도움 될 때 가장 희열을 느낀다.</code><br>
이렇듯 블로깅은 미래의 나를 위해 차곡차곡 드는 <strong>보험</strong> 같은 것이다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_016.png"></p>
<h2>적당한 긴장감을 주기 위해 참여한 글또가 끝났다</h2>
<p>지난 <a href="/post/19">글 쓰는 또라이가 세상을 바꾼다 - 글또 4기에 참여해요</a>를 통해 글쓰기 모임에 참여한다는 것을 알렸고, 이번 주를 마지막으로 글또4기가 끝난다. 시간이 벌써 이렇게 되었나 싶고, 글또에 참여하면서 느꼈던 점을 요약해본다.</p>
<h3>계획을 세우세요</h3>
<p>나의 계획은 창대했으나.. 일이 정말 너무 바빴고, 개인사도 있어서 좀 더 체계적으로 참여하지 못한 것이 아쉽다. 만약 이 글을 보고 글또에 참여하길 원하는 분이라면 미리 어떤 글들을 쓸지 구성해놓는 것이 좋다고 말씀드리고 싶다. 계획은 참고로 최대한 구체적이어야 한다. 나의 경우 적당히 카테고리만 뽑아놨는데 이건 큰 도움이 되지 못했다. 2주란 시간은 생각보다 빨리 돌아온다.</p>
<h3>몇 번 결석해도 괜찮습니다</h3>
<p>또한 예치금 100% 사수하는 것이 목표였으나 2번 결석했다. 그래도 이 글또가 아니었다면 바쁜 일정을 핑계로 글을 단 한 개도 작성하지 않았을 것이다. 그렇기에 100% 예치금 사수를 못하고 실패한 것이라고 칭하고 싶지 않다.<br>
연초에 다짐한 목표 중 하나는 글을 1주일에 1개씩 작성하기가 있다. 지금 생각해보면 정말 무리한 목표였는데, 그래도 글또 덕분에 2주에 한 번은 글 작성해왔으니 성공적이라고 자축하고 싶다. 어느 상황이 되더라도 글쓰기만큼은 지속할 수 있어서 꾸준한 블로깅이 목표라면 참여할 것을 권하고 싶다. 이것이 글또의 최고 장점이 아닌가 싶다.</p>
<h3>다른 분들의 글을 읽기란 생각보다 쉽지 않습니다</h3>
<p>더불어 같은 직군에 있는 다른 분들의 글들을 보며 많은 정보와 동기를 얻게 되고, 다른 분야의 글들도 접할 수 있어서 매우 유익했다. 초반에는 올라오는 글들 대부분을 읽었으나 시간이 점차 흐를수록 지속하기 어려웠다. 피드백을 작성해야 하는 글들만 읽게 되고, 지난 글들을 슬랙 각 채널에서 하나하나 찾아봐야 하는 것이 불편했다. 많아지는 글 양에 비해 슬랙 ux가 따라주지 않아 점차 안 보게 되는 것 같다. 이 부분은 글또 참여한 글들이 어딘가에 갈무리되면 좋겠다.</p>
<h3>코로나 여파는 글또에게도 왔습니다</h3>
<p>지난 글또 기수 후기들을 보면 오프라인 모임이 꽤 있었다. 그래서 오프라인 모임에 대한 기대도 있었지만 아무래도 코로나로 인해 사회적 거리두기가 강화된 시기에 글또가 진행되어 거의 오프 모임은 진행하기 어려웠다. 중간에 각 직군 별로 한 번 모이는 기회가 있었지만, 나는 당일 갑작스런 장애 대응으로 참여하지 못해 너무 아쉽다 :(</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_019.png"></p>
<h2>글쓰기에 대한 부담을 버리고 지금 시작하세요</h2>
<p>이렇게 마무리된 글또를 통해 블로그에 많은 글들을 채울 수 있었다. 계속 블로깅을 이어갈 수 있어 좋았고, 글쓰기 습관화를 할 수 있어 더 좋았다.</p>
<p>글또에 참여하기 전에는 미쳐 몰랐던 점이, <strong>내 글의 호흡이 매우 길다</strong>는 것이다.<br>
한 번에 읽기에는 부담스러울 정도로 양이 많았다. 내게 글을 쓸 때 양적으로나 질적으로 뛰어난 글을 써야 한다는 압박감이 있었던 것이다. 그래서 글을 쓰는 건 각을 잡고 임해야 하는 거사였다. 글또에 참여하기 전에는 포스팅 하나에 들이는 시간이 거의 일주일 정도였다. 초안을 쓰고 다듬고 필요한 내용을 또 첨부하고.. 하지만 글또에 참여하면 시간 압박이 있다.<br>
즉, 내가 시간을 무조건 여유롭게 쓸 수 있는 것이 아니기에 양 혹은 질 중 적절히 밸런스를 맞춰야 했다. 하지만 둘 다 놓칠 수 없는 노릇이니 이 가운데 선택한 방법은 바로 <code>시리즈 글을 작성</code>하는 것이다. 포스팅 하나에 들어가는 시간이 줄어드니 글쓰기에 대한 부담이 정말 많이 줄었다.<br>
물론 아직 시리즈 글을 아직 다 마무리 하지 못했다. 하지만 걱정 없다. 오히려 내게 블로깅을 지속할 수 있는 글감을 더 안겨주었다.</p>
<p>그리고 또 하나, <code>이제는 완벽한 글을 쓰려고 하지 않는 것</code>이다<br>
나는 어차피 작가도 아니고 글로써 먹고 사는 이는 아니기 때문에 좋은 글을 쓰는 분들 처럼 글 쓰기란 매우 어렵고 많은 시간이 든다. 그래서 완벽하게 쓰려고 하기 보다는 내가 이 포스팅에서 말하고자 하는 부분만 충분히 전달하는 것에 집중한다. 적절히 꼭지를 나누고 불렛 리스트를 적용하면 꽤 정렬된 글이 나오며, 이 중 강조하고 싶은 두~세곳에만 하이라이트를 적절히 주는 방법을 쓰고 있다.</p>
<hr>
<p>블로그는 오픈 된 공간이라서 부담스럽고 소위 있어 보이는 글을 쓰기에 주저하는 분들이 계실 것이다. 시작하기 주저된다면 책이나 강의 후기, 기술 요약 포스팅처럼 <strong>글감의 원천이 내가 아닌 다른 것에서부터 시작</strong>하면 좋다. 그다음에는 나에 대해 돌아보는 포스팅으로 이어지면 더 좋다 :)<br>
그러니 이제 지금 시작하면 됩니다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_027.png"></p>]]></description><link>https://baek.dev/post/27/</link><guid isPermaLink="false">https://baek.dev/post/27/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 16 Aug 2020 12:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;블로그를 하면 가장 좋은 점은&lt;/h2&gt;
&lt;p&gt;얼마 전 지인으로부터 도움받은 글이라며 링크 하나를 공유해 줬다. &lt;a href=&quot;/post/2/&quot;&gt;개발자 이력서 작성하는 방법 - 99콘 이력서 후기&lt;/a&gt;라는 내가 지난해 작성한 글로, 조회 수 및 다른 블로그에 많이 링크된 글이지만 포스팅 후 나조차도 상세 내용을 잊고 있었다. 헌데 요즘 내가 고민 중인 내용의 답이 이 포스팅 안에 있었다.&lt;br&gt;
슬럼프가 온 어느 날, 아무것도 해낼 수 없을 것 같은 땐 내가 작성했던 &lt;a href=&quot;/post/16&quot;&gt;털어놓기 어려웠던 개발자로서 고민을 해결해 준 책, 함께 자라기&lt;/a&gt;를 다시 읽어 보고 마음을 다 잡는다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;삶은 마치 특정한 사이클로 흐름이 반복되는 것 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;무엇이든지 할 수 있을 것 같이 흥하는 시기&lt;/li&gt;
&lt;li&gt;어떤 길로도 더 이상 나아갈 수 없을 것 같이 좌절하는 시기&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 시기들을 겪으면서 고민하고 답을 찾고 나를 알아가는 과정이 필요하다. 이때 그 고민과 답을 찾아가는 길을 기록하는 것은 미래의 같은 사이클을 또 경험 나에게 매우 도움 된다. 그래서 블로그를 하면 가장 좋은 점은 그 누구도 아닌 바로 나, 내게 도움된다. 기술 포스팅은 물론이고, 기술 이외에 개발자와 관련한 어떤 포스팅이든지.&lt;br&gt;
한 가지 더, 물론 내 블로그는 현시점에 많은 글들이 있지도 않고, 글 솜씨가 유려하지도 않지만 보너스처럼 면접 제안도 종종 온다.&lt;/p&gt;
&lt;p&gt;지인에게 혹은 다른 이들에게 내 글이 도움이 되는 것도 좋지만, &lt;code&gt;결국 나에게 도움 될 때 가장 희열을 느낀다.&lt;/code&gt;&lt;br&gt;
이렇듯 블로깅은 미래의 나를 위해 차곡차곡 드는 &lt;strong&gt;보험&lt;/strong&gt; 같은 것이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_016.png&quot;&gt;&lt;/p&gt;
&lt;h2&gt;적당한 긴장감을 주기 위해 참여한 글또가 끝났다&lt;/h2&gt;
&lt;p&gt;지난 &lt;a href=&quot;/post/19&quot;&gt;글 쓰는 또라이가 세상을 바꾼다 - 글또 4기에 참여해요&lt;/a&gt;를 통해 글쓰기 모임에 참여한다는 것을 알렸고, 이번 주를 마지막으로 글또4기가 끝난다. 시간이 벌써 이렇게 되었나 싶고, 글또에 참여하면서 느꼈던 점을 요약해본다.&lt;/p&gt;
&lt;h3&gt;계획을 세우세요&lt;/h3&gt;
&lt;p&gt;나의 계획은 창대했으나.. 일이 정말 너무 바빴고, 개인사도 있어서 좀 더 체계적으로 참여하지 못한 것이 아쉽다. 만약 이 글을 보고 글또에 참여하길 원하는 분이라면 미리 어떤 글들을 쓸지 구성해놓는 것이 좋다고 말씀드리고 싶다. 계획은 참고로 최대한 구체적이어야 한다. 나의 경우 적당히 카테고리만 뽑아놨는데 이건 큰 도움이 되지 못했다. 2주란 시간은 생각보다 빨리 돌아온다.&lt;/p&gt;
&lt;h3&gt;몇 번 결석해도 괜찮습니다&lt;/h3&gt;
&lt;p&gt;또한 예치금 100% 사수하는 것이 목표였으나 2번 결석했다. 그래도 이 글또가 아니었다면 바쁜 일정을 핑계로 글을 단 한 개도 작성하지 않았을 것이다. 그렇기에 100% 예치금 사수를 못하고 실패한 것이라고 칭하고 싶지 않다.&lt;br&gt;
연초에 다짐한 목표 중 하나는 글을 1주일에 1개씩 작성하기가 있다. 지금 생각해보면 정말 무리한 목표였는데, 그래도 글또 덕분에 2주에 한 번은 글 작성해왔으니 성공적이라고 자축하고 싶다. 어느 상황이 되더라도 글쓰기만큼은 지속할 수 있어서 꾸준한 블로깅이 목표라면 참여할 것을 권하고 싶다. 이것이 글또의 최고 장점이 아닌가 싶다.&lt;/p&gt;
&lt;h3&gt;다른 분들의 글을 읽기란 생각보다 쉽지 않습니다&lt;/h3&gt;
&lt;p&gt;더불어 같은 직군에 있는 다른 분들의 글들을 보며 많은 정보와 동기를 얻게 되고, 다른 분야의 글들도 접할 수 있어서 매우 유익했다. 초반에는 올라오는 글들 대부분을 읽었으나 시간이 점차 흐를수록 지속하기 어려웠다. 피드백을 작성해야 하는 글들만 읽게 되고, 지난 글들을 슬랙 각 채널에서 하나하나 찾아봐야 하는 것이 불편했다. 많아지는 글 양에 비해 슬랙 ux가 따라주지 않아 점차 안 보게 되는 것 같다. 이 부분은 글또 참여한 글들이 어딘가에 갈무리되면 좋겠다.&lt;/p&gt;
&lt;h3&gt;코로나 여파는 글또에게도 왔습니다&lt;/h3&gt;
&lt;p&gt;지난 글또 기수 후기들을 보면 오프라인 모임이 꽤 있었다. 그래서 오프라인 모임에 대한 기대도 있었지만 아무래도 코로나로 인해 사회적 거리두기가 강화된 시기에 글또가 진행되어 거의 오프 모임은 진행하기 어려웠다. 중간에 각 직군 별로 한 번 모이는 기회가 있었지만, 나는 당일 갑작스런 장애 대응으로 참여하지 못해 너무 아쉽다 :(&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_019.png&quot;&gt;&lt;/p&gt;
&lt;h2&gt;글쓰기에 대한 부담을 버리고 지금 시작하세요&lt;/h2&gt;
&lt;p&gt;이렇게 마무리된 글또를 통해 블로그에 많은 글들을 채울 수 있었다. 계속 블로깅을 이어갈 수 있어 좋았고, 글쓰기 습관화를 할 수 있어 더 좋았다.&lt;/p&gt;
&lt;p&gt;글또에 참여하기 전에는 미쳐 몰랐던 점이, &lt;strong&gt;내 글의 호흡이 매우 길다&lt;/strong&gt;는 것이다.&lt;br&gt;
한 번에 읽기에는 부담스러울 정도로 양이 많았다. 내게 글을 쓸 때 양적으로나 질적으로 뛰어난 글을 써야 한다는 압박감이 있었던 것이다. 그래서 글을 쓰는 건 각을 잡고 임해야 하는 거사였다. 글또에 참여하기 전에는 포스팅 하나에 들이는 시간이 거의 일주일 정도였다. 초안을 쓰고 다듬고 필요한 내용을 또 첨부하고.. 하지만 글또에 참여하면 시간 압박이 있다.&lt;br&gt;
즉, 내가 시간을 무조건 여유롭게 쓸 수 있는 것이 아니기에 양 혹은 질 중 적절히 밸런스를 맞춰야 했다. 하지만 둘 다 놓칠 수 없는 노릇이니 이 가운데 선택한 방법은 바로 &lt;code&gt;시리즈 글을 작성&lt;/code&gt;하는 것이다. 포스팅 하나에 들어가는 시간이 줄어드니 글쓰기에 대한 부담이 정말 많이 줄었다.&lt;br&gt;
물론 아직 시리즈 글을 아직 다 마무리 하지 못했다. 하지만 걱정 없다. 오히려 내게 블로깅을 지속할 수 있는 글감을 더 안겨주었다.&lt;/p&gt;
&lt;p&gt;그리고 또 하나, &lt;code&gt;이제는 완벽한 글을 쓰려고 하지 않는 것&lt;/code&gt;이다&lt;br&gt;
나는 어차피 작가도 아니고 글로써 먹고 사는 이는 아니기 때문에 좋은 글을 쓰는 분들 처럼 글 쓰기란 매우 어렵고 많은 시간이 든다. 그래서 완벽하게 쓰려고 하기 보다는 내가 이 포스팅에서 말하고자 하는 부분만 충분히 전달하는 것에 집중한다. 적절히 꼭지를 나누고 불렛 리스트를 적용하면 꽤 정렬된 글이 나오며, 이 중 강조하고 싶은 두~세곳에만 하이라이트를 적절히 주는 방법을 쓰고 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;블로그는 오픈 된 공간이라서 부담스럽고 소위 있어 보이는 글을 쓰기에 주저하는 분들이 계실 것이다. 시작하기 주저된다면 책이나 강의 후기, 기술 요약 포스팅처럼 &lt;strong&gt;글감의 원천이 내가 아닌 다른 것에서부터 시작&lt;/strong&gt;하면 좋다. 그다음에는 나에 대해 돌아보는 포스팅으로 이어지면 더 좋다 :)&lt;br&gt;
그러니 이제 지금 시작하면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_027.png&quot;&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[경력을 발전 시키고 싶다면 - 커리어 스킬(1)]]></title><description><![CDATA[<p>import ExternalLink from 'components/ExternalLink';</p>
<ul>
<li><a href="/post/26/">경력을 발전시키고 싶다면 - 커리어 스킬(1)</a></li>
<li><a href="/post/28/">개발자의 사이드 프로젝트 - 커리어 스킬(2)</a></li>
</ul>
<p>소프트 스킬에서는 경력을 비롯한 소프트웨어 개발자의 생활 전반에 초점을 맞추었다면 이 <a href="https://coupa.ng/bHkYTv">커리스 스킬</a>은 오로지 경력에 집중한다. <a href="https://coupa.ng/bHkYTv">이 책</a>은 경력에 따라 읽는 순서를 가이드한다.</p>
<ul>
<li>이제 막 개발을 시작하는 입문자라면 소프트웨어 개발자로 입문하기 부터</li>
<li>
<p>이미 개발자로 일을 하고 몇 년간 코딩을 해온 사람이라면</p>
<ul>
<li>자신의 빈틈을 채우기 위해 바로 소프트웨어 개발에 대해 알아야 할 것 혹은 개발자로 일하기부터 보는 것을 추천</li>
</ul>
</li>
<li>경력을 발전시키는 데 관심이 많다면 바로 <code>경력 발전시키기</code> 부터 보는게 가장 합리적이다.</li>
</ul>
<h2>경력 발전시키기</h2>
<blockquote>
<p>자신에게 요구된 것 이상을 습관적으로 더 많이 해야만 발전할 수 있다.</p>
</blockquote>
<h2>최신 기술 따라잡기</h2>
<p>신기술과 새로운 프로그래밍 언어를 전부 배워야 한다는 뜻은 아니며, 그건 불가능하다. 다만 최신 기술을 따라잡기 위해 노력해야 한다는 뜻이다.</p>
<h3>블로그 구독하기</h3>
<ul>
<li>매일 아침 30분씩 여러 소프트웨어 개발 관련 블로그를 읽음</li>
<li>프로그래밍 세계에 등장하는 최신 기술을 따라잡기 위해</li>
<li>내가 직접 해야 할 일을 다른 사람이 어느 정도 도와주는 셈</li>
</ul>
<h3>책 읽기</h3>
<ul>
<li>기술 관련 서적을 적어도 한 권은 읽어야 함</li>
<li>자신에게 가장 큰 도움이 되는 책, 영구적 가치를 지닌 책을 고를 줄 알아야 함</li>
<li>소프트웨어 개발 방법론이나 디자인 패턴, 아키텍처에 대한 책도 언제나 좋은 선택</li>
<li>새로운 기술에 관한 책을 읽을 때는 단순히 읽는 데서 그치지 말고 경험을 통해 배워야 함</li>
</ul>
<h3>새로운 기술 선택하기</h3>
<ul>
<li>무엇을 배울 것인지 계획을 세울 것</li>
<li>현재 학습하는 주제를 마쳤을 때 다음 주제로 바로 넘어갈 수 있음</li>
<li>자신의 현재 기술 수준을 평가하고 앞으로 어떤 수준까지 이르고 싶은지 생각</li>
<li>다음에 배울 새로운 주제를 고르고 어떤 순서로 배울지 우선순위로 정하라</li>
<li>자신에게 가장 큰 도움이 될 기술, 프로그래밍 언어, 프레임워크를 정하고 배워야 할 것 목록에 적어두라</li>
</ul>
<h3>부지런히 코딩하기</h3>
<ul>
<li>
<p>사이드 프로젝트를 쉬면 안됨</p>
<ul>
<li>계속 코딩해야 기술이 녹슬지 않음</li>
</ul>
</li>
<li>사이드 프로젝트를 진행할 때는 마무리 지을 수 있을 정도로 작은 규모로 진행</li>
<li>
<p>시작한 프로젝트를 반드시 마무리하는 습관을 들인 것이 내가 태어나서 가장 잘한 일중 하나</p>
<ul>
<li>뭐든 시작한 일은 마무리하는 사람이 되어라</li>
</ul>
</li>
<li>그런 습관은 경력뿐 아니라 인생 전반에 큰 차이를 나타낼 것</li>
</ul>
<h2>제너럴리스트 vs. 스페셜리스트</h2>
<ul>
<li>
<p>제너럴리스트의 가치를 높이 산다고 말하는 많은 사람이 자신은 정말 그렇게 생각한다고 믿음</p>
<ul>
<li>하지만 그런 사람도 필요한 순간에는 결국 전무가를 찾음</li>
</ul>
</li>
<li>해당 분야에 대해 일반적인 지식을 넓게 갖추지 못한 상태로 훌륭한 전문가가 된다는 건 어불성설</li>
</ul>
<h3>T자형 인재가 되는 게 중요</h3>
<ul>
<li>자신의 분야에 대해 넓은 기본 지식을 갖추되 적어도 한 영역에 대해서는 깊이 있는 전문적 지식이나 기술을 갖춰야 함</li>
<li>소프트웨어 개발자라면 코딩, 알고리즘, 데이터 구조, 아키텍처, 프런트엔드, 백엔드, 데이터베이스 등에 정통하기 위해 노력해야 함</li>
<li>적어도 한 영역에 있어서만큼은 깊이 있는 지식을 쌓는 게 좋음</li>
<li>독보적으로 두각을 드러내서 자신의 가치를 더욱 높일 영역을 선택해야 함</li>
<li>개인 브랜드를 만들고 자신을 마케팅할 대 이런 전문성을 확용</li>
</ul>
<h3>만약 전문 영역을 잘못 선택한다면?</h3>
<ul>
<li><code>다른 영역으로 바꾸면 된다. 별일 아니다.</code></li>
<li>잘못 고를까 두려운 마음에 아무 영역도 고르지 못하는 소프트웨어 개발자가 많다</li>
<li>
<p>무엇이든 선택하고 결과를 지켜보라</p>
<ul>
<li>아무것도 하지 않는 것보다 그게 훨씬 낫다</li>
</ul>
</li>
<li>필요하면 언제든 방향을 전환하면 된다</li>
<li>
<p>일단 한 영역의 전문간가 된 후에 다른 영역의 전문가가 되는 건 훨씬 쉽게 느껴진다</p>
<ul>
<li>다른 데서 활용할 수 없을 것 같은 기술이 알고 보면 다른 곳에서 유용하게 쓰이는 경우가 있어</li>
<li>그래서 <code>깊이 파고드는 능력</code>을 키우는 건 그 자체만으로도 가치가 있음</li>
</ul>
</li>
</ul>
<h3>그래서 어떻게 해야 하나요?</h3>
<ul>
<li>
<p>너무 넓은 영역을 선택하기 보다는 지나칠 정도로 좁고 구체적인 영역을 고르는게 좋음</p>
<ul>
<li>최대한 좁은 범위를 설정하고 나중에 얼마든지 확장할 수 있음</li>
</ul>
</li>
<li>소프트웨어 개발에 관한 일반적인 지식을 최대한 넓게 쌓는것도 게을리하지 말 것</li>
<li>좋은 코드를 작성하는 방법을 배울 것</li>
</ul>
<p><ExternalLink
 href="https://coupa.ng/bHkYTv" target="_blank"
 src="https://baek.dev/assets/images/post/2020/2020_026_002.jpg" alt="커리어 스킬" 
/></p>
<h2>사이드 프로젝트</h2>
<blockquote>
<p>내 인생과 경력을 돌이켜봤을 때 모든 게 극적으로 변한 한 순간,<br>
변곡점이 하나 존재한다.<br>
그 변곡점은 내가 사이드 프로젝트를 처음으로 마무리한 순간이었다.</p>
</blockquote>
<h3>사이드 프로젝트는 항상 해야 한다</h3>
<ul>
<li>사이드 프로젝트는 소프트웨어 개발자가 경력을 발전시킬 좋은 방법</li>
<li>새로운 기술을 배우고 알던 기술을 연습할 기회를 줌</li>
<li>새로운 영역에 도전해보면서 자신의 능력에 대한 자신감도 키울 수 있음</li>
<li>6개월짜리 사이드 프로젝트 하나가 9시부터 5시까지 근무하는 회사에 몇 년간 다녀야배울 수 있는 경험을 하게 해줌</li>
</ul>
<h3>사이드 프로젝트 고르기</h3>
<ul>
<li>
<p>처음에는 아주 작은 것에 도전</p>
<ul>
<li>아주 쉽게 완료할 수 있다고 생각하는 아주 간단한 사이드 프로젝트로 시작</li>
<li>한두 주 혹은 길어도 한 달 정도면 마칠 수 있는 것을 선택</li>
</ul>
</li>
<li>첫 번째 사이드 프로젝트로 클론 코딩을 추천</li>
<li>작고 쉬운 사이드 프로젝트를 완성해서 자신에 대한 신뢰가 굳건해지면 조금 더 욕심을 내도 좋음</li>
</ul>
<h3>시작하기</h3>
<ul>
<li>
<p>사실 무슨 일이든 시작하기 전에 어떤 일을 할 것이고 최종 목표는 무엇인지 계획을 세워두어야 함</p>
<ul>
<li>목표 혹은 완료의 기준</li>
<li>마감</li>
<li>체계 혹은 프로젝트 작업 시간 정하기</li>
</ul>
</li>
</ul>
<h3>꾸준히 하라</h3>
<ul>
<li>프로젝트를 완료하고 거기에서 이득을 취하기 위해 실제로 당신이 지켜할 아주 중요한 사항은 바로 <code>일관성</code></li>
<li>
<p>마음이 내킬 떄만 해서는 안됨</p>
<ul>
<li>마음이 내키지 않을 때가 너무 많기 때문</li>
</ul>
</li>
</ul>
<h3>마무리하라</h3>
<ul>
<li>
<p>어떤 프로젝트든지 아무리 마음에 들지 않아도 시작했으면 마무리하라</p>
<ul>
<li>그 프로젝트 때문에 죽을 것만 같아도 지켜라</li>
</ul>
</li>
<li>99%센트 완성했어도 출시하지 못했다면 가치는 0%</li>
<li>완벽한 해결책을 찾지 못했다는 이유로, 막혔다고 손을 놓아버리는 것보다 어떻게든 강행해서 진전을 보는 게 거의 언제나 더 나음</li>
</ul>
<h2>좋은 평판 쌓기</h2>
<ul>
<li>정말 뛰어난 개발자가 되고 싶다면</li>
<li>자신의 경력을 한 단계 끌어 올리고 싶다면</li>
<li>자신을 마게팅하고 개인 브랜드를 만드는 방법을 배워서 좋은 평판을 구축해야 함</li>
<li>모두에게 닫혀 있던 기회의 문이 열릴 것</li>
<li>평판에 따라 보상이 달라짐</li>
<li>본인이 인맥, 일자리, 기횔를 따라다니지 않아도 평판이 좋으면 이런 것들이 저절로 따라옴</li>
<li>자신을 홍보하고 마케팅하고 브랜드를 만드는 걸 나쁘게 보아서는 안 됨</li>
</ul>
<blockquote>
<p>세계 최고의 프로그래머라 해도 자기 방에만 틀어박혀서 그 누구와도 소통하지 않는다면 아무 의미가 없다.<br>
별다른 영향력을 갖지 못하기 떄문이다.</p>
</blockquote>
<h3>블로그를 시작하면서</h3>
<ul>
<li>심플 프로그래머라는 블로그를 시작</li>
<li>
<p>점점 더 많은 사람들이 블로그에 찾아오면서 흥미로운 일이 일어남</p>
<ul>
<li>코드 캠프나 행사에서 나를 알거나 내 블로그를 아는 사람들이 나타남</li>
<li>인기 있는 팟캐스트에서 인터뷰 요청이 들어오기 시작</li>
<li>헤드헌터들이 스팸이나 다름없는 이메일 말고 제대로 된 일자리를 제안하는 이메일을 보내오기 시작</li>
</ul>
</li>
</ul>
<h3>가치 제공하기</h3>
<ul>
<li>
<p>브랜딩을 위한 다양한 활동에는 한 가지 중요한 원칙이 있음</p>
<ul>
<li>다른 사람들에게 가치를 제공하는 것</li>
</ul>
</li>
<li>가치를 무료로 제공하면 더 좋고, 90%를 무료로 제공하고, 10%만 돈을 받는 전략을 세움</li>
<li>
<p><code>다른 사람들의 인생에 도움이 되는 게 최고의 마케팅</code></p>
<ul>
<li>베푸는 사람으로 이름을 알리고</li>
<li>주변에 있으면 혜택을 보는 것 같아서 자꾸 함께 어울리고 싶은 느낌이 드는 사람이 되어라</li>
</ul>
</li>
<li>다른 사람들이 원하는 것을 잘 얻도록 도와준다면 당신도 자신이 원하는 모든 것을 얻을 수 있을 것</li>
</ul>
<h3>시간이 든다</h3>
<ul>
<li>
<p>블로그를 시작하고 한 1년 정도 글을 쓰다가 아무 성과 없이 그만두면 문제</p>
<ul>
<li>성공하고 싶다면 그보다 오래 버틸 각오가 되어 있어야 함</li>
<li>2~3년이 걸릴 수도, 5년이 걸릴 수도</li>
</ul>
</li>
<li>끈기있게 노력하면 결국은 목적이에 도달할 것</li>
</ul>
<hr>
<p>출처 - <a href="https://coupa.ng/bHkYTv">커리스 스킬 / 존 손메즈 지음</a> 중 경력 발전 시키기에 대해 요약 정리한 내용입니다.</p>]]></description><link>https://baek.dev/post/26/</link><guid isPermaLink="false">https://baek.dev/post/26/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 02 Aug 2020 12:45:00 GMT</pubDate><content:encoded>&lt;p&gt;import ExternalLink from &apos;components/ExternalLink&apos;;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/post/26/&quot;&gt;경력을 발전시키고 싶다면 - 커리어 스킬(1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/28/&quot;&gt;개발자의 사이드 프로젝트 - 커리어 스킬(2)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;소프트 스킬에서는 경력을 비롯한 소프트웨어 개발자의 생활 전반에 초점을 맞추었다면 이 &lt;a href=&quot;https://coupa.ng/bHkYTv&quot;&gt;커리스 스킬&lt;/a&gt;은 오로지 경력에 집중한다. &lt;a href=&quot;https://coupa.ng/bHkYTv&quot;&gt;이 책&lt;/a&gt;은 경력에 따라 읽는 순서를 가이드한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이제 막 개발을 시작하는 입문자라면 소프트웨어 개발자로 입문하기 부터&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이미 개발자로 일을 하고 몇 년간 코딩을 해온 사람이라면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자신의 빈틈을 채우기 위해 바로 소프트웨어 개발에 대해 알아야 할 것 혹은 개발자로 일하기부터 보는 것을 추천&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;경력을 발전시키는 데 관심이 많다면 바로 &lt;code&gt;경력 발전시키기&lt;/code&gt; 부터 보는게 가장 합리적이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;경력 발전시키기&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;자신에게 요구된 것 이상을 습관적으로 더 많이 해야만 발전할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;최신 기술 따라잡기&lt;/h2&gt;
&lt;p&gt;신기술과 새로운 프로그래밍 언어를 전부 배워야 한다는 뜻은 아니며, 그건 불가능하다. 다만 최신 기술을 따라잡기 위해 노력해야 한다는 뜻이다.&lt;/p&gt;
&lt;h3&gt;블로그 구독하기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;매일 아침 30분씩 여러 소프트웨어 개발 관련 블로그를 읽음&lt;/li&gt;
&lt;li&gt;프로그래밍 세계에 등장하는 최신 기술을 따라잡기 위해&lt;/li&gt;
&lt;li&gt;내가 직접 해야 할 일을 다른 사람이 어느 정도 도와주는 셈&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;책 읽기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;기술 관련 서적을 적어도 한 권은 읽어야 함&lt;/li&gt;
&lt;li&gt;자신에게 가장 큰 도움이 되는 책, 영구적 가치를 지닌 책을 고를 줄 알아야 함&lt;/li&gt;
&lt;li&gt;소프트웨어 개발 방법론이나 디자인 패턴, 아키텍처에 대한 책도 언제나 좋은 선택&lt;/li&gt;
&lt;li&gt;새로운 기술에 관한 책을 읽을 때는 단순히 읽는 데서 그치지 말고 경험을 통해 배워야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;새로운 기술 선택하기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;무엇을 배울 것인지 계획을 세울 것&lt;/li&gt;
&lt;li&gt;현재 학습하는 주제를 마쳤을 때 다음 주제로 바로 넘어갈 수 있음&lt;/li&gt;
&lt;li&gt;자신의 현재 기술 수준을 평가하고 앞으로 어떤 수준까지 이르고 싶은지 생각&lt;/li&gt;
&lt;li&gt;다음에 배울 새로운 주제를 고르고 어떤 순서로 배울지 우선순위로 정하라&lt;/li&gt;
&lt;li&gt;자신에게 가장 큰 도움이 될 기술, 프로그래밍 언어, 프레임워크를 정하고 배워야 할 것 목록에 적어두라&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;부지런히 코딩하기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;사이드 프로젝트를 쉬면 안됨&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;계속 코딩해야 기술이 녹슬지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;사이드 프로젝트를 진행할 때는 마무리 지을 수 있을 정도로 작은 규모로 진행&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시작한 프로젝트를 반드시 마무리하는 습관을 들인 것이 내가 태어나서 가장 잘한 일중 하나&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;뭐든 시작한 일은 마무리하는 사람이 되어라&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;그런 습관은 경력뿐 아니라 인생 전반에 큰 차이를 나타낼 것&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;제너럴리스트 vs. 스페셜리스트&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;제너럴리스트의 가치를 높이 산다고 말하는 많은 사람이 자신은 정말 그렇게 생각한다고 믿음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하지만 그런 사람도 필요한 순간에는 결국 전무가를 찾음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;해당 분야에 대해 일반적인 지식을 넓게 갖추지 못한 상태로 훌륭한 전문가가 된다는 건 어불성설&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;T자형 인재가 되는 게 중요&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;자신의 분야에 대해 넓은 기본 지식을 갖추되 적어도 한 영역에 대해서는 깊이 있는 전문적 지식이나 기술을 갖춰야 함&lt;/li&gt;
&lt;li&gt;소프트웨어 개발자라면 코딩, 알고리즘, 데이터 구조, 아키텍처, 프런트엔드, 백엔드, 데이터베이스 등에 정통하기 위해 노력해야 함&lt;/li&gt;
&lt;li&gt;적어도 한 영역에 있어서만큼은 깊이 있는 지식을 쌓는 게 좋음&lt;/li&gt;
&lt;li&gt;독보적으로 두각을 드러내서 자신의 가치를 더욱 높일 영역을 선택해야 함&lt;/li&gt;
&lt;li&gt;개인 브랜드를 만들고 자신을 마케팅할 대 이런 전문성을 확용&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;만약 전문 영역을 잘못 선택한다면?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;다른 영역으로 바꾸면 된다. 별일 아니다.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;잘못 고를까 두려운 마음에 아무 영역도 고르지 못하는 소프트웨어 개발자가 많다&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;무엇이든 선택하고 결과를 지켜보라&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;아무것도 하지 않는 것보다 그게 훨씬 낫다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;필요하면 언제든 방향을 전환하면 된다&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;일단 한 영역의 전문간가 된 후에 다른 영역의 전문가가 되는 건 훨씬 쉽게 느껴진다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다른 데서 활용할 수 없을 것 같은 기술이 알고 보면 다른 곳에서 유용하게 쓰이는 경우가 있어&lt;/li&gt;
&lt;li&gt;그래서 &lt;code&gt;깊이 파고드는 능력&lt;/code&gt;을 키우는 건 그 자체만으로도 가치가 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;그래서 어떻게 해야 하나요?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;너무 넓은 영역을 선택하기 보다는 지나칠 정도로 좁고 구체적인 영역을 고르는게 좋음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;최대한 좁은 범위를 설정하고 나중에 얼마든지 확장할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;소프트웨어 개발에 관한 일반적인 지식을 최대한 넓게 쌓는것도 게을리하지 말 것&lt;/li&gt;
&lt;li&gt;좋은 코드를 작성하는 방법을 배울 것&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;ExternalLink
 href=&quot;https://coupa.ng/bHkYTv&quot; target=&quot;_blank&quot;
 src=&quot;https://baek.dev/assets/images/post/2020/2020_026_002.jpg&quot; alt=&quot;커리어 스킬&quot; 
/&gt;&lt;/p&gt;
&lt;h2&gt;사이드 프로젝트&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;내 인생과 경력을 돌이켜봤을 때 모든 게 극적으로 변한 한 순간,&lt;br&gt;
변곡점이 하나 존재한다.&lt;br&gt;
그 변곡점은 내가 사이드 프로젝트를 처음으로 마무리한 순간이었다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;사이드 프로젝트는 항상 해야 한다&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;사이드 프로젝트는 소프트웨어 개발자가 경력을 발전시킬 좋은 방법&lt;/li&gt;
&lt;li&gt;새로운 기술을 배우고 알던 기술을 연습할 기회를 줌&lt;/li&gt;
&lt;li&gt;새로운 영역에 도전해보면서 자신의 능력에 대한 자신감도 키울 수 있음&lt;/li&gt;
&lt;li&gt;6개월짜리 사이드 프로젝트 하나가 9시부터 5시까지 근무하는 회사에 몇 년간 다녀야배울 수 있는 경험을 하게 해줌&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;사이드 프로젝트 고르기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;처음에는 아주 작은 것에 도전&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;아주 쉽게 완료할 수 있다고 생각하는 아주 간단한 사이드 프로젝트로 시작&lt;/li&gt;
&lt;li&gt;한두 주 혹은 길어도 한 달 정도면 마칠 수 있는 것을 선택&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;첫 번째 사이드 프로젝트로 클론 코딩을 추천&lt;/li&gt;
&lt;li&gt;작고 쉬운 사이드 프로젝트를 완성해서 자신에 대한 신뢰가 굳건해지면 조금 더 욕심을 내도 좋음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;시작하기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;사실 무슨 일이든 시작하기 전에 어떤 일을 할 것이고 최종 목표는 무엇인지 계획을 세워두어야 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;목표 혹은 완료의 기준&lt;/li&gt;
&lt;li&gt;마감&lt;/li&gt;
&lt;li&gt;체계 혹은 프로젝트 작업 시간 정하기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;꾸준히 하라&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트를 완료하고 거기에서 이득을 취하기 위해 실제로 당신이 지켜할 아주 중요한 사항은 바로 &lt;code&gt;일관성&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마음이 내킬 떄만 해서는 안됨&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;마음이 내키지 않을 때가 너무 많기 때문&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;마무리하라&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;어떤 프로젝트든지 아무리 마음에 들지 않아도 시작했으면 마무리하라&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그 프로젝트 때문에 죽을 것만 같아도 지켜라&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;99%센트 완성했어도 출시하지 못했다면 가치는 0%&lt;/li&gt;
&lt;li&gt;완벽한 해결책을 찾지 못했다는 이유로, 막혔다고 손을 놓아버리는 것보다 어떻게든 강행해서 진전을 보는 게 거의 언제나 더 나음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;좋은 평판 쌓기&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;정말 뛰어난 개발자가 되고 싶다면&lt;/li&gt;
&lt;li&gt;자신의 경력을 한 단계 끌어 올리고 싶다면&lt;/li&gt;
&lt;li&gt;자신을 마게팅하고 개인 브랜드를 만드는 방법을 배워서 좋은 평판을 구축해야 함&lt;/li&gt;
&lt;li&gt;모두에게 닫혀 있던 기회의 문이 열릴 것&lt;/li&gt;
&lt;li&gt;평판에 따라 보상이 달라짐&lt;/li&gt;
&lt;li&gt;본인이 인맥, 일자리, 기횔를 따라다니지 않아도 평판이 좋으면 이런 것들이 저절로 따라옴&lt;/li&gt;
&lt;li&gt;자신을 홍보하고 마케팅하고 브랜드를 만드는 걸 나쁘게 보아서는 안 됨&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;세계 최고의 프로그래머라 해도 자기 방에만 틀어박혀서 그 누구와도 소통하지 않는다면 아무 의미가 없다.&lt;br&gt;
별다른 영향력을 갖지 못하기 떄문이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;블로그를 시작하면서&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;심플 프로그래머라는 블로그를 시작&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;점점 더 많은 사람들이 블로그에 찾아오면서 흥미로운 일이 일어남&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;코드 캠프나 행사에서 나를 알거나 내 블로그를 아는 사람들이 나타남&lt;/li&gt;
&lt;li&gt;인기 있는 팟캐스트에서 인터뷰 요청이 들어오기 시작&lt;/li&gt;
&lt;li&gt;헤드헌터들이 스팸이나 다름없는 이메일 말고 제대로 된 일자리를 제안하는 이메일을 보내오기 시작&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;가치 제공하기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;브랜딩을 위한 다양한 활동에는 한 가지 중요한 원칙이 있음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다른 사람들에게 가치를 제공하는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;가치를 무료로 제공하면 더 좋고, 90%를 무료로 제공하고, 10%만 돈을 받는 전략을 세움&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;다른 사람들의 인생에 도움이 되는 게 최고의 마케팅&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;베푸는 사람으로 이름을 알리고&lt;/li&gt;
&lt;li&gt;주변에 있으면 혜택을 보는 것 같아서 자꾸 함께 어울리고 싶은 느낌이 드는 사람이 되어라&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;다른 사람들이 원하는 것을 잘 얻도록 도와준다면 당신도 자신이 원하는 모든 것을 얻을 수 있을 것&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;시간이 든다&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;블로그를 시작하고 한 1년 정도 글을 쓰다가 아무 성과 없이 그만두면 문제&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;성공하고 싶다면 그보다 오래 버틸 각오가 되어 있어야 함&lt;/li&gt;
&lt;li&gt;2~3년이 걸릴 수도, 5년이 걸릴 수도&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;끈기있게 노력하면 결국은 목적이에 도달할 것&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;출처 - &lt;a href=&quot;https://coupa.ng/bHkYTv&quot;&gt;커리스 스킬 / 존 손메즈 지음&lt;/a&gt; 중 경력 발전 시키기에 대해 요약 정리한 내용입니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[포스트 코로나 시대 재택근무의 상반기 회고]]></title><description><![CDATA[<p><a href="/post/18/">지난 2월에 시도했던 매월하는 회고</a>는 1회로 그치고 말았다. 왜냐하면 정말 일밖에 한게 없어서.. 할 이야기가 없었다.<br>
하지만 나는 현재 개발이란 일을 하고 있고, 이 블로그는 개발 블로그이니 일 이야기로 회고를 하는 건 방향에 부합해 몇 가지 회고를 해볼까 한다.</p>
<p>올 2월 중하순부터 본격적으로 코로나 사태가 심각해지면서 회사는 주 5일 온전한 재택근무로 전환했다.<br>
현재 회사는 이전에도 재택근무를 주 1회하고 있어기에 이번 코로나 사태로 인해 근무 형태가 바뀐 것은 내게 큰 일은 아니었다.<br>
참고로 이 글을 쓰는 시점에도 지금 회사는 계속 재택근무 중이다.</p>
<h2>커뮤니케이션의 만족도 하향 및 부상</h2>
<p><code>하지만 팀원 모두가 동시에 재택근무를 하는 것은 다른 일이었다.</code></p>
<p>모두가 온라인으로 회의를 해야하니 말을 할 순서를 눈치봐야되고 네트워크 상태가 좋지않으면 회의가 지연되기도 한다.
또한 미팅을 하다보면 누군가 머뭇거려하는 모습을 보고 발언을 챙겨 준거나 혹은 모두가 이견없이 해피한지 분위기를 가늠할 수 있는데 온라인 회의는 그러기가 쉽지 않다.<br>
<strong>나를 감싸는 이 공기와 조명이 어떤 분위기인지 알길이 없다.</strong></p>
<p>flow chart를 그려가며 프로젝트 설명을 하지만 각 개인마다 업무 집중도가 현저히 달라 이로 인해 일이 산으로 간적도 있다.
코드 리뷰도 온라인으로 실시간 진행도 했지만 보이지 않는 한계가 있었던 것 같다.
아마도 이건 굉장히 빠른 싸이클로 프로젝트를 진행하는 우리 팀 성격도 기인했다고 볼 수 있다.</p>
<p>또 하나 재택근무 특성상 특별히 자리를 뜰 일이 거의 없기 때문에 활동량이 급격히 줄었다.
그래서 재택근무 2주 만에는 무릎이 나가는 부상이 생겨 물리치료도 받았다.
저녁에 운동을 하기에는 업무 종료 시간이 들쭉날쭉하고 야근도 많아 쉽지 않았기에 아침에 운동하는 새로운 도전을 했다.</p>
<p>집 근처 한강에서 아침 운동을 하니 세상 그렇게 뿌듯하고 자기 만족도도 매우 높아졌다. 놀라운 건 아침에 운동을 하는 사람이 정말 많아 많은 자극이 됐다.
물리치료를 병행하면서 업무 중간 중간 의식적으로 스트레칭을 하면서 몸을 풀려고 했고, 점심시간은 정해진 시간에 규칙적으로 휴식을 취하려고 노력했다.</p>
<p>하지만 점점 많아지는 일 때문에 이런 호사는 얼마 누리지 못했다.
계속되는 야근에 새벽까지 일하는 경우는 많아졌고 아침에 눈을 뜨자마자 책상으로 출근해서 일을 하다 늦으면 오후 3~4시에 첫끼를 먹으러 자리를 뜨기도 했다.
프로젝트는 계속되고 장애 발생하니 쉴틈이 없었다.</p>
<p><strong>그렇게 내 상반기는 업무만 하다 끝이 났다.</strong></p>
<p>올드보이처럼 갇혀서 일만했고, 번아웃이 온 것 같고 많이 지쳤다.<br>
보이지 않는 곳에서 더 많은 일을 하니 상실감과 박탈감이 더 크다.<br>
물론 우리가 일을 하는 목적은 보여주고자 하는 것은 아니지만, 팀원들이 서로의 상태를 체크할 수 없다는 것은 협업을 함에 있어서 큰 문제 요소가 될 수 있다.
당연히 초과 근무 진행에 대해 팀내 공유는 하지만 옆에서 직접 눈으로 보는 것과 구두 전달은 엄연히 체감정도가 다를 수 밖에 없다.<br>
이 같은 상황을 팀원 대부분 겪고 있었고 이 점에 대해 많은 시간을 들여 함께 고민하고 점진적 해결 방안을 모색하는 시간을 가졌다.</p>
<h2>장기 재택근무에 대비하기 위해 장비 구매</h2>
<p>집에서 근무하는 시간이 많으니 의자도 새로 구매가 필요했다.<br>
그 전까지는 책상에 장시간 자주 앉지 않아 그닥 불편하지 않았는데 무릎 한 번 고장나니 좀 더 좋은 의자가 필요했다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_025_001.png" alt="시디즈 T50 Air"></p>
<p>여러 제품을 알아보다 회사 의자도 시디즈여서 큰 고민없이 브랜드는 시디즈로 정했다. 코로나 이전 회사에서는 많은 시간 앉아있었지만 불편함을 전혀 느끼지 못했기에 시디즈 정도면 괜찮다고 생각했다. 매장에서 여러 의자를 앉아보고 <a href="https://coupa.ng/bFuLnJ">시디즈 T50 Air</a>으로 결정했다.</p>
<p>의자 판이 앞뒤 위치 조절이 되고, 틸팅 기능, 매쉬 소재로 이뤄져 괜찮은 의자다. 가끔 일하다 잠깐 쉬려고 의자를 뒤로 최대로 누우면 해먹에 누운 기분이라 스스륵 잠이 들때도 있다.<br>
적당한 가격에 의자를 찾고 있다면 <a href="https://coupa.ng/bFuLnJ">시디즈 T50 Air</a> 추천한다.</p>
<p><img src="https://baek.dev/assets/images/basic/001.png" alt="필코 마제스터치2 텐키리스 흑축"></p>
<p>마지막으로 <strong>무접점 키보드</strong>에 입문했다. 회사랑 집에서 둘다 필코 마제스터치2를 사용중이다. 다만 회사는 텐키리스이고 집은 스탠다드로 스탠다드는 마우스를 사용할 때 거리가 더 길어지고 자세가 점점 틀어지기 시작했다. 키보드도 집에선 자주 사용하진 않았으니 크게 불편함이 없었지만 집에서 장시간 사용하면서 스탠다드가 잘못된 자세를 초래하고 이렇게 장시간 사용하면 어깨나 허리에도 안좋은 영향을 줄것이라 직감했다.</p>
<p>그래서 텐키리스 키보드를 알아보다가 이번에는 무접점에 다시 도전해보고 싶어 <a href="https://coupa.ng/bFuQEA">한성컴퓨터 GK888B minicoup</a>을 추천받았다.
기존에 해피해킹을 구매한 적이 있는데, 무접점 방식 키감은 정말 마음에 쏙 들었지만 Vim에 맞춰진 키배열은 내게 그야말로 혼돈의 카오스였다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_025_003.png" alt="화려한 키캡이 나를 감싸줘야 함"><br>
또한 무접점은 키캡 놀이하기 쉽지 않아 화려한 키캡이 나를 감싸줘야 하는데 그렇지 못해 매우 아쉬운 점이 있어 해피해킹 이후 무접점을 시도하진 않았다.
반면 요즘 나오는 다양한 무접점 키보드들이 기계식 키보드 키캡과 호환이 가능하도록 나와서 키캡놀이도 가능하다.</p>
<p>그래서 <a href="https://coupa.ng/bFuQEA">한성컴퓨터 GK888B minicoup</a>을 구매했는데 미니 키 배열이라 방향키가 정말 빌런이었다.
코딩할 땐 최악이어서 생산성이 떨어질 정도였다. 또한 뽑기를 잘못했는지 유선 입력 상태에서도 키입력 딜레이가 있었다.</p>
<p>다음에 구매한 건 콕스 엔데버였다. 콕스 엔데버와 항상 함께 비교되는 제품은 앱코 v2이다.
콕스 엔데버를 먼저 만나 사용해봤더니 정말 마음에 들었다. 하지만 한가지.. 콕스 엔데버는 맥북 카라바이너에서 Fn키 맵핑이 되지 않는다.
다른 유저에게는 별거 아닐 수 있지만 개인 설정에 부합하지 못해 콕스 엔데버는 탈락했다.</p>
<p>이후 다시 돌아 한성으로 왔고 앱코를 선택하지 않고 다시 한성을 고른 이유는 블루투스 기능때문이었다.
무선은 책상을 쾌적하게 만들어주어 매력적인 포인트라 생각했고 다시 한 번 뽑기 운을 믿어 보기로 해서 <a href="https://coupa.ng/bFuQ6J">87key 배열의 GK893B</a>로 선택했다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_025_002.png" alt="한성컴퓨터 무접점 GK893B"></p>
<p>뽑기는 대 성공이었고 키 딜레이 없이 잘 사용하고 있다. 키 배열도 마음에 들고 텐키리스여서 어깨와 자세 부담도 사라졌다. 또한 기계식과 다르게 보글보글한 키감은 정말 기분이 좋다.
저렴한 가격에 무접점을 입문해보고 싶다면 한성, 콕스, 앱코 중에서 개인 취향에 맞는 제품을 구매하면 된다. 나는 좀 더 사용해보다 리얼포스나 레오폴드로 업글하려고 한다.</p>
<hr>
<p>물론 일은 여전히 많고 여전히 바쁠 예정이다.<br>
하지만 하반기에는 여러가지 변화를 꾀하려고 한다. 그래서 다음 회고에는 새로운 변화를 이야기해볼 수 있으면 좋겠다.</p>]]></description><link>https://baek.dev/post/25/</link><guid isPermaLink="false">https://baek.dev/post/25/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 05 Jul 2020 14:50:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;/post/18/&quot;&gt;지난 2월에 시도했던 매월하는 회고&lt;/a&gt;는 1회로 그치고 말았다. 왜냐하면 정말 일밖에 한게 없어서.. 할 이야기가 없었다.&lt;br&gt;
하지만 나는 현재 개발이란 일을 하고 있고, 이 블로그는 개발 블로그이니 일 이야기로 회고를 하는 건 방향에 부합해 몇 가지 회고를 해볼까 한다.&lt;/p&gt;
&lt;p&gt;올 2월 중하순부터 본격적으로 코로나 사태가 심각해지면서 회사는 주 5일 온전한 재택근무로 전환했다.&lt;br&gt;
현재 회사는 이전에도 재택근무를 주 1회하고 있어기에 이번 코로나 사태로 인해 근무 형태가 바뀐 것은 내게 큰 일은 아니었다.&lt;br&gt;
참고로 이 글을 쓰는 시점에도 지금 회사는 계속 재택근무 중이다.&lt;/p&gt;
&lt;h2&gt;커뮤니케이션의 만족도 하향 및 부상&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;하지만 팀원 모두가 동시에 재택근무를 하는 것은 다른 일이었다.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;모두가 온라인으로 회의를 해야하니 말을 할 순서를 눈치봐야되고 네트워크 상태가 좋지않으면 회의가 지연되기도 한다.
또한 미팅을 하다보면 누군가 머뭇거려하는 모습을 보고 발언을 챙겨 준거나 혹은 모두가 이견없이 해피한지 분위기를 가늠할 수 있는데 온라인 회의는 그러기가 쉽지 않다.&lt;br&gt;
&lt;strong&gt;나를 감싸는 이 공기와 조명이 어떤 분위기인지 알길이 없다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;flow chart를 그려가며 프로젝트 설명을 하지만 각 개인마다 업무 집중도가 현저히 달라 이로 인해 일이 산으로 간적도 있다.
코드 리뷰도 온라인으로 실시간 진행도 했지만 보이지 않는 한계가 있었던 것 같다.
아마도 이건 굉장히 빠른 싸이클로 프로젝트를 진행하는 우리 팀 성격도 기인했다고 볼 수 있다.&lt;/p&gt;
&lt;p&gt;또 하나 재택근무 특성상 특별히 자리를 뜰 일이 거의 없기 때문에 활동량이 급격히 줄었다.
그래서 재택근무 2주 만에는 무릎이 나가는 부상이 생겨 물리치료도 받았다.
저녁에 운동을 하기에는 업무 종료 시간이 들쭉날쭉하고 야근도 많아 쉽지 않았기에 아침에 운동하는 새로운 도전을 했다.&lt;/p&gt;
&lt;p&gt;집 근처 한강에서 아침 운동을 하니 세상 그렇게 뿌듯하고 자기 만족도도 매우 높아졌다. 놀라운 건 아침에 운동을 하는 사람이 정말 많아 많은 자극이 됐다.
물리치료를 병행하면서 업무 중간 중간 의식적으로 스트레칭을 하면서 몸을 풀려고 했고, 점심시간은 정해진 시간에 규칙적으로 휴식을 취하려고 노력했다.&lt;/p&gt;
&lt;p&gt;하지만 점점 많아지는 일 때문에 이런 호사는 얼마 누리지 못했다.
계속되는 야근에 새벽까지 일하는 경우는 많아졌고 아침에 눈을 뜨자마자 책상으로 출근해서 일을 하다 늦으면 오후 3~4시에 첫끼를 먹으러 자리를 뜨기도 했다.
프로젝트는 계속되고 장애 발생하니 쉴틈이 없었다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;그렇게 내 상반기는 업무만 하다 끝이 났다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;올드보이처럼 갇혀서 일만했고, 번아웃이 온 것 같고 많이 지쳤다.&lt;br&gt;
보이지 않는 곳에서 더 많은 일을 하니 상실감과 박탈감이 더 크다.&lt;br&gt;
물론 우리가 일을 하는 목적은 보여주고자 하는 것은 아니지만, 팀원들이 서로의 상태를 체크할 수 없다는 것은 협업을 함에 있어서 큰 문제 요소가 될 수 있다.
당연히 초과 근무 진행에 대해 팀내 공유는 하지만 옆에서 직접 눈으로 보는 것과 구두 전달은 엄연히 체감정도가 다를 수 밖에 없다.&lt;br&gt;
이 같은 상황을 팀원 대부분 겪고 있었고 이 점에 대해 많은 시간을 들여 함께 고민하고 점진적 해결 방안을 모색하는 시간을 가졌다.&lt;/p&gt;
&lt;h2&gt;장기 재택근무에 대비하기 위해 장비 구매&lt;/h2&gt;
&lt;p&gt;집에서 근무하는 시간이 많으니 의자도 새로 구매가 필요했다.&lt;br&gt;
그 전까지는 책상에 장시간 자주 앉지 않아 그닥 불편하지 않았는데 무릎 한 번 고장나니 좀 더 좋은 의자가 필요했다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_025_001.png&quot; alt=&quot;시디즈 T50 Air&quot;&gt;&lt;/p&gt;
&lt;p&gt;여러 제품을 알아보다 회사 의자도 시디즈여서 큰 고민없이 브랜드는 시디즈로 정했다. 코로나 이전 회사에서는 많은 시간 앉아있었지만 불편함을 전혀 느끼지 못했기에 시디즈 정도면 괜찮다고 생각했다. 매장에서 여러 의자를 앉아보고 &lt;a href=&quot;https://coupa.ng/bFuLnJ&quot;&gt;시디즈 T50 Air&lt;/a&gt;으로 결정했다.&lt;/p&gt;
&lt;p&gt;의자 판이 앞뒤 위치 조절이 되고, 틸팅 기능, 매쉬 소재로 이뤄져 괜찮은 의자다. 가끔 일하다 잠깐 쉬려고 의자를 뒤로 최대로 누우면 해먹에 누운 기분이라 스스륵 잠이 들때도 있다.&lt;br&gt;
적당한 가격에 의자를 찾고 있다면 &lt;a href=&quot;https://coupa.ng/bFuLnJ&quot;&gt;시디즈 T50 Air&lt;/a&gt; 추천한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/basic/001.png&quot; alt=&quot;필코 마제스터치2 텐키리스 흑축&quot;&gt;&lt;/p&gt;
&lt;p&gt;마지막으로 &lt;strong&gt;무접점 키보드&lt;/strong&gt;에 입문했다. 회사랑 집에서 둘다 필코 마제스터치2를 사용중이다. 다만 회사는 텐키리스이고 집은 스탠다드로 스탠다드는 마우스를 사용할 때 거리가 더 길어지고 자세가 점점 틀어지기 시작했다. 키보드도 집에선 자주 사용하진 않았으니 크게 불편함이 없었지만 집에서 장시간 사용하면서 스탠다드가 잘못된 자세를 초래하고 이렇게 장시간 사용하면 어깨나 허리에도 안좋은 영향을 줄것이라 직감했다.&lt;/p&gt;
&lt;p&gt;그래서 텐키리스 키보드를 알아보다가 이번에는 무접점에 다시 도전해보고 싶어 &lt;a href=&quot;https://coupa.ng/bFuQEA&quot;&gt;한성컴퓨터 GK888B minicoup&lt;/a&gt;을 추천받았다.
기존에 해피해킹을 구매한 적이 있는데, 무접점 방식 키감은 정말 마음에 쏙 들었지만 Vim에 맞춰진 키배열은 내게 그야말로 혼돈의 카오스였다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_025_003.png&quot; alt=&quot;화려한 키캡이 나를 감싸줘야 함&quot;&gt;&lt;br&gt;
또한 무접점은 키캡 놀이하기 쉽지 않아 화려한 키캡이 나를 감싸줘야 하는데 그렇지 못해 매우 아쉬운 점이 있어 해피해킹 이후 무접점을 시도하진 않았다.
반면 요즘 나오는 다양한 무접점 키보드들이 기계식 키보드 키캡과 호환이 가능하도록 나와서 키캡놀이도 가능하다.&lt;/p&gt;
&lt;p&gt;그래서 &lt;a href=&quot;https://coupa.ng/bFuQEA&quot;&gt;한성컴퓨터 GK888B minicoup&lt;/a&gt;을 구매했는데 미니 키 배열이라 방향키가 정말 빌런이었다.
코딩할 땐 최악이어서 생산성이 떨어질 정도였다. 또한 뽑기를 잘못했는지 유선 입력 상태에서도 키입력 딜레이가 있었다.&lt;/p&gt;
&lt;p&gt;다음에 구매한 건 콕스 엔데버였다. 콕스 엔데버와 항상 함께 비교되는 제품은 앱코 v2이다.
콕스 엔데버를 먼저 만나 사용해봤더니 정말 마음에 들었다. 하지만 한가지.. 콕스 엔데버는 맥북 카라바이너에서 Fn키 맵핑이 되지 않는다.
다른 유저에게는 별거 아닐 수 있지만 개인 설정에 부합하지 못해 콕스 엔데버는 탈락했다.&lt;/p&gt;
&lt;p&gt;이후 다시 돌아 한성으로 왔고 앱코를 선택하지 않고 다시 한성을 고른 이유는 블루투스 기능때문이었다.
무선은 책상을 쾌적하게 만들어주어 매력적인 포인트라 생각했고 다시 한 번 뽑기 운을 믿어 보기로 해서 &lt;a href=&quot;https://coupa.ng/bFuQ6J&quot;&gt;87key 배열의 GK893B&lt;/a&gt;로 선택했다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_025_002.png&quot; alt=&quot;한성컴퓨터 무접점 GK893B&quot;&gt;&lt;/p&gt;
&lt;p&gt;뽑기는 대 성공이었고 키 딜레이 없이 잘 사용하고 있다. 키 배열도 마음에 들고 텐키리스여서 어깨와 자세 부담도 사라졌다. 또한 기계식과 다르게 보글보글한 키감은 정말 기분이 좋다.
저렴한 가격에 무접점을 입문해보고 싶다면 한성, 콕스, 앱코 중에서 개인 취향에 맞는 제품을 구매하면 된다. 나는 좀 더 사용해보다 리얼포스나 레오폴드로 업글하려고 한다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;물론 일은 여전히 많고 여전히 바쁠 예정이다.&lt;br&gt;
하지만 하반기에는 여러가지 변화를 꾀하려고 한다. 그래서 다음 회고에는 새로운 변화를 이야기해볼 수 있으면 좋겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[비슷해보이지만 다른 두 친구를 소개합니다. Authentication vs Authorization]]></title><description><![CDATA[<p>내외부 관련된 서비스를 런칭하거나 기능을 추가할때 같이 논의되는 <strong>Auth</strong>에 대해 들어보셨을텐데요,<br>
보통 Auth라고 하면 Authentication을 말하거나 Authentication + Authorization를 통칭합니다.<br>
윗줄에 구분지어 분리를 해놓은 거 보니 다른 것 같긴한데 과연 무엇이 어떻게 다를까요?</p>
<p>각각을 한 단어로 바꿔 표현해보겠습니다.</p>
<ul>
<li><code>Authentication : 로그인</code></li>
<li><code>Authorization : 권한</code></li>
</ul>
<p>한 단어로 표현하니 확실히 더 쉽게 이해가 됩니다.
웹앱의 관점에서 볼 때 Authentication(인증)은 로그인 자격 증명을 확인하여 로그인 한 사용자를 인식하는 것이며,
Authorization(권한 부여)는 액세스 제어로 사용자가 읽기, 수정, 삭제를 허용하는지 여부를 확인하는 것입니다.
<strong>권한 부여는 사용자의 신원이 성공적으로 인증 된 후에 발생합니다.</strong> 
그럼 인증과 권한 부여, 이 둘에 대해 좀 더 자세히 살펴보겠습니다.</p>
<h2>Authentication / 인증</h2>
<ul>
<li><code>로그인과 같이 사용자 또는 프로세스의 신원을 확인하는 프로세스</code></li>
<li>인증에 사용하기 위해 제공하는 데이터(자격 증명)는 이미 저장된 데이터와 비교함</li>
<li>이 데이터는 인증 서버에 저장되며, 가장 일반적인 인증 방법은 비밀번호를 사용하는 것</li>
<li>인증에서는 비밀번호 기반 인증, SSO, API 인증, Barcode 인증, 생체 인증 등이 있음</li>
<li>줄여서 <strong>AuthN</strong>이라고도 함</li>
</ul>
<h2>Authentication Factors</h2>
<table>
<thead>
<tr>
<th>Factor의 구분</th>
<th>설명</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr>
<td>지식기반</td>
<td>사용자만 알고 있는 것</td>
<td>패스워드, 이름, 주민번호, 사번 등</td>
</tr>
<tr>
<td>소유기반</td>
<td>사용만 소유하고 있는 것</td>
<td>인증서, OTP, 휴대폰 SMS인증, USB토큰 등</td>
</tr>
<tr>
<td>속성기반</td>
<td>생체기반으로 사용자만의 고유 속성</td>
<td>지문, 홍채, 정맥, 얼굴, 행동양식 등</td>
</tr>
</tbody>
</table>
<ul>
<li>One Factor 인증 : 위 3가지 인증 요소 중 1가지만으로 인증</li>
<li>Two Factor 인증 : 위 3가지 인증 요소 중 2가지의 인증 조합</li>
<li><strong>동일 factor의 두 가지 인증은 Two Factor 인증이 아님</strong></li>
</ul>
<p><img src="https://baek.dev/assets/images/post/2020/2020_024_002.jpg" alt="MFA"></p>
<h2>Authentication Techniques</h2>
<ul>
<li>
<p>비밀번호 기반 인증</p>
<ul>
<li>사용자의 신원을 확인하기 위해 비밀번호가 필요</li>
<li>사용자는 먼저 이메일 주소 및 비밀번호와 같은 필요한 세부 사항을 제공하여 계정을 작성한 뒤 액세스</li>
</ul>
</li>
<li>
<p>비밀번호없는 인증</p>
<ul>
<li>사용자는 매직 링크 또는 이메일 또는 문자 메시지를 통해 전달 된 OTP를 통해 로그인</li>
</ul>
</li>
<li>
<p>2FA(Two Factor Authentication) / MFA(Multi Factor Authentication)</p>
<ul>
<li>2 단계 또는 다중 요소 인증을 사용하여 추가 보안 계층을 강화 및 유연한 인증</li>
</ul>
</li>
<li>
<p>Single Sign On</p>
<ul>
<li>SSO를 통해 사용자는 단일 자격 증명 세트로 여러 응용 프로그램에 액세스 할 수 있음</li>
<li>한 번의 시스템 인증을 통해 다양한 정보시스템에 재인증없이 접근할 수 있도록 개발된 방식</li>
</ul>
</li>
<li>
<p>Social Authentication</p>
<ul>
<li>소셜 네트워킹 플랫폼의 기존 자격 증명으로 확인하고 인증</li>
<li>이 방법은 Facebook, Twitter, Google 등과 같은 소셜 네트워킹 플랫폼의 기존 자격 증명을 사용하여 사용자를 식별함</li>
</ul>
</li>
<li>
<p>API Authentication</p>
<ul>
<li>API 인증은 서버에서 서비스에 액세스하려는 사용자 식별을 인증하는 프로세스</li>
<li>API Key / Token</li>
</ul>
</li>
<li>
<p>생체인증</p>
<ul>
<li>신원을 확인하기 위해 개인의 독특한 생물학적 특징의 사용을 포함</li>
<li>사용자의 생체 데이터가 캡처되어 데이터베이스에 저장된 후 사용자 인증을 확인하기 위해 비교</li>
<li>홍채, 지문, 얼굴, 행동 인식등이 있음</li>
</ul>
</li>
</ul>
<p><img src="https://baek.dev/assets/images/post/2020/2020_024_003.jpg" alt="AuthN vs AuthZ"></p>
<h2>Authorization / 권한부여</h2>
<ul>
<li>
<p><code>권한부여는 누가 무엇을 할 수 있는지 결정하는 규칙</code></p>
<ul>
<li>파일, 데이터 등과 같은 시스템 리소스에 대한 액세스 수준을 결정하는 데 사용되는 보안 메커니즘</li>
<li>예로 DBA는 데이터베이스 작성 및 삭제 권한이있는 반면 Software Engineer는 읽기 및 쓰기 권한만 주어짐</li>
</ul>
</li>
<li>기본적으로 개인에게 조직의 기밀 리소스에 대한 부분 또는 전체 액세스 권한이 부여되는 프로세스</li>
<li>기술에는 역할 기반 액세스 제어, JSON 웹 토큰, SAML, OpenID 권한 부여, 0Auth 등이 있음</li>
<li>줄여서 <strong>AuthZ</strong>라고도 함</li>
</ul>
<h2>Authorization Techniques</h2>
<ul>
<li>
<p>API keys</p>
<ul>
<li>이 방법은 인증 및 권한 부여에도 사용됨</li>
<li>사용자가 등록 중에 시스템에 대한 인증 된 액세스 권한을 얻으려고하면 API key를 생성 받아 사용함</li>
<li>API Key는 일반적으로 요청의 URL 또는 헤더에 포함하는 긴 문자열</li>
<li>API 키는 주로 API를 호출하는 사람을 식별하는 수단으로 사용</li>
<li>이 방법은 AuthN 및 Authz 모두에서 사용</li>
<li>시스템-시스템 및 사용자-시스템 권한 관리를 위해 RBAC ( 역할 기반 액세스 제어 )를 구현할 수 있음</li>
</ul>
</li>
<li>
<p>HMAC (Hash-Based Message Authentication Code)</p>
<ul>
<li>암호화에서 HMAC은 암호화 해시 기능과 비밀 암호화 키를 포함하는 특정 유형의 메시지 인증 코드</li>
<li>다른 MAC(Message Authentication Code)과 마찬가지로 데이터 무결성과 메시지의 신뢰성을 동시에 확인하는 데 사용될 수 있음</li>
</ul>
</li>
<li>
<p>JWT / JSON Web Token</p>
<ul>
<li>JWT는 당사자간에 안전하게 데이터를 전송하기위한 공개 표준이며 사용자는 공개 / 개인 키 쌍을 사용하여 권한을 부여받음</li>
</ul>
</li>
<li>
<p>SAML / Security Assurance Markup Language</p>
<ul>
<li>디지털 서명 된 XML 문서를 통해 인증 정보를 교환하는 표준 싱글 사인온 형식 (SSO)</li>
<li>서비스 공급자와 아이덴티티 공급자라는 두 엔터티 간의 XML 기반 인증 및 권한 부여 시스템</li>
</ul>
</li>
<li>
<p>OpenID</p>
<ul>
<li>인증 서버의 인증을 기반으로 사용자 신원을 확인하게 Authentication에 더 가까움</li>
<li>이를 통해 클라이언트는 Authorization Server의 인증을 기반으로 최종 사용자 ID를 확인할 수 있을뿐만 아니라</li>
<li>최종 사용자에 대한 상호 운용 가능하고 REST와 유사한 기본 프로파일 정보를 얻을 수 있음</li>
</ul>
</li>
<li>
<p>OAuth</p>
<ul>
<li>인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있는 공통적인 수단으로서 사용 접근 위임을 위한 개방형 표준</li>
<li>이 매커니즘은 여러 기업들에 의해 사용되는데, 이를테면 아마존, 구글, 페이스북, 마이크로소프트, 트위터가 있으며 사용자들이 타사 애플리케이션이나 웹사이트의 계정에 관한 정보를 공유할 수 있게 허용</li>
</ul>
</li>
</ul>
<h3>마무리</h3>
<p>Auth란 무엇인지 이번 글을 통해 인증과 권한 부여 대해 그림이 그려봤고, 각 인증 방법들을 어떻게 사용햘 수 있을지 알아보았습니다.<br>
그럼 요약 정리하면서 함께 읽으시면 도움 될 글들 소개하며 마무리하겠습니다.</p>
<table>
<thead>
<tr>
<th>항목</th>
<th>Authentication</th>
<th>Authorization</th>
</tr>
</thead>
<tbody>
<tr>
<td>정의</td>
<td>사용자의 신원 확인</td>
<td>액세스 권한 확인</td>
</tr>
<tr>
<td>목적</td>
<td>자신이 누구인지 확인하도록 사용자를 확인</td>
<td>사용자에게 특정 리소스에 대한 액세스 권한이 있는지 확인</td>
</tr>
<tr>
<td>방법</td>
<td>사용자 이름, 망막 스캔, 얼굴 인식 등과 같은 요소를 통해 사용자를 식별</td>
<td>미리 지정된 규칙을 통해 리소스에 엑세스 할 수 있는 사용자의 권한을 확인</td>
</tr>
<tr>
<td>순서</td>
<td>AuthZ전에 수행</td>
<td>AuthN 후에 수행</td>
</tr>
</tbody>
</table>
<p><strong>함께 읽으면 좋은 글들</strong></p>
<ul>
<li><a href="https://bcho.tistory.com/955">REST API의 이해와 설계-#3 API 보안</a></li>
<li><a href="https://www.slideshare.net/tebica/oauth-api-13721761">OAuth 를 자세하고 쉽게 요약 설명한 기획자를 위한 OAuth</a></li>
<li><a href="https://cheese10yun.github.io/spring-oauth2-provider/">Spring Project에 적용해보는 Spring OAuth2 Provider 정리</a></li>
<li><a href="https://d2.naver.com/helloworld/24942">OAuth와 춤을 - Naver D2</a></li>
</ul>
<hr>
<p>Reference</p>
<ul>
<li><a href="https://www.loginradius.com/blog/2020/06/authentication-vs-authorization-infographic/">https://www.loginradius.com/blog/2020/06/authentication-vs-authorization-infographic/</a></li>
<li><a href="https://dev.to/caffiendkitten/authentication-vs-authorization-25lc">https://dev.to/caffiendkitten/authentication-vs-authorization-25lc</a></li>
</ul>]]></description><link>https://baek.dev/post/24/</link><guid isPermaLink="false">https://baek.dev/post/24/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 21 Jun 2020 14:08:00 GMT</pubDate><content:encoded>&lt;p&gt;내외부 관련된 서비스를 런칭하거나 기능을 추가할때 같이 논의되는 &lt;strong&gt;Auth&lt;/strong&gt;에 대해 들어보셨을텐데요,&lt;br&gt;
보통 Auth라고 하면 Authentication을 말하거나 Authentication + Authorization를 통칭합니다.&lt;br&gt;
윗줄에 구분지어 분리를 해놓은 거 보니 다른 것 같긴한데 과연 무엇이 어떻게 다를까요?&lt;/p&gt;
&lt;p&gt;각각을 한 단어로 바꿔 표현해보겠습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Authentication : 로그인&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Authorization : 권한&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;한 단어로 표현하니 확실히 더 쉽게 이해가 됩니다.
웹앱의 관점에서 볼 때 Authentication(인증)은 로그인 자격 증명을 확인하여 로그인 한 사용자를 인식하는 것이며,
Authorization(권한 부여)는 액세스 제어로 사용자가 읽기, 수정, 삭제를 허용하는지 여부를 확인하는 것입니다.
&lt;strong&gt;권한 부여는 사용자의 신원이 성공적으로 인증 된 후에 발생합니다.&lt;/strong&gt; 
그럼 인증과 권한 부여, 이 둘에 대해 좀 더 자세히 살펴보겠습니다.&lt;/p&gt;
&lt;h2&gt;Authentication / 인증&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;로그인과 같이 사용자 또는 프로세스의 신원을 확인하는 프로세스&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;인증에 사용하기 위해 제공하는 데이터(자격 증명)는 이미 저장된 데이터와 비교함&lt;/li&gt;
&lt;li&gt;이 데이터는 인증 서버에 저장되며, 가장 일반적인 인증 방법은 비밀번호를 사용하는 것&lt;/li&gt;
&lt;li&gt;인증에서는 비밀번호 기반 인증, SSO, API 인증, Barcode 인증, 생체 인증 등이 있음&lt;/li&gt;
&lt;li&gt;줄여서 &lt;strong&gt;AuthN&lt;/strong&gt;이라고도 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Authentication Factors&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Factor의 구분&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;th&gt;예시&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;지식기반&lt;/td&gt;
&lt;td&gt;사용자만 알고 있는 것&lt;/td&gt;
&lt;td&gt;패스워드, 이름, 주민번호, 사번 등&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;소유기반&lt;/td&gt;
&lt;td&gt;사용만 소유하고 있는 것&lt;/td&gt;
&lt;td&gt;인증서, OTP, 휴대폰 SMS인증, USB토큰 등&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;속성기반&lt;/td&gt;
&lt;td&gt;생체기반으로 사용자만의 고유 속성&lt;/td&gt;
&lt;td&gt;지문, 홍채, 정맥, 얼굴, 행동양식 등&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;One Factor 인증 : 위 3가지 인증 요소 중 1가지만으로 인증&lt;/li&gt;
&lt;li&gt;Two Factor 인증 : 위 3가지 인증 요소 중 2가지의 인증 조합&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;동일 factor의 두 가지 인증은 Two Factor 인증이 아님&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_024_002.jpg&quot; alt=&quot;MFA&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Authentication Techniques&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;비밀번호 기반 인증&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용자의 신원을 확인하기 위해 비밀번호가 필요&lt;/li&gt;
&lt;li&gt;사용자는 먼저 이메일 주소 및 비밀번호와 같은 필요한 세부 사항을 제공하여 계정을 작성한 뒤 액세스&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비밀번호없는 인증&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용자는 매직 링크 또는 이메일 또는 문자 메시지를 통해 전달 된 OTP를 통해 로그인&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2FA(Two Factor Authentication) / MFA(Multi Factor Authentication)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2 단계 또는 다중 요소 인증을 사용하여 추가 보안 계층을 강화 및 유연한 인증&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Single Sign On&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SSO를 통해 사용자는 단일 자격 증명 세트로 여러 응용 프로그램에 액세스 할 수 있음&lt;/li&gt;
&lt;li&gt;한 번의 시스템 인증을 통해 다양한 정보시스템에 재인증없이 접근할 수 있도록 개발된 방식&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Social Authentication&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;소셜 네트워킹 플랫폼의 기존 자격 증명으로 확인하고 인증&lt;/li&gt;
&lt;li&gt;이 방법은 Facebook, Twitter, Google 등과 같은 소셜 네트워킹 플랫폼의 기존 자격 증명을 사용하여 사용자를 식별함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;API Authentication&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API 인증은 서버에서 서비스에 액세스하려는 사용자 식별을 인증하는 프로세스&lt;/li&gt;
&lt;li&gt;API Key / Token&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;생체인증&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;신원을 확인하기 위해 개인의 독특한 생물학적 특징의 사용을 포함&lt;/li&gt;
&lt;li&gt;사용자의 생체 데이터가 캡처되어 데이터베이스에 저장된 후 사용자 인증을 확인하기 위해 비교&lt;/li&gt;
&lt;li&gt;홍채, 지문, 얼굴, 행동 인식등이 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_024_003.jpg&quot; alt=&quot;AuthN vs AuthZ&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Authorization / 권한부여&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;권한부여는 누가 무엇을 할 수 있는지 결정하는 규칙&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파일, 데이터 등과 같은 시스템 리소스에 대한 액세스 수준을 결정하는 데 사용되는 보안 메커니즘&lt;/li&gt;
&lt;li&gt;예로 DBA는 데이터베이스 작성 및 삭제 권한이있는 반면 Software Engineer는 읽기 및 쓰기 권한만 주어짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;기본적으로 개인에게 조직의 기밀 리소스에 대한 부분 또는 전체 액세스 권한이 부여되는 프로세스&lt;/li&gt;
&lt;li&gt;기술에는 역할 기반 액세스 제어, JSON 웹 토큰, SAML, OpenID 권한 부여, 0Auth 등이 있음&lt;/li&gt;
&lt;li&gt;줄여서 &lt;strong&gt;AuthZ&lt;/strong&gt;라고도 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Authorization Techniques&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;API keys&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이 방법은 인증 및 권한 부여에도 사용됨&lt;/li&gt;
&lt;li&gt;사용자가 등록 중에 시스템에 대한 인증 된 액세스 권한을 얻으려고하면 API key를 생성 받아 사용함&lt;/li&gt;
&lt;li&gt;API Key는 일반적으로 요청의 URL 또는 헤더에 포함하는 긴 문자열&lt;/li&gt;
&lt;li&gt;API 키는 주로 API를 호출하는 사람을 식별하는 수단으로 사용&lt;/li&gt;
&lt;li&gt;이 방법은 AuthN 및 Authz 모두에서 사용&lt;/li&gt;
&lt;li&gt;시스템-시스템 및 사용자-시스템 권한 관리를 위해 RBAC ( 역할 기반 액세스 제어 )를 구현할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HMAC (Hash-Based Message Authentication Code)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;암호화에서 HMAC은 암호화 해시 기능과 비밀 암호화 키를 포함하는 특정 유형의 메시지 인증 코드&lt;/li&gt;
&lt;li&gt;다른 MAC(Message Authentication Code)과 마찬가지로 데이터 무결성과 메시지의 신뢰성을 동시에 확인하는 데 사용될 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JWT / JSON Web Token&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JWT는 당사자간에 안전하게 데이터를 전송하기위한 공개 표준이며 사용자는 공개 / 개인 키 쌍을 사용하여 권한을 부여받음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SAML / Security Assurance Markup Language&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;디지털 서명 된 XML 문서를 통해 인증 정보를 교환하는 표준 싱글 사인온 형식 (SSO)&lt;/li&gt;
&lt;li&gt;서비스 공급자와 아이덴티티 공급자라는 두 엔터티 간의 XML 기반 인증 및 권한 부여 시스템&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenID&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인증 서버의 인증을 기반으로 사용자 신원을 확인하게 Authentication에 더 가까움&lt;/li&gt;
&lt;li&gt;이를 통해 클라이언트는 Authorization Server의 인증을 기반으로 최종 사용자 ID를 확인할 수 있을뿐만 아니라&lt;/li&gt;
&lt;li&gt;최종 사용자에 대한 상호 운용 가능하고 REST와 유사한 기본 프로파일 정보를 얻을 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OAuth&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있는 공통적인 수단으로서 사용 접근 위임을 위한 개방형 표준&lt;/li&gt;
&lt;li&gt;이 매커니즘은 여러 기업들에 의해 사용되는데, 이를테면 아마존, 구글, 페이스북, 마이크로소프트, 트위터가 있으며 사용자들이 타사 애플리케이션이나 웹사이트의 계정에 관한 정보를 공유할 수 있게 허용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;마무리&lt;/h3&gt;
&lt;p&gt;Auth란 무엇인지 이번 글을 통해 인증과 권한 부여 대해 그림이 그려봤고, 각 인증 방법들을 어떻게 사용햘 수 있을지 알아보았습니다.&lt;br&gt;
그럼 요약 정리하면서 함께 읽으시면 도움 될 글들 소개하며 마무리하겠습니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;항목&lt;/th&gt;
&lt;th&gt;Authentication&lt;/th&gt;
&lt;th&gt;Authorization&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;정의&lt;/td&gt;
&lt;td&gt;사용자의 신원 확인&lt;/td&gt;
&lt;td&gt;액세스 권한 확인&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;목적&lt;/td&gt;
&lt;td&gt;자신이 누구인지 확인하도록 사용자를 확인&lt;/td&gt;
&lt;td&gt;사용자에게 특정 리소스에 대한 액세스 권한이 있는지 확인&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;방법&lt;/td&gt;
&lt;td&gt;사용자 이름, 망막 스캔, 얼굴 인식 등과 같은 요소를 통해 사용자를 식별&lt;/td&gt;
&lt;td&gt;미리 지정된 규칙을 통해 리소스에 엑세스 할 수 있는 사용자의 권한을 확인&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;순서&lt;/td&gt;
&lt;td&gt;AuthZ전에 수행&lt;/td&gt;
&lt;td&gt;AuthN 후에 수행&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;함께 읽으면 좋은 글들&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://bcho.tistory.com/955&quot;&gt;REST API의 이해와 설계-#3 API 보안&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/tebica/oauth-api-13721761&quot;&gt;OAuth 를 자세하고 쉽게 요약 설명한 기획자를 위한 OAuth&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cheese10yun.github.io/spring-oauth2-provider/&quot;&gt;Spring Project에 적용해보는 Spring OAuth2 Provider 정리&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/24942&quot;&gt;OAuth와 춤을 - Naver D2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;Reference&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.loginradius.com/blog/2020/06/authentication-vs-authorization-infographic/&quot;&gt;https://www.loginradius.com/blog/2020/06/authentication-vs-authorization-infographic/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.to/caffiendkitten/authentication-vs-authorization-25lc&quot;&gt;https://dev.to/caffiendkitten/authentication-vs-authorization-25lc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Apache Cassandra에 대해 알아보자]]></title><description><![CDATA[<h2>Apache Cassandra</h2>
<p><code>Apache Cassandra는 대규모로 확장 가능한 분산 NoSQL DB</code>로 Facebook 내부에서 시작하여 오픈소스로 출시되었습니다.</p>
<ul>
<li>아파치 카산드라는 다운 타임 없이 지속적인 가용성과 <strong>고성능 및 선형 확장성</strong>을 제공합니다.</li>
<li>데이터 센터와 지역에 걸쳐 단순하고 손쉬운 복제, 페타 바이트 규모의 정보와 초당 수천 건의 동시 작업을 처리 할 수 있는 카산드라는 하이브리드 클라우드<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 환경에서 대량의 데이터를 관리 할 수 있습니다.</li>
<li>성능 저하없이 확장성과 고 가용성이 필요한 경우 여러 데이터 센터와 클라우드에서 대량의 정형, 반 정형 및 비정형 데이터를 관리 할 수있는 올바른 선택입니다.</li>
<li><strong>단일 장애 지점없이</strong> 많은 상용 서버에서 지속적인 가용성, 선형 확장 성 및 운영 단순성을 제공합니다.</li>
<li>데이터 모델은 로그 구조 업데이트의 성능, 비정규 화 및 구체화 된 뷰에 대한 강력한 지원 및 강력한 내장 캐싱을 통해 컬럼 인덱스의 편의성을 제공합니다.</li>
</ul>
<h2>카산드라의 주요 기능 및 장단점</h2>
<h3>Masterless</h3>
<h4>Master-Slave</h4>
<ul>
<li>전통적인 데이터베이스의 대부분은 마스터-슬레이브라고 하는 기능을 갖추고 있음</li>
<li>이러한 구성에서는 단일 노드가 마스터로 지정되어 읽기 및 쓰기 작업을 수행 할 수 있고</li>
<li>나머지 노드는 슬레이브 역할을 하며 읽기 작업만 수행할 수 있음</li>
<li>
<p>마스터-슬레이브 단점</p>
<ul>
<li>지연은 특히 분산됨 팀의 주요 문제가 될 수 있음</li>
<li>응용 프로그램을 확장해야 할 경우 비용이 크게 상승 할 수 있음</li>
<li>가용성마저 저하 될 수 있음</li>
<li>마스터 노드에 장애가 발생하면 관리자가 새 마스터를 지정할 때까지 데이터베이스 작업이 중지 될 수 있음</li>
</ul>
</li>
</ul>
<h4>Masterless</h4>
<ul>
<li>마스터리스 아키텍처로 구축 된 Apache Cassandra는 위와 같은 단점이 없음</li>
<li>데이터 복제를 담당하는 단일 노드가 없고 모든 노드가 동일함</li>
<li>
<p>링 또는 데이터베이스 클러스터에 참여하는 모든 노드에 자동으로 데이터 분재를 제공</p>
<ul>
<li>데이터는 모든 노드에서 투명하게 분할되므로 개발자나 관리자가 클러스터 전체에 데이터를 배포하기 위해 프로그래밍 하지 않아도 됨</li>
</ul>
</li>
<li>대신 모든 노드가 읽기 및 쓰기 작업을 수행</li>
<li>성능이 향상되고 데이터베이스에 복원력이 추가 됨</li>
</ul>
<h3>확장성</h3>
<p>기존 환경에서 응용 프로그램의 확장은 대개 시간이 많이 걸리고 비용이 많이 드는 프로세스이며 일반적으로 확장을 통해 수행됩니다. 반면 Cassandra를 사용하면 클러스터에 노드를 추가하기 만하면 용량을 선형으로 늘릴 수 있습니다. 예를 들어, 2 개의 노드가 초당 100,000 개의 트랜잭션을 처리 할 수있는 경우 8 개의 노드가 초당 400,000 개의 트랜잭션을 처리 할 수 ​​있습니다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_023_001.png" alt="선형 확장이 가능한 카산드라"></p>
<h3>고 가용성 및 내 결함성</h3>
<p>모든 Cassandra 노드는 읽기 및 쓰기 작업을 수행 할 수 있으므로 데이터가 빠르게 복제 하이브리드 클라우드 환경 및 지역, 노드에 장애가 발생하면 사용자는 가장 가까운 정상 노드로 자동 라우팅됩니다.
심지어 장애가 발생하더라도 응용 프로그램이 설계된대로 작동하기 때문에 노드가 오프라인 상태가 된 것을 알지 못합니다.</p>
<p>결과적으로 응용 프로그램을 항상 사용할 수 있으며 데이터에 항상 액세스 할 수 있으며 손실되지 않는다. 또한 Cassandra는 수동 수리없이 문제가 발생한 직후 문제를 실제로 해결할 수있는 기본 제공 수리 서비스를 제공합니다. 노드가 고장 나더라도 생산성을 높이지 않아도 됩니다.</p>
<h3>고성능</h3>
<p>함께 찍은 카산드라의 마스터리스 아키텍처 기본적으로 분산 된 데이터 복제는 트랜잭션에 포함 된 데이터의 양에 관계없이 대규모로 고성능을 제공합니다. 직원은 위치에 상관없이 생산성을 유지할 수있을뿐만 아니라, 직원 수와 동시에 사용하는 사람들도 앱과 상호 작용하는 긍정적인 경험을 누릴 수 있습니다.</p>
<h3>단점</h3>
<ul>
<li>Join이나 Transaction을 지원하지 않음</li>
<li>Index 등의 검색을 위한 기능도 매우 단출</li>
<li>RDBMS와 같은 Paging을 구현하는 것이 힘들고 Keyspace나 Table 등을 과도하게 생성할 경우 Memory Overflow가 발생할 수 있음</li>
</ul>
<h3>Apache Cassandra vs 기존 관계형 데이터베이스</h3>
<table>
<thead>
<tr>
<th>관계형 데이터베이스</th>
<th>카산드라</th>
</tr>
</thead>
<tbody>
<tr>
<td>적당한 수신 데이터 속도 처리</td>
<td>높은 수신 데이터 속도 처리</td>
</tr>
<tr>
<td>복잡하고 중첩 된 거래 지원</td>
<td>간단한 거래 지원</td>
</tr>
<tr>
<td>장애 조치를 통한 단일 장애 지점</td>
<td>단일 실패 지점이 없고 지속적인 가동 시간</td>
</tr>
<tr>
<td>중간 규모의 데이터 볼륨 지원</td>
<td>매우 높은 데이터 볼륨 지원</td>
</tr>
<tr>
<td>중앙 집중식 배포</td>
<td>분산 배치</td>
</tr>
<tr>
<td>주로 한 위치에 기록 된 데이터</td>
<td>여러 위치에서 작성된 데이터</td>
</tr>
<tr>
<td>읽기 확장 성 지원 (일관성 희생)</td>
<td>읽기 및 쓰기 확장 성 지원</td>
</tr>
<tr>
<td>수직 확장 방식으로 배포</td>
<td>수평 확장 방식으로 배포</td>
</tr>
</tbody>
</table>
<h2>데이터 모델</h2>
<h3>내부 데이터 구조</h3>
<p>카산드라 데이터 모델은 스키마 선택적 열 지향 데이터 모델입니다.<br>
즉, 관계형 데이터베이스와 달리 각 행에 동일한 열 집합이 없어도되므로 <code>응용 프로그램에 필요한 모든 열을 미리 모델링할 필요가 없습니다.</code><br>
카산드라 데이터 모델은 키 스페이스(데이터베이스와 유사), 열 패밀리(관계형 모델의 테이블과 유사), 키와 열로 구성됩니다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_023_002.jpg"></p>
<p>각 열 계열에 대해 관계형 테이블을 생각하지 마세요. 대신 중첩 된 맵 데이터 구조를 생각하세요. 중첩 정렬 맵은 관계형 테이블보다 더 정확하며 카산드라 데이터 모델에 대한 올바른 결정을 내리는데 도움이 됩니다.</p>
<!-- <script src="https://gist.github.com/baekdev/a4a38c65e70f7b51b72dc298baa93f4b.js"></script> -->
<pre><code class="language-java">Map&#x3C;RowKey, SortedMap&#x3C;ColumnKey, ColumnValue>>
</code></pre>
<p>맵은 효율적인 키 조회를 제공하고 정렬 된 특성은 효율적인 스캔을 제공합니다.
카산드라에서는 행 키와 열 키를 사용하여 효율적인 조회 및 범위 검색을 수행 할 수 있습니다.
열 키의 수는 제한이 없습니다. 즉, 넓은 행을 가질 수 있습니다.
키 자체는 키 이름의 일부로 값을 보유 할 수 있습니다. 즉, 값이없는 열을 가질 수 있습니다.</p>
<h3>CQL</h3>
<p>카산드라는 SQL과 유사한 CQL (Cassandra Query Language)를 사용합니다. SQL과 마찬가지로 명령문은 데이터를 변경하거나, 데이터를 검색하거나, 데이터를 저장하거나, 데이터가 저장되는 방식을 변경합니다.</p>
<!-- <script src="https://gist.github.com/baekdev/9176790bff80bf2fa7f2d2fe9004a13b.js"></script> -->
<pre><code class="language-sql">SELECT * FROM MyTable;

UPDATE MyTable
  SET SomeColumn = 'Some Value'
  WHERE columnName = 'Something Else';
</code></pre>
<p>CQL을 사용하여 작성된 키 공간, 열 및 테이블 이름은 큰 따옴표로 묶지 않으면 대소문자를 구분하지 않습니다. 대문자를 사용하여 이러한 객체의 이름을 입력하면 카산드라는 이름을 소문자로 저장합니다. 큰 따옴표를 사용하여 케이스를 강제 실행할 수 있습니다.</p>
<!-- <script src="https://gist.github.com/baekdev/a43ba9f71f4a7d0a540d3c50add0f94c.js"></script> -->
<pre><code class="language-sql">CREATE TABLE test (
  Foo int PRIMARY KEY,
  "Bar" int
);
</code></pre>
<ul>
<li><a href="https://docs.datastax.com/en/dse/6.8/cql/cql/cql_reference/refDataTypes.html" target="_blank">CQL Data types</a></li>
</ul>
<h3>마무리</h3>
<p>오늘은 카산드라가 무엇인지 간략히 알아봤습니다.<br>
다음에는 카산드라 인덱스와 데이터 복제, 동시성 등에 대해 알아보겠습니다.</p>
<hr>
<p>참고</p>
<ul>
<li><a href="https://www.datastax.com/resources/definitions/what-is-apache-cassandra" target="_blank">What is Apache Cassandra</a></li>
<li><a href="https://teddyma.gitbooks.io/learncassandra/" target="_blank">Learn Cassandra</a></li>
<li><a href="https://meetup.toast.com/posts/58" target="_blank">Apache Cassandra 톺아보기</a></li>
</ul>
<div class="footnotes">
<hr>
<ol>
<li id="fn-1">
<p>하이브리드 클라우드란 둘 이상의 퍼블릭 클라우드와 프라이빗 클라우드를 환경이 조합된 것</p>
<a href="#fnref-1" class="footnote-backref">↩</a>
</li>
</ol>
</div>]]></description><link>https://baek.dev/post/23/</link><guid isPermaLink="false">https://baek.dev/post/23/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 10 May 2020 13:12:00 GMT</pubDate><content:encoded>&lt;h2&gt;Apache Cassandra&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Apache Cassandra는 대규모로 확장 가능한 분산 NoSQL DB&lt;/code&gt;로 Facebook 내부에서 시작하여 오픈소스로 출시되었습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;아파치 카산드라는 다운 타임 없이 지속적인 가용성과 &lt;strong&gt;고성능 및 선형 확장성&lt;/strong&gt;을 제공합니다.&lt;/li&gt;
&lt;li&gt;데이터 센터와 지역에 걸쳐 단순하고 손쉬운 복제, 페타 바이트 규모의 정보와 초당 수천 건의 동시 작업을 처리 할 수 있는 카산드라는 하이브리드 클라우드&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 환경에서 대량의 데이터를 관리 할 수 있습니다.&lt;/li&gt;
&lt;li&gt;성능 저하없이 확장성과 고 가용성이 필요한 경우 여러 데이터 센터와 클라우드에서 대량의 정형, 반 정형 및 비정형 데이터를 관리 할 수있는 올바른 선택입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;단일 장애 지점없이&lt;/strong&gt; 많은 상용 서버에서 지속적인 가용성, 선형 확장 성 및 운영 단순성을 제공합니다.&lt;/li&gt;
&lt;li&gt;데이터 모델은 로그 구조 업데이트의 성능, 비정규 화 및 구체화 된 뷰에 대한 강력한 지원 및 강력한 내장 캐싱을 통해 컬럼 인덱스의 편의성을 제공합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;카산드라의 주요 기능 및 장단점&lt;/h2&gt;
&lt;h3&gt;Masterless&lt;/h3&gt;
&lt;h4&gt;Master-Slave&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;전통적인 데이터베이스의 대부분은 마스터-슬레이브라고 하는 기능을 갖추고 있음&lt;/li&gt;
&lt;li&gt;이러한 구성에서는 단일 노드가 마스터로 지정되어 읽기 및 쓰기 작업을 수행 할 수 있고&lt;/li&gt;
&lt;li&gt;나머지 노드는 슬레이브 역할을 하며 읽기 작업만 수행할 수 있음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;마스터-슬레이브 단점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;지연은 특히 분산됨 팀의 주요 문제가 될 수 있음&lt;/li&gt;
&lt;li&gt;응용 프로그램을 확장해야 할 경우 비용이 크게 상승 할 수 있음&lt;/li&gt;
&lt;li&gt;가용성마저 저하 될 수 있음&lt;/li&gt;
&lt;li&gt;마스터 노드에 장애가 발생하면 관리자가 새 마스터를 지정할 때까지 데이터베이스 작업이 중지 될 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Masterless&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;마스터리스 아키텍처로 구축 된 Apache Cassandra는 위와 같은 단점이 없음&lt;/li&gt;
&lt;li&gt;데이터 복제를 담당하는 단일 노드가 없고 모든 노드가 동일함&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;링 또는 데이터베이스 클러스터에 참여하는 모든 노드에 자동으로 데이터 분재를 제공&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터는 모든 노드에서 투명하게 분할되므로 개발자나 관리자가 클러스터 전체에 데이터를 배포하기 위해 프로그래밍 하지 않아도 됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;대신 모든 노드가 읽기 및 쓰기 작업을 수행&lt;/li&gt;
&lt;li&gt;성능이 향상되고 데이터베이스에 복원력이 추가 됨&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;확장성&lt;/h3&gt;
&lt;p&gt;기존 환경에서 응용 프로그램의 확장은 대개 시간이 많이 걸리고 비용이 많이 드는 프로세스이며 일반적으로 확장을 통해 수행됩니다. 반면 Cassandra를 사용하면 클러스터에 노드를 추가하기 만하면 용량을 선형으로 늘릴 수 있습니다. 예를 들어, 2 개의 노드가 초당 100,000 개의 트랜잭션을 처리 할 수있는 경우 8 개의 노드가 초당 400,000 개의 트랜잭션을 처리 할 수 ​​있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_023_001.png&quot; alt=&quot;선형 확장이 가능한 카산드라&quot;&gt;&lt;/p&gt;
&lt;h3&gt;고 가용성 및 내 결함성&lt;/h3&gt;
&lt;p&gt;모든 Cassandra 노드는 읽기 및 쓰기 작업을 수행 할 수 있으므로 데이터가 빠르게 복제 하이브리드 클라우드 환경 및 지역, 노드에 장애가 발생하면 사용자는 가장 가까운 정상 노드로 자동 라우팅됩니다.
심지어 장애가 발생하더라도 응용 프로그램이 설계된대로 작동하기 때문에 노드가 오프라인 상태가 된 것을 알지 못합니다.&lt;/p&gt;
&lt;p&gt;결과적으로 응용 프로그램을 항상 사용할 수 있으며 데이터에 항상 액세스 할 수 있으며 손실되지 않는다. 또한 Cassandra는 수동 수리없이 문제가 발생한 직후 문제를 실제로 해결할 수있는 기본 제공 수리 서비스를 제공합니다. 노드가 고장 나더라도 생산성을 높이지 않아도 됩니다.&lt;/p&gt;
&lt;h3&gt;고성능&lt;/h3&gt;
&lt;p&gt;함께 찍은 카산드라의 마스터리스 아키텍처 기본적으로 분산 된 데이터 복제는 트랜잭션에 포함 된 데이터의 양에 관계없이 대규모로 고성능을 제공합니다. 직원은 위치에 상관없이 생산성을 유지할 수있을뿐만 아니라, 직원 수와 동시에 사용하는 사람들도 앱과 상호 작용하는 긍정적인 경험을 누릴 수 있습니다.&lt;/p&gt;
&lt;h3&gt;단점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Join이나 Transaction을 지원하지 않음&lt;/li&gt;
&lt;li&gt;Index 등의 검색을 위한 기능도 매우 단출&lt;/li&gt;
&lt;li&gt;RDBMS와 같은 Paging을 구현하는 것이 힘들고 Keyspace나 Table 등을 과도하게 생성할 경우 Memory Overflow가 발생할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Apache Cassandra vs 기존 관계형 데이터베이스&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;관계형 데이터베이스&lt;/th&gt;
&lt;th&gt;카산드라&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;적당한 수신 데이터 속도 처리&lt;/td&gt;
&lt;td&gt;높은 수신 데이터 속도 처리&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;복잡하고 중첩 된 거래 지원&lt;/td&gt;
&lt;td&gt;간단한 거래 지원&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;장애 조치를 통한 단일 장애 지점&lt;/td&gt;
&lt;td&gt;단일 실패 지점이 없고 지속적인 가동 시간&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;중간 규모의 데이터 볼륨 지원&lt;/td&gt;
&lt;td&gt;매우 높은 데이터 볼륨 지원&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;중앙 집중식 배포&lt;/td&gt;
&lt;td&gt;분산 배치&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;주로 한 위치에 기록 된 데이터&lt;/td&gt;
&lt;td&gt;여러 위치에서 작성된 데이터&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;읽기 확장 성 지원 (일관성 희생)&lt;/td&gt;
&lt;td&gt;읽기 및 쓰기 확장 성 지원&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;수직 확장 방식으로 배포&lt;/td&gt;
&lt;td&gt;수평 확장 방식으로 배포&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;데이터 모델&lt;/h2&gt;
&lt;h3&gt;내부 데이터 구조&lt;/h3&gt;
&lt;p&gt;카산드라 데이터 모델은 스키마 선택적 열 지향 데이터 모델입니다.&lt;br&gt;
즉, 관계형 데이터베이스와 달리 각 행에 동일한 열 집합이 없어도되므로 &lt;code&gt;응용 프로그램에 필요한 모든 열을 미리 모델링할 필요가 없습니다.&lt;/code&gt;&lt;br&gt;
카산드라 데이터 모델은 키 스페이스(데이터베이스와 유사), 열 패밀리(관계형 모델의 테이블과 유사), 키와 열로 구성됩니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_023_002.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;각 열 계열에 대해 관계형 테이블을 생각하지 마세요. 대신 중첩 된 맵 데이터 구조를 생각하세요. 중첩 정렬 맵은 관계형 테이블보다 더 정확하며 카산드라 데이터 모델에 대한 올바른 결정을 내리는데 도움이 됩니다.&lt;/p&gt;
&lt;!-- &lt;script src=&quot;https://gist.github.com/baekdev/a4a38c65e70f7b51b72dc298baa93f4b.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Map&amp;#x3C;RowKey, SortedMap&amp;#x3C;ColumnKey, ColumnValue&gt;&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;맵은 효율적인 키 조회를 제공하고 정렬 된 특성은 효율적인 스캔을 제공합니다.
카산드라에서는 행 키와 열 키를 사용하여 효율적인 조회 및 범위 검색을 수행 할 수 있습니다.
열 키의 수는 제한이 없습니다. 즉, 넓은 행을 가질 수 있습니다.
키 자체는 키 이름의 일부로 값을 보유 할 수 있습니다. 즉, 값이없는 열을 가질 수 있습니다.&lt;/p&gt;
&lt;h3&gt;CQL&lt;/h3&gt;
&lt;p&gt;카산드라는 SQL과 유사한 CQL (Cassandra Query Language)를 사용합니다. SQL과 마찬가지로 명령문은 데이터를 변경하거나, 데이터를 검색하거나, 데이터를 저장하거나, 데이터가 저장되는 방식을 변경합니다.&lt;/p&gt;
&lt;!-- &lt;script src=&quot;https://gist.github.com/baekdev/9176790bff80bf2fa7f2d2fe9004a13b.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT * FROM MyTable;

UPDATE MyTable
  SET SomeColumn = &apos;Some Value&apos;
  WHERE columnName = &apos;Something Else&apos;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CQL을 사용하여 작성된 키 공간, 열 및 테이블 이름은 큰 따옴표로 묶지 않으면 대소문자를 구분하지 않습니다. 대문자를 사용하여 이러한 객체의 이름을 입력하면 카산드라는 이름을 소문자로 저장합니다. 큰 따옴표를 사용하여 케이스를 강제 실행할 수 있습니다.&lt;/p&gt;
&lt;!-- &lt;script src=&quot;https://gist.github.com/baekdev/a43ba9f71f4a7d0a540d3c50add0f94c.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE test (
  Foo int PRIMARY KEY,
  &quot;Bar&quot; int
);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.datastax.com/en/dse/6.8/cql/cql/cql_reference/refDataTypes.html&quot; target=&quot;_blank&quot;&gt;CQL Data types&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;마무리&lt;/h3&gt;
&lt;p&gt;오늘은 카산드라가 무엇인지 간략히 알아봤습니다.&lt;br&gt;
다음에는 카산드라 인덱스와 데이터 복제, 동시성 등에 대해 알아보겠습니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;참고&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.datastax.com/resources/definitions/what-is-apache-cassandra&quot; target=&quot;_blank&quot;&gt;What is Apache Cassandra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://teddyma.gitbooks.io/learncassandra/&quot; target=&quot;_blank&quot;&gt;Learn Cassandra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://meetup.toast.com/posts/58&quot; target=&quot;_blank&quot;&gt;Apache Cassandra 톺아보기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;하이브리드 클라우드란 둘 이상의 퍼블릭 클라우드와 프라이빗 클라우드를 환경이 조합된 것&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[객체지향을 한 단어로 설명한다면 그것은 클래스가 아니라 메시지이다]]></title><description><![CDATA[<blockquote>
<p>의도는 "메시징"이다.<br>
훌륭하고 성장 가능한 시스템을 만들기 위한 핵심은 모듈 내부의 속성과 행동이 어떤가보다<br>
모듈이 어떻게 커뮤니케이션하는가에 달려있다.</p>
<ul>
<li>Alan Curtis Kay</li>
</ul>
</blockquote>
<h2>자율적인 책임</h2>
<p><code>객체지향 공동체를 구성하는 기본 단위는 자율적인 객체다.</code><br>
자율적인 객체란 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 객체다.
객체가 어떤 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문이다. <strong>요청을 처리하기 위해 객체가 수행하는 행동을 책임</strong>이라고 한다.</p>
<p>적절한 책임이 자율적인 객체를 낳고, 자율적인 객체들이 모여 유연하고 단순한 협력을 낳는다. <strong>따라서 협력에 참여하는 객체가 얼마나 자율적인지가 전체 어플리케이션의 품질을 결정한다.</strong>
객체가 책임을 자율적으로 수행하기 위해서는 객체에게 할당되는 책임이 자율적이어야 한다. 책임이 자율적이지 않다면 객체가 아무리 발버둥친다고 하더라도 자율적으로 책임을 수행하기 어렵다.</p>
<p>이상한 나라의 앨리스 동화에 등장하는 왕의 재판을 통해 객체지향에서의 책임과 협력하는 과정을 살펴보자.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_022_002.png" alt="협력1. 모자 장수는 증언할 책임을 자율적인 방식으로 수행할 수 있음"></p>
<p><strong>협력1</strong>에서 모자 장수는 왕에게 증언할 책임은 있지만 증언을 위한 구체적인 방법이나 절차에 대해서는 최대한의 자유를 누린다.<br>
증언을 위해 기억력에 의존할지, 메모를 참고할지, 혹은 서면 제출할지 등 증언을 수행하기 위한 방법에는 제약이 없다.</p>
<p><code>중요한 것은 왕의 입장에서 모자 장수가 어떤 방법으로 증하는지는 중요하지 않다는 것이다.</code></p>
<p>왕은 단지 모자 장수가 증언하기를 바랄 뿐이다. 증언이라는 책임만 완수할 수 있다면 나머지 구체적인 방법이나 절차는 모자 장수가 자유롭게 선택하도록 허용한다.
따라서 모자 장수는 최종적으로 왕이 만족할 만한 수준으로 증언할 수만 있다면 그 밖의 세부 사항에 대해서는 무한대에 가까운 자율권을 누릴 수 있다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_022_001.png" alt="협력2. 좀 더 상세한 수준의 책임을 수행하는 모자 장수"></p>
<p><strong>협력2</strong>는 왕이 모자 장수에게 증언을 좀 더 상세한 수준으로 요청한다.<br>
모자 장수는 협력1에서와 마찬가지로 이 요청들을 차례대로 처리해야하는 책임을 갖고 있다.
하지만 문제는 모자 장수가 증언하기 위해 선택할 수 있는 자유의 범위를 지나치게 제한한다는 것이다. 메모한 내용을 손에 쥐고 있어도 보기 어렵고, 반드시 재판에 참석하여 말로 증언을 해야하기 때문에 다른 수단을 이용할 수도 없다.</p>
<p><strong>이와 같은 상세한 수준의 책임은 증언이라는 협력의 최종 목표는 만족시킬지 몰라도 모자 장수가 누려야 하는 선택의 자유를 크게 훼손하고 만다.</strong><br>
즉, 협력2를 통해 모자 장수는 책임을 수행하기 위해 자신의 의지나 판단력이 아닌 왕의 명령에 의존할 수밖에 없다.<br>
결과적으로 두 번째 모자 장수는 자율적으로 책임을 수행할 수 없다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_022_003.png" alt="협력3. 협력의 의도를 흐릿하게 만드는 추상적인 책임"><br>
협력2와 같이 책임이 너무 상세해도 문제지만 협력의 의도를 명확하게 표현하지 못할 정도로 추상적인 것 역시 문제다.<br>
<strong>협력3</strong>에서 <strong>설명하라</strong>라는 책임은 무엇에 대해서 설명해야하는지 알 수 없다.
추상적이고 포괄적인 책임은 협력을 좀 더 다양한 환경에서 재사용할 수 있도록 유연성이라는 축복을 내려준다. 그러나 책임은 협력에 참여하는 의도를 명확하게 설명할 수 있는 수준 안에서 추상적이어야 한다.</p>
<p>증언하라라는 책임이 휼륭한 책임인 이유는,<br>
<code>모자 장수의 자율성을 보장할 수 있을 정도로 충분히 추상적인 동시에 협력의 의도를 뚜렷하게 표현할 수 있을 정도로 충분히 구체적이기 때문이다.</code><br>
어떤 책임이 자율적인지를 판단하는 기준은 문맥에 따라 다르다는 사실에 유의하라.<br>
어떤 책임이 가장 적절한가는 설계 중인 협력이 무엇인가에 따라 달라진다.<br>
이런 모호함이 객체지향 설계를 난해하면서도 매력적인 예술로 만드는 이유다.</p>
<blockquote>
<p>성급한 일반화의 오류를 피하고 현재의 문맥에 가장 적합한 책임을 선택할 수 있는 날카로운 안목을 기르기 바란다.</p>
</blockquote>
<p>자율적인 책임의 특징은 객체가 <strong>어떻게</strong>해야 하는가가 아니라 <strong>무엇</strong>을 해야하는가를 설명한다는 것이다. <strong>증언한다</strong>라는 책임은 모자 장수가 협력을 위해 <strong>무엇</strong>을 해야 하는지는 결정하지만
<strong>어떻게</strong> 해야 하는지에 대해서는 전혀 언급하지 않는다. 증언할 방법은 모자 장수가 자율적으로 선택할 수 있다.
책임이라는 말 속에는 어떤 행동을 수행한다는 의미가 포함돼 있다. 객체지향 공동체 안에 거주하는 객체는 다른 객체로부터 전송된 요청을 수신할 때만 어떤 행동을 시작한다.</p>
<p>즉, <code>사실 객체가 다른 객체에게 접근할 수 있는 유일한 방법은 요청을 전송하는 것뿐</code>이다.<br>
그리고 이 요청을 우리는 <strong>메시지</strong>라고 부른다.
메시지는 객체로 하여금 자신의 책임, 즉 행동을 수행하게 만드는 유일한 방법이다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_022_004.png"></p>
<h2>메시지와 메서드</h2>
<p>하나의 객체는 메시지를 전송함으로써 다른 객체에 접근한다. 객체의 행동을 유발하는 행위를 가리켜 메시지-전송이라고 한다.
메시지-전송 메커니즘은 객체가 다른 객체에 접근할 수 있는 유일한 방법이다.</p>
<p>앞서 예로 든 <strong>증언하라</strong>라는 부분은 왕이 모자 장수에게 전송하는 메시지이고, 이 부분을 메시지 이름이라고 한다.
메시지를 전송할 때 추가적인 정보가 필요한 경우 메시지의 인자를 통해 추가 정보를 제공할 수 있다. 메시지는 메시지 이름과 인자의 두 부분으로 구성되므로 결국 메시지 전송은 수신자, 메시지 이름, 인자이 조합이 된다.</p>
<pre><code class="language-text">모자장수.증언하라(어제, 왕국);
</code></pre>
<p><code>모자 장수가 수신할 수 있는 메시지가 모자 장수가 수행해야 할 책임의 모양을 결정한다.</code><br>
모자 장수가 메시지를 변경하지만 않는다면 책임을 수행하는 방법을 변경하더라도 왕은 그 사실을 알 수 없다.
이것은 객체의 외부와 내부가 메시지를 기준으로 분리된다는 것을 의미한다.</p>
<p>객체가 제공하는 메시지는 외부의 다른 객체가 볼 수 있는 공개된 영역에 속한다.
메시지를 처리하기 위해 책임을 수행하는 방법은 외부의 다른 객체가 볼 수 없는 객체 자신의 사적인 영역에 속한다.
객체가 유일하게 이해할 수 있는 의사소통 수단은 메시지뿐이며 객체는 메시지를 처리하기 위한 방법을 자율적으로 선택할 수 있다.</p>
<p>모자 장수가 메시지를 처리하기 위해 내부적으로 선택하는 방법을 <strong>메서드</strong>라고 한다.
왕이 전송한 증언하라라는 메시지를 처리하기 위해 모자 장수가 내부적으로 선택하는 증언 방법이 바로 메서드다.
따라서 어떤 객체에게 메시지를 전송하면 결과적으로 메시지에 대응되는 특정 메서드가 실행된다.</p>
<blockquote>
<p>메시지가 '어떻게' 수행될 것인지는 명시하지 않는다.<br>
메시지는 단지 오퍼레이션을 통해 '무엇'이 실행되기를 바라는지만 명시하며,<br>
어떤 메서드를 선택할 것인지는 전적으로 수신자의 결정에 좌우된다.</p>
</blockquote>
<h2>다형성</h2>
<p>이런 메시지와 메서드의 차이와 관계를 이해하고 나면 객체지향의 핵심 개념인 다형성을 쉽게 이해할 수 있다.<br>
<code>다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미한다.</code><br>
서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메서드를 이용해 메시를 이용해 메시지를 처리할 수 있는 메커니즘을 가리킨다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_022_005.png" alt="다형성 : 왕으로부터 동일한 메시지를 수신하고 각자 필요한 방법에 맞게 처리한다."></p>
<p>앨리스의 이야기에서 모자 장수, 요리사, 앨리시는 모두 왕이 전송한 <strong>증언하라</strong>라는 메시지를 이해할 수 있다.
각 수신자는 왕이 전송한 메시지를 처리하기 위해 자신만의 방법을 자유롭게 선택할 수 있다.
어떤 방법을 사용하건 왕의 입장에서는 결과가 동일하다. 이들 모두 증언하고 있는 것이다. 이것이 바로 <code>다형성</code>이다.</p>
<p>다형성은 역할, 책임, 협력과 깊은 관련이 있다.<br>
서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미한다.
메시지 수신자들이 동일한 오퍼레이션을 서로 다른 방식으로 처리하더라도 메시지 송신자의 관점에서 이 객체들은 동일한 책임을 수행하는 것이다.
<strong>즉, 송신자의 관점에서 다형적인 수신자들을 구별할 필요가 없으며 자신의 요청을 수행할 책임을 지닌다는 점에서 모두 동일하다.</strong></p>
<p>다형성은 객체들의 대체 가능성을 이용해 설계를 유연하고 재사용 가능하게 만든다. 다형성을 사용하면 송신자가 수신자의 종류를 모르더라도 메시지를 전송할 수 있다.
즉, 다형성은 수신자의 종류를 캡슐화한다.</p>
<blockquote>
<p>객체지향 패러다임이 강력한 이유는 다형성을 이용해 협력을 유연하게 만들수 있기 때문이다.</p>
</blockquote>
<h2>메시지를 따라라</h2>
<p>객체지향 애플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것이다.
<strong>클래스 기반의 객체지향 언어를 사용하는 대부분의 사람들은 객체지향 애플리케이션을 클래스의 집합으로 생각한다.</strong> 프로그래머 입장에서는 클래스는 실제로 볼 수 있고 수정할 수 있는 구체적인 존재다. 대부분의 입문자들은 클래스 간의 상속 관계가 객체지향 설계를 가치 있게 만드는 핵심적인 매커니즘이라고 배운다.</p>
<p><code>하지만 객체지향의 강력함은 클래스가 아니라 객체들이 주고받는 메시지로부터 나온다.</code><br>
<code>객체지향의 애플리케이션은 클래스를 이용해 만들어지지만 메시지를 통해 정의된다.</code></p>
<p>실제로 애플리케이션을 살아있게 만드는 것은 클래스가 아니라 객체다. 그리고 이런 객체들의 윤곽을 결정하는 것이 바로 객체들이 주고받는 메시지다.
클래스를 정의하는 것이 먼저가 아니라 객체들의 속성과 행위를 식별하는 것이 먼저다. <strong>클래스는 객체의 속성과 행위를 담는 틀일 뿐이다.</strong><br>
객체 자체에 초점을 맞출 경우 가장 흔히 범하게 되는 실수는 협력이라는 문맥을 배제한 채 객체 내부의 데이터 구조를 먼저 생각한 후 데이터 조작에 필요한 오퍼레이션을 나중에 고려하는 것이다.</p>
<blockquote>
<p>훌륭한 객체지향 설계는 어떤 객체가 어떤 메시지를 전송할 수 있는가와<br>
어떤 객체가 어떤 메시지를 이해할 수 있는가를 중심으로 객체 사이의 협력 관계를 구성하는 것이다.<br>
객체지향 설계의 중심에는 메시지가 위치한다. 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 한다.<br>
객체지향 시스템은 협력하는 객체들의 연결망이다.</p>
</blockquote>
<h2>객체 인터페이스, 구현의 분리</h2>
<p>일반적인 인터페이스의 특징은 다음과 같다.</p>
<ul>
<li>인터페이스의 사용법을 익히기만 하면 내부 구조나 동작 방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달할 수 있다.</li>
<li>인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동 방식만을 변경하는 것은 인터페이스 사용자에게 어떤 영향도 미치지 않는다.</li>
<li>대상이 변경되더라도 동일한 인터페이스를 제공하기만 하면 아무런 문제 없이 상호작용 할 수 있다.</li>
</ul>
<p><code>객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지 전송이다.</code><br>
따라서 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성되며 객체가 어떤 메시지를 수신할 수 있는지가 제공하는 인터페이스의 모양을 빚는다.
이때는 3가지의 원칙이 필요하다.</p>
<ul>
<li>좀 더 추상적인 인터페이스를 통해 수신자의 자율성을 보장</li>
<li>외부에서 사용할 필요가 없는 인터페이스는 최대한 노출하지 말 것</li>
<li>인터페이스와 구현 간에 차이가 있음</li>
</ul>
<p>객체가 가져야 할 상태와 메서드 구현은 객체 내부에 속한다. 이 부분을 수정하더라도 객체 외부에 영향을 미쳐서는 안된다. 객체 외부에 영향을 미치는 변경은 객체의 공용 인터페이스를 수정할 때 분이다. 이렇게 인터페이스와 구현의 분리 원칙은 변경을 관리하기 위한 것이다. 느슨한 인터페이스에 대해서만 결합되도록 만드는 것이다.</p>
<p>이렇게 인터페이스를 제외한 구현부를 외부로 부터 감추는 것을 <strong>캡슐화</strong>라고 한다. 객체는 상태와 행위를 함께 캡슐화함으로써 충분히 협력적이고 만족스러울 정도로 자율적인 존재가 될 수 있다.
<strong>캡슐화를 정보의 은닉</strong>이라고 부르기도 한다.</p>
<h2>객체가 자율적인 책임을 갖는 것이 중요한 이유</h2>
<blockquote>
<p>책임의 자율성이 협력의 품질을 결정한다.</p>
</blockquote>
<p>객체의 책임이 자율적일수록 협력이 이해하기 쉬워지고 유연하게 변경할 수 있게 된다. 결과적으로 책임이 얼마나 자율적인지가 전체적인 협력의 설계 품질을 결정하게 된다.</p>
<ul>
<li>자율적인 책임은 협력을 단순하게 만든다.</li>
<li>자율적인 책임은 모자 장수의 외부와 내부를 명확하게 분리한다.</li>
<li>책임이 자율적일 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않는다.(결합도가 낮아짐)</li>
<li>자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다.</li>
<li>객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다.</li>
</ul>
<h2>마무리</h2>
<p>책임이 자율적일수록 적절하게 <strong>추상화</strong>되며,<br>
<strong>응집도</strong>가 높아지고, <strong>결합도</strong>가 낮아지며,<br>
<strong>캡슐화</strong>가 증진되고, <strong>인터페이스와 구현이 명확히 분리</strong>되며, 설계의 <strong>유연성</strong>과 <strong>재사용성</strong>이 향상된다.<br>
이런 특성들이 모여 객체지향을 다른 패러다임보다 우월하게 만든다는 사실을 이해하는 것이 매우 중요하다.</p>
<p><code>객체지향의 강력함을 누리기 위한 출발점은 책임을 자율적으로 만드는 것이다.</code></p>
<hr>
<p>출처 : 객체지향의 사실과 오해 5장 &#x3C;책임과 메시지></p>]]></description><link>https://baek.dev/post/22/</link><guid isPermaLink="false">https://baek.dev/post/22/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 10 May 2020 09:25:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;의도는 &quot;메시징&quot;이다.&lt;br&gt;
훌륭하고 성장 가능한 시스템을 만들기 위한 핵심은 모듈 내부의 속성과 행동이 어떤가보다&lt;br&gt;
모듈이 어떻게 커뮤니케이션하는가에 달려있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Alan Curtis Kay&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;자율적인 책임&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;객체지향 공동체를 구성하는 기본 단위는 자율적인 객체다.&lt;/code&gt;&lt;br&gt;
자율적인 객체란 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 객체다.
객체가 어떤 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문이다. &lt;strong&gt;요청을 처리하기 위해 객체가 수행하는 행동을 책임&lt;/strong&gt;이라고 한다.&lt;/p&gt;
&lt;p&gt;적절한 책임이 자율적인 객체를 낳고, 자율적인 객체들이 모여 유연하고 단순한 협력을 낳는다. &lt;strong&gt;따라서 협력에 참여하는 객체가 얼마나 자율적인지가 전체 어플리케이션의 품질을 결정한다.&lt;/strong&gt;
객체가 책임을 자율적으로 수행하기 위해서는 객체에게 할당되는 책임이 자율적이어야 한다. 책임이 자율적이지 않다면 객체가 아무리 발버둥친다고 하더라도 자율적으로 책임을 수행하기 어렵다.&lt;/p&gt;
&lt;p&gt;이상한 나라의 앨리스 동화에 등장하는 왕의 재판을 통해 객체지향에서의 책임과 협력하는 과정을 살펴보자.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_022_002.png&quot; alt=&quot;협력1. 모자 장수는 증언할 책임을 자율적인 방식으로 수행할 수 있음&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;협력1&lt;/strong&gt;에서 모자 장수는 왕에게 증언할 책임은 있지만 증언을 위한 구체적인 방법이나 절차에 대해서는 최대한의 자유를 누린다.&lt;br&gt;
증언을 위해 기억력에 의존할지, 메모를 참고할지, 혹은 서면 제출할지 등 증언을 수행하기 위한 방법에는 제약이 없다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;중요한 것은 왕의 입장에서 모자 장수가 어떤 방법으로 증하는지는 중요하지 않다는 것이다.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;왕은 단지 모자 장수가 증언하기를 바랄 뿐이다. 증언이라는 책임만 완수할 수 있다면 나머지 구체적인 방법이나 절차는 모자 장수가 자유롭게 선택하도록 허용한다.
따라서 모자 장수는 최종적으로 왕이 만족할 만한 수준으로 증언할 수만 있다면 그 밖의 세부 사항에 대해서는 무한대에 가까운 자율권을 누릴 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_022_001.png&quot; alt=&quot;협력2. 좀 더 상세한 수준의 책임을 수행하는 모자 장수&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;협력2&lt;/strong&gt;는 왕이 모자 장수에게 증언을 좀 더 상세한 수준으로 요청한다.&lt;br&gt;
모자 장수는 협력1에서와 마찬가지로 이 요청들을 차례대로 처리해야하는 책임을 갖고 있다.
하지만 문제는 모자 장수가 증언하기 위해 선택할 수 있는 자유의 범위를 지나치게 제한한다는 것이다. 메모한 내용을 손에 쥐고 있어도 보기 어렵고, 반드시 재판에 참석하여 말로 증언을 해야하기 때문에 다른 수단을 이용할 수도 없다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;이와 같은 상세한 수준의 책임은 증언이라는 협력의 최종 목표는 만족시킬지 몰라도 모자 장수가 누려야 하는 선택의 자유를 크게 훼손하고 만다.&lt;/strong&gt;&lt;br&gt;
즉, 협력2를 통해 모자 장수는 책임을 수행하기 위해 자신의 의지나 판단력이 아닌 왕의 명령에 의존할 수밖에 없다.&lt;br&gt;
결과적으로 두 번째 모자 장수는 자율적으로 책임을 수행할 수 없다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_022_003.png&quot; alt=&quot;협력3. 협력의 의도를 흐릿하게 만드는 추상적인 책임&quot;&gt;&lt;br&gt;
협력2와 같이 책임이 너무 상세해도 문제지만 협력의 의도를 명확하게 표현하지 못할 정도로 추상적인 것 역시 문제다.&lt;br&gt;
&lt;strong&gt;협력3&lt;/strong&gt;에서 &lt;strong&gt;설명하라&lt;/strong&gt;라는 책임은 무엇에 대해서 설명해야하는지 알 수 없다.
추상적이고 포괄적인 책임은 협력을 좀 더 다양한 환경에서 재사용할 수 있도록 유연성이라는 축복을 내려준다. 그러나 책임은 협력에 참여하는 의도를 명확하게 설명할 수 있는 수준 안에서 추상적이어야 한다.&lt;/p&gt;
&lt;p&gt;증언하라라는 책임이 휼륭한 책임인 이유는,&lt;br&gt;
&lt;code&gt;모자 장수의 자율성을 보장할 수 있을 정도로 충분히 추상적인 동시에 협력의 의도를 뚜렷하게 표현할 수 있을 정도로 충분히 구체적이기 때문이다.&lt;/code&gt;&lt;br&gt;
어떤 책임이 자율적인지를 판단하는 기준은 문맥에 따라 다르다는 사실에 유의하라.&lt;br&gt;
어떤 책임이 가장 적절한가는 설계 중인 협력이 무엇인가에 따라 달라진다.&lt;br&gt;
이런 모호함이 객체지향 설계를 난해하면서도 매력적인 예술로 만드는 이유다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;성급한 일반화의 오류를 피하고 현재의 문맥에 가장 적합한 책임을 선택할 수 있는 날카로운 안목을 기르기 바란다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;자율적인 책임의 특징은 객체가 &lt;strong&gt;어떻게&lt;/strong&gt;해야 하는가가 아니라 &lt;strong&gt;무엇&lt;/strong&gt;을 해야하는가를 설명한다는 것이다. &lt;strong&gt;증언한다&lt;/strong&gt;라는 책임은 모자 장수가 협력을 위해 &lt;strong&gt;무엇&lt;/strong&gt;을 해야 하는지는 결정하지만
&lt;strong&gt;어떻게&lt;/strong&gt; 해야 하는지에 대해서는 전혀 언급하지 않는다. 증언할 방법은 모자 장수가 자율적으로 선택할 수 있다.
책임이라는 말 속에는 어떤 행동을 수행한다는 의미가 포함돼 있다. 객체지향 공동체 안에 거주하는 객체는 다른 객체로부터 전송된 요청을 수신할 때만 어떤 행동을 시작한다.&lt;/p&gt;
&lt;p&gt;즉, &lt;code&gt;사실 객체가 다른 객체에게 접근할 수 있는 유일한 방법은 요청을 전송하는 것뿐&lt;/code&gt;이다.&lt;br&gt;
그리고 이 요청을 우리는 &lt;strong&gt;메시지&lt;/strong&gt;라고 부른다.
메시지는 객체로 하여금 자신의 책임, 즉 행동을 수행하게 만드는 유일한 방법이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_022_004.png&quot;&gt;&lt;/p&gt;
&lt;h2&gt;메시지와 메서드&lt;/h2&gt;
&lt;p&gt;하나의 객체는 메시지를 전송함으로써 다른 객체에 접근한다. 객체의 행동을 유발하는 행위를 가리켜 메시지-전송이라고 한다.
메시지-전송 메커니즘은 객체가 다른 객체에 접근할 수 있는 유일한 방법이다.&lt;/p&gt;
&lt;p&gt;앞서 예로 든 &lt;strong&gt;증언하라&lt;/strong&gt;라는 부분은 왕이 모자 장수에게 전송하는 메시지이고, 이 부분을 메시지 이름이라고 한다.
메시지를 전송할 때 추가적인 정보가 필요한 경우 메시지의 인자를 통해 추가 정보를 제공할 수 있다. 메시지는 메시지 이름과 인자의 두 부분으로 구성되므로 결국 메시지 전송은 수신자, 메시지 이름, 인자이 조합이 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;모자장수.증언하라(어제, 왕국);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;모자 장수가 수신할 수 있는 메시지가 모자 장수가 수행해야 할 책임의 모양을 결정한다.&lt;/code&gt;&lt;br&gt;
모자 장수가 메시지를 변경하지만 않는다면 책임을 수행하는 방법을 변경하더라도 왕은 그 사실을 알 수 없다.
이것은 객체의 외부와 내부가 메시지를 기준으로 분리된다는 것을 의미한다.&lt;/p&gt;
&lt;p&gt;객체가 제공하는 메시지는 외부의 다른 객체가 볼 수 있는 공개된 영역에 속한다.
메시지를 처리하기 위해 책임을 수행하는 방법은 외부의 다른 객체가 볼 수 없는 객체 자신의 사적인 영역에 속한다.
객체가 유일하게 이해할 수 있는 의사소통 수단은 메시지뿐이며 객체는 메시지를 처리하기 위한 방법을 자율적으로 선택할 수 있다.&lt;/p&gt;
&lt;p&gt;모자 장수가 메시지를 처리하기 위해 내부적으로 선택하는 방법을 &lt;strong&gt;메서드&lt;/strong&gt;라고 한다.
왕이 전송한 증언하라라는 메시지를 처리하기 위해 모자 장수가 내부적으로 선택하는 증언 방법이 바로 메서드다.
따라서 어떤 객체에게 메시지를 전송하면 결과적으로 메시지에 대응되는 특정 메서드가 실행된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;메시지가 &apos;어떻게&apos; 수행될 것인지는 명시하지 않는다.&lt;br&gt;
메시지는 단지 오퍼레이션을 통해 &apos;무엇&apos;이 실행되기를 바라는지만 명시하며,&lt;br&gt;
어떤 메서드를 선택할 것인지는 전적으로 수신자의 결정에 좌우된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;다형성&lt;/h2&gt;
&lt;p&gt;이런 메시지와 메서드의 차이와 관계를 이해하고 나면 객체지향의 핵심 개념인 다형성을 쉽게 이해할 수 있다.&lt;br&gt;
&lt;code&gt;다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미한다.&lt;/code&gt;&lt;br&gt;
서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메서드를 이용해 메시를 이용해 메시지를 처리할 수 있는 메커니즘을 가리킨다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_022_005.png&quot; alt=&quot;다형성 : 왕으로부터 동일한 메시지를 수신하고 각자 필요한 방법에 맞게 처리한다.&quot;&gt;&lt;/p&gt;
&lt;p&gt;앨리스의 이야기에서 모자 장수, 요리사, 앨리시는 모두 왕이 전송한 &lt;strong&gt;증언하라&lt;/strong&gt;라는 메시지를 이해할 수 있다.
각 수신자는 왕이 전송한 메시지를 처리하기 위해 자신만의 방법을 자유롭게 선택할 수 있다.
어떤 방법을 사용하건 왕의 입장에서는 결과가 동일하다. 이들 모두 증언하고 있는 것이다. 이것이 바로 &lt;code&gt;다형성&lt;/code&gt;이다.&lt;/p&gt;
&lt;p&gt;다형성은 역할, 책임, 협력과 깊은 관련이 있다.&lt;br&gt;
서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미한다.
메시지 수신자들이 동일한 오퍼레이션을 서로 다른 방식으로 처리하더라도 메시지 송신자의 관점에서 이 객체들은 동일한 책임을 수행하는 것이다.
&lt;strong&gt;즉, 송신자의 관점에서 다형적인 수신자들을 구별할 필요가 없으며 자신의 요청을 수행할 책임을 지닌다는 점에서 모두 동일하다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;다형성은 객체들의 대체 가능성을 이용해 설계를 유연하고 재사용 가능하게 만든다. 다형성을 사용하면 송신자가 수신자의 종류를 모르더라도 메시지를 전송할 수 있다.
즉, 다형성은 수신자의 종류를 캡슐화한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;객체지향 패러다임이 강력한 이유는 다형성을 이용해 협력을 유연하게 만들수 있기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;메시지를 따라라&lt;/h2&gt;
&lt;p&gt;객체지향 애플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것이다.
&lt;strong&gt;클래스 기반의 객체지향 언어를 사용하는 대부분의 사람들은 객체지향 애플리케이션을 클래스의 집합으로 생각한다.&lt;/strong&gt; 프로그래머 입장에서는 클래스는 실제로 볼 수 있고 수정할 수 있는 구체적인 존재다. 대부분의 입문자들은 클래스 간의 상속 관계가 객체지향 설계를 가치 있게 만드는 핵심적인 매커니즘이라고 배운다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;하지만 객체지향의 강력함은 클래스가 아니라 객체들이 주고받는 메시지로부터 나온다.&lt;/code&gt;&lt;br&gt;
&lt;code&gt;객체지향의 애플리케이션은 클래스를 이용해 만들어지지만 메시지를 통해 정의된다.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;실제로 애플리케이션을 살아있게 만드는 것은 클래스가 아니라 객체다. 그리고 이런 객체들의 윤곽을 결정하는 것이 바로 객체들이 주고받는 메시지다.
클래스를 정의하는 것이 먼저가 아니라 객체들의 속성과 행위를 식별하는 것이 먼저다. &lt;strong&gt;클래스는 객체의 속성과 행위를 담는 틀일 뿐이다.&lt;/strong&gt;&lt;br&gt;
객체 자체에 초점을 맞출 경우 가장 흔히 범하게 되는 실수는 협력이라는 문맥을 배제한 채 객체 내부의 데이터 구조를 먼저 생각한 후 데이터 조작에 필요한 오퍼레이션을 나중에 고려하는 것이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;훌륭한 객체지향 설계는 어떤 객체가 어떤 메시지를 전송할 수 있는가와&lt;br&gt;
어떤 객체가 어떤 메시지를 이해할 수 있는가를 중심으로 객체 사이의 협력 관계를 구성하는 것이다.&lt;br&gt;
객체지향 설계의 중심에는 메시지가 위치한다. 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 한다.&lt;br&gt;
객체지향 시스템은 협력하는 객체들의 연결망이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;객체 인터페이스, 구현의 분리&lt;/h2&gt;
&lt;p&gt;일반적인 인터페이스의 특징은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인터페이스의 사용법을 익히기만 하면 내부 구조나 동작 방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달할 수 있다.&lt;/li&gt;
&lt;li&gt;인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동 방식만을 변경하는 것은 인터페이스 사용자에게 어떤 영향도 미치지 않는다.&lt;/li&gt;
&lt;li&gt;대상이 변경되더라도 동일한 인터페이스를 제공하기만 하면 아무런 문제 없이 상호작용 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지 전송이다.&lt;/code&gt;&lt;br&gt;
따라서 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성되며 객체가 어떤 메시지를 수신할 수 있는지가 제공하는 인터페이스의 모양을 빚는다.
이때는 3가지의 원칙이 필요하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;좀 더 추상적인 인터페이스를 통해 수신자의 자율성을 보장&lt;/li&gt;
&lt;li&gt;외부에서 사용할 필요가 없는 인터페이스는 최대한 노출하지 말 것&lt;/li&gt;
&lt;li&gt;인터페이스와 구현 간에 차이가 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;객체가 가져야 할 상태와 메서드 구현은 객체 내부에 속한다. 이 부분을 수정하더라도 객체 외부에 영향을 미쳐서는 안된다. 객체 외부에 영향을 미치는 변경은 객체의 공용 인터페이스를 수정할 때 분이다. 이렇게 인터페이스와 구현의 분리 원칙은 변경을 관리하기 위한 것이다. 느슨한 인터페이스에 대해서만 결합되도록 만드는 것이다.&lt;/p&gt;
&lt;p&gt;이렇게 인터페이스를 제외한 구현부를 외부로 부터 감추는 것을 &lt;strong&gt;캡슐화&lt;/strong&gt;라고 한다. 객체는 상태와 행위를 함께 캡슐화함으로써 충분히 협력적이고 만족스러울 정도로 자율적인 존재가 될 수 있다.
&lt;strong&gt;캡슐화를 정보의 은닉&lt;/strong&gt;이라고 부르기도 한다.&lt;/p&gt;
&lt;h2&gt;객체가 자율적인 책임을 갖는 것이 중요한 이유&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;책임의 자율성이 협력의 품질을 결정한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;객체의 책임이 자율적일수록 협력이 이해하기 쉬워지고 유연하게 변경할 수 있게 된다. 결과적으로 책임이 얼마나 자율적인지가 전체적인 협력의 설계 품질을 결정하게 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자율적인 책임은 협력을 단순하게 만든다.&lt;/li&gt;
&lt;li&gt;자율적인 책임은 모자 장수의 외부와 내부를 명확하게 분리한다.&lt;/li&gt;
&lt;li&gt;책임이 자율적일 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않는다.(결합도가 낮아짐)&lt;/li&gt;
&lt;li&gt;자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다.&lt;/li&gt;
&lt;li&gt;객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;마무리&lt;/h2&gt;
&lt;p&gt;책임이 자율적일수록 적절하게 &lt;strong&gt;추상화&lt;/strong&gt;되며,&lt;br&gt;
&lt;strong&gt;응집도&lt;/strong&gt;가 높아지고, &lt;strong&gt;결합도&lt;/strong&gt;가 낮아지며,&lt;br&gt;
&lt;strong&gt;캡슐화&lt;/strong&gt;가 증진되고, &lt;strong&gt;인터페이스와 구현이 명확히 분리&lt;/strong&gt;되며, 설계의 &lt;strong&gt;유연성&lt;/strong&gt;과 &lt;strong&gt;재사용성&lt;/strong&gt;이 향상된다.&lt;br&gt;
이런 특성들이 모여 객체지향을 다른 패러다임보다 우월하게 만든다는 사실을 이해하는 것이 매우 중요하다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;객체지향의 강력함을 누리기 위한 출발점은 책임을 자율적으로 만드는 것이다.&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;출처 : 객체지향의 사실과 오해 5장 &amp;#x3C;책임과 메시지&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Spring Framework에서 의존성을 주입받는 방법 3가지 - DI / Dependency Injection]]></title><description><![CDATA[<p>Spring Framework Triangle이라 불리는 스프링 프레임워크 핵심 3요소 IoC(역전 제어), AOP(관심 지향 프로그래밍), PSA(서비스 추상화)를 다룰 예정입니다.
그 전에 DI(의존성 주입)라는 사전 개념이 수반되어야 합니다. 그래서 이번 포스팅에서는 DI에 대해 알아보고 다음 포스팅에서 Spring Framework Triangle을 알아보겠습니다.</p>
<ul>
<li><a href="/post/21" target="_blank">Spring Framework에서 의존성을 주입받는 방법(DI) 3가지</a></li>
<li>(예정)Spring Framework의 핵심 3요소 - IoC(DI), AOP, PSA</li>
</ul>
<h2>DI / Dependency Injection - 의존성 주입</h2>
<p><img src="https://martinfowler.com/articles/injection/injector.gif" alt="The dependencies for a Dependency Injector"></p>
<p>A가 B에 의존한다는 의미는 B가 어떠한 이유로 변경이 발생하면 그 영향이 A에 미친다는 것입니다. 그래서 클래스들간에 직접적인 의존 관계를 맺는 것보다 느슨하게 인터페이스를 통해 의존관계 맺어, 결합도를 낮추는 것이 중요합니다. 이로써 재사용이 가능하고 확장 가능성 있는 객체를 만들어 둠으로써 모듈 간의 결합도를 낮출 수 있습니다. 이때 필요한 의존 관계는 컨테이너가 책임을 갖고 외부에서 동적으로 설정해줍니다.</p>
<ul>
<li>
<p>의존성 주입의 장점<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup></p>
<ul>
<li>의존 관계 설정이 컴파일시가 아닌 실행시에 이루어져 모듈들간의 결합도를 낮출 수 있다.</li>
<li>코드 재사용을 높여서 작성된 모듈을 여러 곳에서 소스코드의 수정 없이 사용할 수 있다.</li>
<li>모의 객체 등을 이용한 단위 테스트의 편의성을 높여준다.</li>
</ul>
</li>
</ul>
<p>의존성 주입 방법은 3가지가 있습니다. 생성자 주입, 멤버 필드 주입, Setter 메서드 주입이 있습니다.<br>
각 방법에 대한 예제를 먼저 보고 설명을 이어가겠습니다.</p>
<!-- <script src="https://gist.github.com/baekdev/29377a1adf6eb7e93c8aa26fdaec5b28.js"></script> -->
<pre><code class="language-java">/**
 * Constructor Injection
 */
@Controller
public class BookController {

    private final BookRepository bookRepository;

    public BookController(BookRepository bookRepository) {
        this.bookRepository = bookRepository;
    }

}
</code></pre>
<pre><code class="language-java">/**
 * Field Injection
 */
@Controller
public class BookController {

    @Autowired
    private BookRepository bookRepository;

}
</code></pre>
<pre><code class="language-java">/**
 * Setter Injection
 */
@Controller
public class BookController {

    private BookRepository bookRepository;

    @Autowired
    public void setBookRepository(BookRepository bookRepository) {
        this.bookRepository = bookRepository;
    }

}
</code></pre>
<h2>Constructor-Based Dependency Injection</h2>
<p>생성자 주입은 생성자에 의존성 주입을 받고자 하는 field를 나열하는 방법으로, 권고되는 방법의 하나 입니다.</p>
<ul>
<li>
<p><strong>장점</strong></p>
<ul>
<li><code>필수적으로 사용해야 하는 레퍼런스 없이는 인스턴스를 만들지 못하도록 강제함</code></li>
<li>Spring 4.3 이상부터는 생성자가 하나인 경우 @Autowired 를 사용하지 않아도 됨</li>
<li>Circular Dependency / 순환 참조<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup> 의존성을 알아 차릴 수 있음</li>
<li>생성자에 점차 많은 의존성이 추가 될 경우 리패토링 시점을 감지 할 수 있음</li>
<li>의존성 주입 대상 필드를 final로 불변 객체 선언할 수 있음</li>
<li>테스트 코드 작성시 생성자를 통해 의존성 주입이 용이함</li>
</ul>
</li>
<li>
<p><strong>단점</strong></p>
<ul>
<li>어쩔 수 없는 순환 참조는 생성자 주입으로 해결하기 어려움</li>
<li>이 경우에는 나머지 주입 방법을 사용하도록 하나</li>
<li>가급적이면 순환 참조가 발생하지 않도록 하는 것이 더 중요</li>
</ul>
</li>
</ul>
<h2>Field-Based Dependency Injection</h2>
<p>member field에 @Autowired annotation을 선언하여 주입받는 방법입니다.</p>
<ul>
<li>
<p><strong>장점</strong></p>
<ul>
<li>가장 간단한 선언 방식</li>
</ul>
</li>
<li>
<p><strong>단점</strong></p>
<ul>
<li><code>의존 관계가 눈에 잘 보이지 않아 추상적이고, 이로 인해 의존성 관계가 과도하게 복잡해질 수 있음</code></li>
<li>반대로 Constructor injection과 Setter injection은 의존성을 명확하게 커뮤니케이션 함</li>
<li>이는 SRP / 단일 책임 원칙에 반하는 안티패턴</li>
<li>DI Container와 강한 결합을 가져 외부 사용이 용이하지 않음</li>
<li><code>단위 테스트시 의존성 주입이 용이하지 않음</code></li>
<li>의존성 주입 대상 필드가 <strong>final 선언 불가</strong></li>
</ul>
</li>
</ul>
<h2>Setter-Based Dependency Injection</h2>
<p>setter 메서드에 @Autowired annotation을 선언하여 주입받는 방법입니다.</p>
<ul>
<li>
<p><strong>장점</strong></p>
<ul>
<li>의존성이 선택적으로 필요한 경우에 사용</li>
<li><code>생성자에 모든 의존성을 기술하면 과도하게 복잡해질 수 있는 것을 선택적으로 나눠 주입 할 수 있게 부담을 덜어줌</code></li>
<li>생성자 주입 방법과 Setter 주입 방법을 적절하게 상황에 맞게 분배하여 사용</li>
</ul>
</li>
<li>
<p><strong>단점</strong></p>
<ul>
<li>의존성 주입 대상 필드가 final 선언 불가</li>
</ul>
</li>
</ul>
<h3>마무리</h3>
<p>필드 주입 방법은 deprecated 이므로 이를 제외한 생성자 주입과 setter 주입 방법 중에서 적절히 상황에 맞게 사용하면 좋습니다.<br>
끝으로 마틴 파울러의 <a href="https://martinfowler.com/articles/injection.html" target="_blank">Inversion of Control Containers and the Dependency Injection pattern</a> 글은 다음 포스팅에서 다룰 IoC와도 연관이 되지만 DI를 한 번 정리하는데 많은 도움이 되므로 같이 읽어보시면 더 좋습니다.</p>
<div class="footnotes">
<hr>
<ol>
<li id="fn-1">
<p>의존성 주입의 장점 - <a href="https://ko.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EC%84%B1_%EC%A3%BC%EC%9E%85" target="_blank">위키백과</a></p>
<a href="#fnref-1" class="footnote-backref">↩</a>
</li>
<li id="fn-2">
<p>순환 참조? A가 B가 참조하고 B가 A를 참조하는 경우</p>
<a href="#fnref-2" class="footnote-backref">↩</a>
</li>
</ol>
</div>]]></description><link>https://baek.dev/post/21/</link><guid isPermaLink="false">https://baek.dev/post/21/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 12 Apr 2020 02:25:00 GMT</pubDate><content:encoded>&lt;p&gt;Spring Framework Triangle이라 불리는 스프링 프레임워크 핵심 3요소 IoC(역전 제어), AOP(관심 지향 프로그래밍), PSA(서비스 추상화)를 다룰 예정입니다.
그 전에 DI(의존성 주입)라는 사전 개념이 수반되어야 합니다. 그래서 이번 포스팅에서는 DI에 대해 알아보고 다음 포스팅에서 Spring Framework Triangle을 알아보겠습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/post/21&quot; target=&quot;_blank&quot;&gt;Spring Framework에서 의존성을 주입받는 방법(DI) 3가지&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(예정)Spring Framework의 핵심 3요소 - IoC(DI), AOP, PSA&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;DI / Dependency Injection - 의존성 주입&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://martinfowler.com/articles/injection/injector.gif&quot; alt=&quot;The dependencies for a Dependency Injector&quot;&gt;&lt;/p&gt;
&lt;p&gt;A가 B에 의존한다는 의미는 B가 어떠한 이유로 변경이 발생하면 그 영향이 A에 미친다는 것입니다. 그래서 클래스들간에 직접적인 의존 관계를 맺는 것보다 느슨하게 인터페이스를 통해 의존관계 맺어, 결합도를 낮추는 것이 중요합니다. 이로써 재사용이 가능하고 확장 가능성 있는 객체를 만들어 둠으로써 모듈 간의 결합도를 낮출 수 있습니다. 이때 필요한 의존 관계는 컨테이너가 책임을 갖고 외부에서 동적으로 설정해줍니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;의존성 주입의 장점&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;의존 관계 설정이 컴파일시가 아닌 실행시에 이루어져 모듈들간의 결합도를 낮출 수 있다.&lt;/li&gt;
&lt;li&gt;코드 재사용을 높여서 작성된 모듈을 여러 곳에서 소스코드의 수정 없이 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;모의 객체 등을 이용한 단위 테스트의 편의성을 높여준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;의존성 주입 방법은 3가지가 있습니다. 생성자 주입, 멤버 필드 주입, Setter 메서드 주입이 있습니다.&lt;br&gt;
각 방법에 대한 예제를 먼저 보고 설명을 이어가겠습니다.&lt;/p&gt;
&lt;!-- &lt;script src=&quot;https://gist.github.com/baekdev/29377a1adf6eb7e93c8aa26fdaec5b28.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
 * Constructor Injection
 */
@Controller
public class BookController {

    private final BookRepository bookRepository;

    public BookController(BookRepository bookRepository) {
        this.bookRepository = bookRepository;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
 * Field Injection
 */
@Controller
public class BookController {

    @Autowired
    private BookRepository bookRepository;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
 * Setter Injection
 */
@Controller
public class BookController {

    private BookRepository bookRepository;

    @Autowired
    public void setBookRepository(BookRepository bookRepository) {
        this.bookRepository = bookRepository;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Constructor-Based Dependency Injection&lt;/h2&gt;
&lt;p&gt;생성자 주입은 생성자에 의존성 주입을 받고자 하는 field를 나열하는 방법으로, 권고되는 방법의 하나 입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;필수적으로 사용해야 하는 레퍼런스 없이는 인스턴스를 만들지 못하도록 강제함&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Spring 4.3 이상부터는 생성자가 하나인 경우 @Autowired 를 사용하지 않아도 됨&lt;/li&gt;
&lt;li&gt;Circular Dependency / 순환 참조&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; 의존성을 알아 차릴 수 있음&lt;/li&gt;
&lt;li&gt;생성자에 점차 많은 의존성이 추가 될 경우 리패토링 시점을 감지 할 수 있음&lt;/li&gt;
&lt;li&gt;의존성 주입 대상 필드를 final로 불변 객체 선언할 수 있음&lt;/li&gt;
&lt;li&gt;테스트 코드 작성시 생성자를 통해 의존성 주입이 용이함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어쩔 수 없는 순환 참조는 생성자 주입으로 해결하기 어려움&lt;/li&gt;
&lt;li&gt;이 경우에는 나머지 주입 방법을 사용하도록 하나&lt;/li&gt;
&lt;li&gt;가급적이면 순환 참조가 발생하지 않도록 하는 것이 더 중요&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Field-Based Dependency Injection&lt;/h2&gt;
&lt;p&gt;member field에 @Autowired annotation을 선언하여 주입받는 방법입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가장 간단한 선언 방식&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;의존 관계가 눈에 잘 보이지 않아 추상적이고, 이로 인해 의존성 관계가 과도하게 복잡해질 수 있음&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;반대로 Constructor injection과 Setter injection은 의존성을 명확하게 커뮤니케이션 함&lt;/li&gt;
&lt;li&gt;이는 SRP / 단일 책임 원칙에 반하는 안티패턴&lt;/li&gt;
&lt;li&gt;DI Container와 강한 결합을 가져 외부 사용이 용이하지 않음&lt;/li&gt;
&lt;li&gt;&lt;code&gt;단위 테스트시 의존성 주입이 용이하지 않음&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;의존성 주입 대상 필드가 &lt;strong&gt;final 선언 불가&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Setter-Based Dependency Injection&lt;/h2&gt;
&lt;p&gt;setter 메서드에 @Autowired annotation을 선언하여 주입받는 방법입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;의존성이 선택적으로 필요한 경우에 사용&lt;/li&gt;
&lt;li&gt;&lt;code&gt;생성자에 모든 의존성을 기술하면 과도하게 복잡해질 수 있는 것을 선택적으로 나눠 주입 할 수 있게 부담을 덜어줌&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;생성자 주입 방법과 Setter 주입 방법을 적절하게 상황에 맞게 분배하여 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;의존성 주입 대상 필드가 final 선언 불가&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;마무리&lt;/h3&gt;
&lt;p&gt;필드 주입 방법은 deprecated 이므로 이를 제외한 생성자 주입과 setter 주입 방법 중에서 적절히 상황에 맞게 사용하면 좋습니다.&lt;br&gt;
끝으로 마틴 파울러의 &lt;a href=&quot;https://martinfowler.com/articles/injection.html&quot; target=&quot;_blank&quot;&gt;Inversion of Control Containers and the Dependency Injection pattern&lt;/a&gt; 글은 다음 포스팅에서 다룰 IoC와도 연관이 되지만 DI를 한 번 정리하는데 많은 도움이 되므로 같이 읽어보시면 더 좋습니다.&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;의존성 주입의 장점 - &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EC%84%B1_%EC%A3%BC%EC%9E%85&quot; target=&quot;_blank&quot;&gt;위키백과&lt;/a&gt;&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-2&quot;&gt;
&lt;p&gt;순환 참조? A가 B가 참조하고 B가 A를 참조하는 경우&lt;/p&gt;
&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Apache Kafka - 높은 처리량과 실시간으로 대량의 데이터를 취급하는 카프카]]></title><description><![CDATA[<p>import ResizeImage from 'components/ResizeImage'</p>
<p><a href="http://kafka.apache.org/" target="_blank">Apache Kafka</a>는 여러 대의 분산 서버에서 대량의 데이터를 처리하는 분산 메시징 시스템입니다.<br>
메시지를 받고, 받은 메시지를 다른 시스템이나 장치에 보내기 위해 사용하는데요, <code>높은 처리량과 실시간으로 대량의 데이터를 취급</code>하기 위해 초점을 맞췄으나 이제는 기능과 신뢰성을 향상시켜 현재는 데이터가 들어오는 대로 순차 실행하는 플랫폼이 되고 있습니다. 애플, 드롭박스, 넷플릭스, 트위터, 우버 등에서 카프카를 사용하고 있습니다.</p>
<p>오픈소스인 카프카는 링크드인에서 개발했습니다. 링크드인 웹사이트에서 생성되는 로그를 처리하여 웹사이트 활동을 추적하는 것을 목적으로 개발했습니다. 링크드인에서 누군가의 프로필을 조회하거나 아티클을 보거나 특정 키워드로 검색하거나 혹은 광고를 클릭하는 등의 모든 행위가 낳는 로그들은 매우 방대했습니다. 우리는 이것을 <strong>빅데이터</strong>라고 부릅니다. 이 빅데이터 파이프라인에서 카프카는 주요 멤버로 자리매김했습니다.</p>
<p>이처럼 방대한 양의 데이터를 카프카는 비동기로 처리할 수 있는 시스템으로 주목받고 있습니다. 현재 재직 중인 회사에서도 트래픽이 증가하고 새로운 프로세스들이 추가되면서 다양한 정보, 이벤트 로그가 기하급수적으로 늘어나 데이터 처리가 점점 방대해지면서 기존 RabbitMQ에서 Kafka로 마이그레이션 하면서 카프카를 접했습니다.</p>
<p>카프카를 사용하면서 주요하다고 생각한 개념과 실전 경험을 요약하여 정리했습니다.<br>
그럼 함께 살펴보시죠 :)</p>
<h2>카프카 특징</h2>
<ul>
<li>
<p><strong>높은 처리량으로 실시간 처리</strong></p>
<ul>
<li>방대한 엑세스 데이터를 처리해야 하기에 처리량이 우수해야 함</li>
<li>사용자의 활동을 신속하게 파악하거나 사용자의 활동에 따라 즉시 피드백하기 위함</li>
<li>실시간 처리는 수집부터 시작해 수백 밀리초에서 수 초 안에 데이터가 처리돼야 함</li>
</ul>
</li>
<li>
<p><strong>임의의 타이밍에서 데이터를 읽음</strong></p>
<ul>
<li>실시간이 아니어도 배치 처리를 할 수 있어야 함</li>
</ul>
</li>
<li>
<p><strong>다양한 제품과 시스템에 쉽게 연동</strong></p>
<ul>
<li>데이터베이스나 데이터 웨어하우스 등 다른 제품과의 연결이 쉬워야 함</li>
</ul>
</li>
<li>
<p><strong>메시지를 잃지 않아야 함</strong></p>
<ul>
<li>약간의 중복이 있더라도 데이터를 잃지 않는 것이 중요 / <code>At Least Once</code></li>
<li>건마다 엄격하게 관리하면 처리 오버헤드가 커짐</li>
<li>높은 처리량으로 실시간 처리라는 요건과의 균형을 가미함</li>
</ul>
</li>
</ul>
<p>카프카는 높은 처리량으로 실시간 처리하고 임의의 타이밍에 데이터를 읽고 다양한 제품과 시스템에 쉽게 연동하기 위해 메시징 모델을 채용합니다. 일반적인 메시징 모델은 다음 세 가지 요소로 구성됩니다.</p>
<ul>
<li>Producer : 메시지 생산자</li>
<li>Broker : 메시지 수집/전달 역할</li>
<li>Consumer : 메시지 소비자</li>
</ul>
<p><img src="https://baek.dev/assets/images/post/2020/2020_020_001.jpg"></p>
<p>카프카는 Message Queuing Model과 Pub/Sub Model의 특징을 겸비했습니다. 큐잉 모델에서 실현한 여러 컨슈머가 분산 처리로 메시지를 소비하는 모델을 도입했고, 펍/섭 메시징 모델에서 실현한 여러 subscriber들에게 동일한 메시지를 전달하고 토픽 기반으로 전달 내용을 변경하는 모델은 카프카에서 컨슈머 그룹이라는 개념을 도입하게 되었습니다.</p>
<p>카프카는 <strong>디스크 영속화를 함</strong>에도 높은 처리량을 제공하는 특징입니다. 데이터를 받아들이면서 한 묶음으로 장기 보존을 목적으로 영속화하기 때문에 카프카를 스토리지 시스템으로도 간주 할 수 있습니다. 그래서 <code>카프카는 메시지를 잃지 않는 전달 보증이 특징으로 Ack와 Offset Commit 개념</code>이 같이 생겼습니다.</p>
<ul>
<li>
<p><strong>Ack</strong></p>
<ul>
<li>브로커가 메시지를 수신했을 때 프로듀서에게 수신 완료했다는 응답</li>
</ul>
</li>
<li>
<p><strong>Offset Commit</strong></p>
<ul>
<li>컨슈머가 브로커로부터 메시지를 받을 때 컨슈머가 어디까지 메시지를 받았는지 관리</li>
</ul>
</li>
</ul>
<p><img src="https://baek.dev/assets/images/post/2020/2020_020_002.jpg"><br>
<img src="https://baek.dev/assets/images/post/2020/2020_020_003.jpg"></p>
<h2>카프카 5가지 구성 요소</h2>
<p><img src="https://baek.dev/assets/images/post/2020/2020_020_005.jpg"></p>
<ul>
<li>
<p><strong>Broker</strong></p>
<ul>
<li>데이터를 수신, 전달하는 서비스</li>
</ul>
</li>
<li>
<p><strong>Message</strong></p>
<ul>
<li>카프카에서 다루는 데이터의 최소 단위</li>
<li>메시지는 Key와 Value를 갖게 되며 나중에 언급할 메시지 전송할 때 파티셔닝에 이용</li>
</ul>
</li>
<li>
<p><strong>Producer</strong></p>
<ul>
<li>데이터의 생산자이며 브로커에 메시지를 보내는 애플리케이션</li>
</ul>
</li>
<li>
<p><strong>Consumer</strong></p>
<ul>
<li>브로커에서 메시지를 취득하는 애플리케이션</li>
</ul>
</li>
<li>
<p><strong>Topic</strong></p>
<ul>
<li>메시지를 종류별로 관리하는 스토리지</li>
<li>브로커에 배치되어 관리됨</li>
<li>프로듀서와 컨슈머는 특정 토픽을 지정하여 메시지를 송수신함으로써 단일 카프카 클러스터에서 여러 종류의 메시지를 중계함</li>
</ul>
</li>
</ul>
<h2>더 상세히 살펴보는 카프카 구성 요소</h2>
<p><img src="https://baek.dev/assets/images/post/2020/2020_020_006.jpg"></p>
<h3>Broker / 브로커</h3>
<p>브로커는 하나의 서버(또는 인스턴스) 당 하나의 데몬 프로세스로 동작하여 메시지 수신/전달 요청을 받아들입니다.<br>
이것을 여러 대의 클러스터로 구성할 수 있으며 브로커를 추가함으로써 수신/전달의 처리량 향상, 스케일 아웃이 가능합니다.<br>
브로커에서 받은 데이터는 모두 디스크로 내보내기(영속화)가 이루어져 디스크의 총 용량에 따라 장기간 데이터를 보존할 수 있습니다.</p>
<h3>Partition / 파티션</h3>
<p>토픽에 대한 대량의 메시지 입출력을 지원하기 위해, 브로커 상의 데이터를 읽고 쓰는 것은 파티션이라는 단위로 분할합니다.<br>
토픽을 구성하는 파티션은 브로커 클러스터 안에 분산 배치되며 프로듀서로부터 메시지 수신, 컨슈머에게 배달을 분산 실시함으로써 하나의 토픽에 대한 대규모 데이터 수신과 전달을 지원하게 됩니다.</p>
<ul>
<li>
<p><strong>적정 파티션 수</strong></p>
<ul>
<li>구성 및 요구 사항에 따라 다르기 때문에 시스템을 설계할 때 고려</li>
<li>메시지 처리 속도, 컨슈머 그룹 내 컨슈머 개수, 컨슈머내 스레드 수 등을 동시에 고려해야 함</li>
<li>파티션 수는 증가할 수는 있지만 한 번 증가한 파티션 수는 다시 줄일 수 없음</li>
</ul>
</li>
</ul>
<h3>Producer / 프로듀서</h3>
<p>프로듀서는 프로듀서 API를 이용하여 브로커에 데이터를 송신하기 위해 구현된 애플리케이션입니다.<br>
각종 로그 전송 및 미들웨어와 연동하여 동작하기 때문에 프로듀서 API를 내포한 도구, 미들웨어를 통해 이용하는 형태 등으로 다양합니다.</p>
<ul>
<li>프로듀서가 토픽의 파티션에 메시지를 송신할 때 버퍼 기능처럼 프로듀서의 메모리를 이용하여 일정량을 축적 후 송신</li>
<li>
<p>데이터의 송신에 대해서는 지정한 크기까지 메시지가 축적되거나</p>
<ul>
<li>batch.size</li>
</ul>
</li>
<li>
<p>지정한 대기 시간에 도달하는 것 중 하나를 트리거로 전송</p>
<ul>
<li>linger.ms</li>
</ul>
</li>
<li>
<p>토픽에 메시지 전송 시 파티셔닝</p>
<ul>
<li><code>Key의 해시값을 사용한 송신</code></li>
<li>메시지는 Key와 Value로 이뤄져 있는데 이 Key를 이용하여 송신처 파티션을 결정</li>
<li>동일한 Key를 가진 메시지는 동일한 ID를 가진 파티션에 송신</li>
<li><strong>partitionkey를 이용하면 메시지 순서 보장이 가능하나 대신 imbalance를 챙겨야 함</strong></li>
<li>라운드 로빈에 의한 송신</li>
<li>메시지 Key를 지정하지 않고 Null로 한 경우 여러 파티션으로 메시지 송신을 라운드 로빈 방식으로 실행</li>
<li><img src="https://baek.dev/assets/images/post/2020/2020_020_009.jpg"></li>
</ul>
</li>
<li>
<p>callback을 통해 브로커로 메시지 송신 결과를 비동기 처리 할 수 있음</p>
<ul>
<li><strong>future.get()</strong>을 하면 브로커 상태와 설정에 따라 쓰레드가 무한 점유될 수 있으므로 <strong>매우 위험</strong></li>
<li><a href="https://www.baeldung.com/java-completablefuture" target="_blank">CompletableFuture</a>를 이용</li>
</ul>
</li>
</ul>
<h3>Consumer</h3>
<p>컨슈머 API를 이용해 브로커에서 메시지를 취득하도록 구현된 애플리케이션입니다. 브로커는 메시지를 디스크에 영속화하기 위해 브로커에 도달하는 즉시 컨슈머에서 취득해야 하는 제약이 없어 디스크에 보관된 동안은 메시지 취득이 가능합니다. 일정 기간 데이터를 축적한 스토리지에서 데이터 추출 및 시간 처리를 위한 애플리케이션의 데이터 입력 등으로 이용됩니다.</p>
<ul>
<li>RetryTemplate 등을 통해 컨슈머 장애시 재처리를 시도하도록 해야함</li>
</ul>
<!-- <script src="https://gist.github.com/baekdev/d7cff37e191d632dca3a9d9cf662bfcb.js"></script> -->
<pre><code class="language-java">import org.apache.kafka.clients.producer.*;

import java.util.Properties;

public class FirstAppProducer {

    private static String topicName = "first-app";

    public static void main(String[] args) {

        // 1. KafkaProducer에 필요한 설정
        Properties conf = new Properties();
        conf.setProperty("bootstrap.servers", "kafka-broker01:9092,kafka-broker02:9092,kafka-broker03:9092");
        conf.setProperty("key.serializer", "org.apache.kafka.common.serialization.IntegerSerializer");
        conf.setProperty("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");

        // 2. Kafka 클러스터에 메시지를 송신(produce)하는 객체를 생성
        Producer&#x3C;Integer, String> producer = new KafkaProducer&#x3C;>(conf);

        int key;
        String value;
        for(int i = 1; i &#x3C;= 100; i++) {
            key = i;
            value = String.valueOf(i);

            // 3. 송신할 메시지를 생성
            ProducerRecord&#x3C;Integer, String> record = new ProducerRecord&#x3C;>(topicName, key, value);

            // 4. 메시지를 송신하고, Ack을 받았을 때에 실행할 작업(Callback)을 등록한다
            producer.send(record, new Callback() {
                @Override
                public void onCompletion(RecordMetadata metadata, Exception e) {
                    if( metadata != null) {
                        // 송신에 성공한 경우의 처리
                        String infoString = String.format("Success partition:%d, offset:%d", metadata.partition(), metadata.offset());
                        System.out.println(infoString);
                    } else {
                        // 송신에 실패한 경우의 처리
                        String infoString = String.format("Failed:%s", e.getMessage());
                        System.err.println(infoString);
                    }
                }
            });
        }

        // 5. KafkaProducer를 클로즈하여 종료
        producer.close();
    }
}
</code></pre>
<pre><code class="language-java">import org.apache.kafka.clients.consumer.*;
import org.apache.kafka.common.TopicPartition;
import java.util.*;

public class FirstAppConsumer {

    private static String topicName = "first-app";

    public static void main( String[] args ) {

        // 1. KafkaConsumer에 필요한 설정
        Properties conf = new Properties();
        conf.setProperty("bootstrap.servers", "kafka-broker01:9092,kafka-broker02:9092,kafka-broker03:9092");
        conf.setProperty("group.id", "FirstAppConsumerGroup");
        conf.setProperty("enable.auto.commit", "false");
        conf.setProperty("key.deserializer", "org.apache.kafka.common.serialization.IntegerDeserializer");
        conf.setProperty("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer");

        // 2. Kafka클러스터에서 Message를 수신(Consume)하는 객체를 생성
        Consumer&#x3C;Integer, String> consumer = new KafkaConsumer&#x3C;>(conf);

        // 3. 수신(subscribe)하는 Topic을 등록
        consumer.subscribe(Collections.singletonList(topicName));

        for(int count = 0; count &#x3C; 300; count++) {
            // 4. Message를 수신하여, 콘솔에 표시한다
            ConsumerRecords&#x3C;Integer, String> records = consumer.poll(1);
            for(ConsumerRecord&#x3C;Integer, String> record: records) {
                String msgString = String.format("key:%d, value:%s", record.key(), record.value());
                System.out.println(msgString);

                // 5. 처리가 완료한 Message의 Offset을 Commit한다
                TopicPartition tp = new TopicPartition(record.topic(), record.partition());
                OffsetAndMetadata oam = new OffsetAndMetadata(record.offset() + 1);
                Map&#x3C;TopicPartition, OffsetAndMetadata> commitInfo = Collections.singletonMap(tp, oam);
                consumer.commitSync(commitInfo);
            }
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex ) {
                ex.printStackTrace();
            }
        }

        // 6. KafkaConsumer를 클로즈하여 종료
        consumer.close();
    }
}
</code></pre>
<h3>Consumer Group</h3>
<p>카프카에서는 컨슈머가 카프카 클러스터에서 메시지를 얻어 처리합니다. 이때 컨슈머는 컨슈머그룹이라 불리는 하나 이상의 컨슈머들로 이루어진 그룹을 형성하여 메시지를 얻습니다. 컨슈머 그룹은 Group ID라는 ID로 구분됩니다. 이 Group ID는 KafkaConsumer를 생성할 떄 지정하는 옵션으로 <code>group.id</code>라는 파라미터로 지정하며, 특정 컨슈머는 여러 컨슈머 그룹에 속하지 않고 항상 하나의 컨슈머 그룹에 속합니다.<br>
카프카 클러스터에서 수신할 메시지는 컨슈머 그룹 안에서 어느 하나의 컨슈머가 수신합니다. 즉, <strong>카프카 클러스터에서 수신할 메시지를 동일 컨슈머 그룹에 속하는 컨슈머 사이에서 분산하여 수신</strong>합니다. 이는 컨슈머에서 분산 스트림 처리도 고려해 설계된 것입니다.</p>
<p>메시지를 컨슈머 그룹의 어느 컨슈머가 수신하는가에 대한 할당은 수신할 토픽에 존재하는 파티션과 그룹 내 컨슈머를 매핑함으로써 가능합니다. 컨슈머와 파티션의 매핑은 각 파티션에 반드시 하나의 컨슈머가 매핑됩니다. 반대로 파티션 수에 따라 하나의 컨슈머에 여러 파티션이 할당되는 경우가 있습니다. 컨슈머 그룹에서 기대한 대로 분산하여 메시지를 수신하기 위해서는 <code>파티션 수가 적어도 각 컨슈머 그룹에 속하는 컨슈머보다 많아야 합니다.</code> 토픽의 파티션보다 컨슈머 쪽이 많을 경우 파티션이 할당되지 않은 컨슈머가 발생할 수 있습니다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_020_017.jpg"></p>
<p>컨슈머를 생성할 때 partition.assignment.strategy 옵션을 활용하면 Assignor<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>를 선택할 수 있습니다.</p>
<h3>Offset</h3>
<p><img src="https://baek.dev/assets/images/post/2020/2020_020_007.jpg"></p>
<ul>
<li>각 파티션에서 수신한 메시지에는 각각 일려번호를 부여</li>
<li>파티션 단위로 메시지 위치를 나타내는 오프셋이라는 관리 정보를 이용해 컨슈머가 취득하는 메시지의 범위 및 재시도를 제어</li>
<li>
<p>오프셋 설정 값 종류</p>
<ul>
<li>Log-End-Offsset(LEO) : 파티션 데이터의 끝</li>
<li>Current Offset : 컨슈머가 어디까지 메시지를 읽었는가를 나타냄</li>
<li>Commit Offset : 컨슈머가 어디까지 커밋했는지를 나타냄</li>
<li>컨슈머는 메시지에 대해 확인했음을 다시 브로커에게 알리는데 이것이 바로 Commit Offset임</li>
</ul>
</li>
<li>
<p><strong>자동 오프셋 리셋</strong></p>
<ul>
<li>컨슈머가 시작할 때 오프셋 커밋 기록이 존재하지 않거나 기록되어 있어도 유효하지 않은 경우 사용하는 정책</li>
<li>유효하지 않은 경우는 메시지가 retention이 지나 없는 경우</li>
<li>컨슈머 애플리케이션에서 컨슈머를 생성할 때 지정하는 <code>auto.offset.reset=earliest</code> 옵션으로 설정</li>
<li>
<table>
<thead>
<tr>
<th>정책</th>
<th>자동 오프셋 리셋의 동작</th>
</tr>
</thead>
<tbody>
<tr>
<td>latest</td>
<td>- 해당 파티션의 가장 새로운 오프셋으로 초기화- 카프카 클러스터에 이미 존재하는 메시지는 처리 되지 않음</td>
</tr>
<tr>
<td>earliest</td>
<td>- 해당 파티션에 존재하는 가장 오래된 오프셋으로 초기화- 카프카 클러스터에 이미 존재하는 메시지 모두에 대해 처리 실시</td>
</tr>
<tr>
<td>none</td>
<td>- 유효한 오프셋 커밋 정보가 없는 경우에 예외를 반환- seek() 메서드 등으로 명시적으로 오프셋을 지정해야 함</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<h3>Offset Commit</h3>
<p>컨슈머는 어느 메시지까지 처리를 완료했는지 카프카 클러스터에 기록을 남길 수 있습니다. 정확하게는 <code>다음 수신 및 처리해야 할 메시지의 오프셋 기록</code>입니다.<br>
오프셋 커밋의 기록은 컨슈머 그룹 단위로 이루어집니다. 컨슈머 그룹마다 각 토픽의 파티션에서 어느 오프셋까지 처리 완료했는지 정보를 기록합니다.
오프셋 커밋은 처리 완료 여부를 메시지마다 기록하는 것이 아니라 <strong>처리를 완료한 메시지 중에서 최대의 오프셋을 기록</strong>하는 형태로 이루어집니다.<br>
이것은 카프카가 임의로 메시지를 처리하는 것이 아니라 <strong>파티션 안의 메시지를 연속적으로 처리하는 것을 가정</strong>하고 있기 때문입니다.</p>
<ul>
<li>중간에 메시지가 처리되지 않을 경우 무한 루프가 돌 수 있음 (수기로 메시지 커밋 하는 경우)</li>
<li><code>__consumer_offsets</code> 라는 전용 토픽에 기록</li>
<li>
<p><strong>Auto Offset Commit</strong></p>
<ul>
<li>자동 오프셋 커밋은 일정 간격마다 자동으로 오프셋 커밋을 하는 방식</li>
<li><code>enable.auto.commit=true</code> 설정</li>
<li><code>auto.commit.interval.ms=5000</code> 설정을 통해 오프셋 커밋의 간격 설정. 기본 5초</li>
<li><img src="https://baek.dev/assets/images/post/2020/2020_020_018.jpg"></li>
<li>장점 : 컨슈머는 오프셋 커밋을 명시적으로 실시할 필요가 없음</li>
<li>단점 : 컨슈머 장애가 발생했을 때 메시지가 손실되거나 메시지 중복이 발생할 수 있음</li>
<li><img src="https://baek.dev/assets/images/post/2020/2020_020_019.jpg"></li>
</ul>
</li>
<li>
<p><strong>Manual Offset Commit</strong></p>
<ul>
<li><code>enable.auto.commit=false</code> 설정</li>
<li><code>commitSync()</code> 메서드를 통해 오프셋을 수동으로 커밋할 수 있음</li>
<li>애플리케이션 안에서 언제라도 오프셋 커밋을 수행할 수 있음</li>
<li>카프카 클러스터에서 메시지 취득 후 메시지 처리가 완료한 시점에서 커밋</li>
<li>장점</li>
<li>해당 메시지 처리는 반드시 완료되어 있기 때문에 메시지 손실이 발생하지 않음</li>
<li>컨슈머 장애 발생 시 메시지 중복을 최소화 할 수 있음</li>
<li>단점</li>
<li>메시지 양에 따라 다르지만, 수동 오프셋 커밋이 자주 커밋 처리를 하므로 카프카 클러스터 부하가 높아진다는 점에는 주의가 필요</li>
<li><img src="https://baek.dev/assets/images/post/2020/2020_020_020.jpg"></li>
</ul>
</li>
</ul>
<h3>ZooKeeper</h3>
<p>카프카의 브로커에 있어 분산 처리를 위한 관리 도구로 Apache ZooKeeper가 필요합니다. 주키퍼는 하둡 등 병렬 분산 처리용 OSS에 있어서 설정 관리, 이름 관리, 동기화를 위한 잠금 관리를 하는 구조로 자주 사용됩니다. 카프카에 있었어서는 분산 메시징의 메타 데이터(토픽과 파티션 등)를 관리하기 위한 구성 요소로 기능합니다. 주키퍼 클러스터는 주키퍼 앙상블이라고도 하며 <strong>구조상 3,5 처럼 홀수로 구성</strong>하는 것이 일반적입니다.</p>
<h3>카프카 클러스터</h3>
<p>카프카는 여러 대의 브로커 서버, 주키퍼 서버로 이루어진 클러스터링의 메시지 중계 기능과 메시지 송수신을 위한 라이브러리 그룹으로 구성됩니다.</p>
<h2>카프카 데이터 견고함을 담보하는 복제의 구조</h2>
<h3>Replica / 레플리카</h3>
<p>카프카는 메시지를 중계함과 동시에 서버가 고장 났을 때 수신한 메시지를 잃지 않기 위해 복제(Replication) 구조를 갖추고 있습니다. <strong>레플리카 중 하나는 Leader이며, 나머지는 Follower</strong>라고 불립니다. Follower는 그 이름대로 Leader로부터 메시지를 계속적으로 취득하여 복제를 유지하도록 동작합니다. <strong>다만 프로듀서/컨슈머와의 데이터 교환은 Leader가 맡고 있습니다.</strong></p>
<p>Leader Replica의 복제 상태를 유지하고 있는 레플리카는 <code>In-Sync Replica(ISR)</code>로 분류됩니다. 또한 복제 수와는 독립적으로 <code>최소 ISR 수(min.insync.replicas) 설정</code>이 가능합니다. 고장 등으로 인한 일시적인 동기 지연을 허용하여 전체 읽고 쓰기를 계속하는 것이 가능합니다.</p>
<p>복제 사용 시 오프셋 관리에는 LEO(Log End Offset) 이외에 High Watermark라는 개념이 있습니다. <strong>Hight Watermark는 복제가 완료된 오프셋</strong>이며, 그 성질에서 반드시 LEO와 동일하거나 오래된 오프셋을 나타냅니다. <code>컨슈머는 High Watermark까지 기록된 메시지를 취득할 수 있습니다.</code></p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_020_012.jpg"></p>
<h3>Ack</h3>
<p>복제에 대한 중요한 구성 요소로 프로듀서의 메시지 송신 시 Ack 설정에 대해 알아보겠습니다. <code>브로커에서 프로듀서로 메시지가 송신된 것을 나타내는 Ack</code>를 어느 타이밍에 송신할 것인지를 제어하는 것은 성능과 내장애성(브로커 서버 고장 시 데이터 분실 방지)에 큰 영향을 줍니다.</p>
<table>
<thead>
<tr>
<th>Ack 설정</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>프로듀서는 메시지 송신 시 Ack를 기다리지 않고 다음 메시지를 송신함</td>
</tr>
<tr>
<td>1</td>
<td>Leader Replica에 메시지가 전달되면 Ack를 반환</td>
</tr>
<tr>
<td>All</td>
<td>모든 ISR의 수만큼 복제되면 Ack를 반환</td>
</tr>
</tbody>
</table>
<p><strong>프로듀서는 타임아웃 설정으로 Ack가 돌아오지 않고 타임아웃된 Send 처리를 '송신 실패'로 감지</strong>합니다. 참고로 Ack를 1 또는 all로 설정했을 경우 변환 타이밍이 의미하는 것은 각 복제에 '메시지가 전달'된 것으로 판단해 Ack를 반환하는 타이밍입니다. 이 타이밍에는 <strong>메시지가 디스크에 flush되는 것이 아니라 메모리(OS 버퍼)에 기록</strong>됩니다. 디스크에 flush하는 영속화 타이밍은 다른 속성에서 제어합니다.</p>
<h3>In-Sync Replica</h3>
<p><strong>min.insync.replicas 설정은 서버 고장 시 '메시지를 잃지 않는 것'과 '메시징 시스템을 포함한 전체 시스템의 처리를 계속하는 것'사이의 균형을 조정합니다.</strong><br>
아래 예시 중 어느 것이 뛰어나다는 것이 아니라 시스템 요구 사항과 제약 조건에 의해 결정돼야 한다는 점에 주의해야 합니다.</p>
<table>
<thead>
<tr>
<th colspan="2">
<code>In-Sync Replica와 Ack = all, 쓰기 계속성의 관계</code>
</th>
</tr><tr>
<th colspan="2">
브로커는 4대 레플리카 수는 3으로 브로커 1대가 고장나 레플리카를 하나 잃어버린 경우
</th>
</tr>
<tr>
<th>설정</th>
<th>상황</th>
</tr>
</thead>
<tbody>
<tr>
<td>
min.insync.replicas=3
Ack=all인 경우</td>
<td>브로커 서버가 1대 고장난 경우 프로듀서는 비정상 상태로 간주하여잃어버린 레플리카가 ISR로 복귀할 때까지 데이터를 쓸 수 없음</td>
</tr>
<tr>
<td colspan="2"><ResizeImage src="https://baek.dev/assets/images/post/2020/2020_020_013.jpg" /></td>
</tr>
<tr>
<td>
min.insync.replicas=2
Ack=all인 경우</td>
<td>
- 브로커 서버가 1대 고장난 경우에도 Ack를 반환하고 처리하고 처리를 계속함  
- 처리를 계속하는 점에 있어서는 위보다 나은 반면
- 나중에 추가된 파티션이 복제를 완료해 ISR로 승격될 떄까지 복제수가 2가 됨  
- 복구 전에 2대가 고장난 경우는 처리 중인 메시지를 손실할 위험이 높아짐
</td>
</tr>
<tr>
<td colspan="2"><ResizeImage src="https://baek.dev/assets/images/post/2020/2020_020_014.jpg" /></td>
</tr>
</tbody>
</table>
<p><code>min.insync.replicas</code>는 프로듀서와 메시지를 보낼 때 송신처 파티션의 복제본 중 ISR에 속하는 복제본이 최소 몇 개나 필요한지를 설정하는 브로커와 토픽의 구성입니다. 브로커는 메시지를 수신한 직후에 특정 브로커에 장애가 발생했다고 해도 메시지를 분실하지 않기 위한 안정장치 역할을 합니다. <strong>장애 허용 대수</strong>만큼의 브로커에 장애가 발생했을 때 카프카 클러스터에 영향 없이 서비스를 계속하기 위해서는 <code>모든 파티션에서 ISR에 속하는 복제본의 수가 min.insync.replicas 수 이상</code>이어야 합니다.</p>
<hr>
<p>위 내용은 <a href="https://coupa.ng/bwkNyn" target="_blank">실전 아파치 카프카</a>를 읽고 제 경험을 추가하여 정리한 내용으로 카프카 도입 예정이신 분들은 읽어보시면 도움 될 책입니다.<br>
그럼 다음 편에서는 카프카 예제 코드로 찾아 뵙겠습니다.</p>
<p><strong>참고하면 좋은 글</strong></p>
<ul>
<li><a href="https://www.linkedin.com/pulse/kafka-technical-overview-sylvester-daniel" target="_blank">Kafka Technical Overview</a></li>
<li><a href="https://www.popit.kr/kafka-%EC%9A%B4%EC%98%81%EC%9E%90%EA%B0%80-%EB%A7%90%ED%95%98%EB%8A%94-producer-acks/" target="_blank">Kafka 운영자가 말하는 Producer ACKS</a></li>
<li><a href="https://kafka.apache.org/documentation/#configuration" target="_blank">Apache Kafka - CONFIGURATION</a></li>
</ul>
<div class="footnotes">
<hr>
<ol>
<li id="fn-1">
<p><a href="http://kafka.apache.org/20/javadoc/org/apache/kafka/clients/consumer/RoundRobinAssignor.html">Round Robin Assingor</a> / <a href="http://kafka.apache.org/20/javadoc/org/apache/kafka/clients/consumer/StickyAssignor.html">Sticky Assignor</a> / <a href="http://kafka.apache.org/20/javadoc/org/apache/kafka/clients/consumer/RangeAssignor.html">Range Assignor</a></p>
<a href="#fnref-1" class="footnote-backref">↩</a>
</li>
</ol>
</div>]]></description><link>https://baek.dev/post/20/</link><guid isPermaLink="false">https://baek.dev/post/20/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 29 Mar 2020 13:05:00 GMT</pubDate><content:encoded>&lt;p&gt;import ResizeImage from &apos;components/ResizeImage&apos;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://kafka.apache.org/&quot; target=&quot;_blank&quot;&gt;Apache Kafka&lt;/a&gt;는 여러 대의 분산 서버에서 대량의 데이터를 처리하는 분산 메시징 시스템입니다.&lt;br&gt;
메시지를 받고, 받은 메시지를 다른 시스템이나 장치에 보내기 위해 사용하는데요, &lt;code&gt;높은 처리량과 실시간으로 대량의 데이터를 취급&lt;/code&gt;하기 위해 초점을 맞췄으나 이제는 기능과 신뢰성을 향상시켜 현재는 데이터가 들어오는 대로 순차 실행하는 플랫폼이 되고 있습니다. 애플, 드롭박스, 넷플릭스, 트위터, 우버 등에서 카프카를 사용하고 있습니다.&lt;/p&gt;
&lt;p&gt;오픈소스인 카프카는 링크드인에서 개발했습니다. 링크드인 웹사이트에서 생성되는 로그를 처리하여 웹사이트 활동을 추적하는 것을 목적으로 개발했습니다. 링크드인에서 누군가의 프로필을 조회하거나 아티클을 보거나 특정 키워드로 검색하거나 혹은 광고를 클릭하는 등의 모든 행위가 낳는 로그들은 매우 방대했습니다. 우리는 이것을 &lt;strong&gt;빅데이터&lt;/strong&gt;라고 부릅니다. 이 빅데이터 파이프라인에서 카프카는 주요 멤버로 자리매김했습니다.&lt;/p&gt;
&lt;p&gt;이처럼 방대한 양의 데이터를 카프카는 비동기로 처리할 수 있는 시스템으로 주목받고 있습니다. 현재 재직 중인 회사에서도 트래픽이 증가하고 새로운 프로세스들이 추가되면서 다양한 정보, 이벤트 로그가 기하급수적으로 늘어나 데이터 처리가 점점 방대해지면서 기존 RabbitMQ에서 Kafka로 마이그레이션 하면서 카프카를 접했습니다.&lt;/p&gt;
&lt;p&gt;카프카를 사용하면서 주요하다고 생각한 개념과 실전 경험을 요약하여 정리했습니다.&lt;br&gt;
그럼 함께 살펴보시죠 :)&lt;/p&gt;
&lt;h2&gt;카프카 특징&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;높은 처리량으로 실시간 처리&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;방대한 엑세스 데이터를 처리해야 하기에 처리량이 우수해야 함&lt;/li&gt;
&lt;li&gt;사용자의 활동을 신속하게 파악하거나 사용자의 활동에 따라 즉시 피드백하기 위함&lt;/li&gt;
&lt;li&gt;실시간 처리는 수집부터 시작해 수백 밀리초에서 수 초 안에 데이터가 처리돼야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;임의의 타이밍에서 데이터를 읽음&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실시간이 아니어도 배치 처리를 할 수 있어야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;다양한 제품과 시스템에 쉽게 연동&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스나 데이터 웨어하우스 등 다른 제품과의 연결이 쉬워야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;메시지를 잃지 않아야 함&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;약간의 중복이 있더라도 데이터를 잃지 않는 것이 중요 / &lt;code&gt;At Least Once&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;건마다 엄격하게 관리하면 처리 오버헤드가 커짐&lt;/li&gt;
&lt;li&gt;높은 처리량으로 실시간 처리라는 요건과의 균형을 가미함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;카프카는 높은 처리량으로 실시간 처리하고 임의의 타이밍에 데이터를 읽고 다양한 제품과 시스템에 쉽게 연동하기 위해 메시징 모델을 채용합니다. 일반적인 메시징 모델은 다음 세 가지 요소로 구성됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Producer : 메시지 생산자&lt;/li&gt;
&lt;li&gt;Broker : 메시지 수집/전달 역할&lt;/li&gt;
&lt;li&gt;Consumer : 메시지 소비자&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_020_001.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;카프카는 Message Queuing Model과 Pub/Sub Model의 특징을 겸비했습니다. 큐잉 모델에서 실현한 여러 컨슈머가 분산 처리로 메시지를 소비하는 모델을 도입했고, 펍/섭 메시징 모델에서 실현한 여러 subscriber들에게 동일한 메시지를 전달하고 토픽 기반으로 전달 내용을 변경하는 모델은 카프카에서 컨슈머 그룹이라는 개념을 도입하게 되었습니다.&lt;/p&gt;
&lt;p&gt;카프카는 &lt;strong&gt;디스크 영속화를 함&lt;/strong&gt;에도 높은 처리량을 제공하는 특징입니다. 데이터를 받아들이면서 한 묶음으로 장기 보존을 목적으로 영속화하기 때문에 카프카를 스토리지 시스템으로도 간주 할 수 있습니다. 그래서 &lt;code&gt;카프카는 메시지를 잃지 않는 전달 보증이 특징으로 Ack와 Offset Commit 개념&lt;/code&gt;이 같이 생겼습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ack&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;브로커가 메시지를 수신했을 때 프로듀서에게 수신 완료했다는 응답&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Offset Commit&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;컨슈머가 브로커로부터 메시지를 받을 때 컨슈머가 어디까지 메시지를 받았는지 관리&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_020_002.jpg&quot;&gt;&lt;br&gt;
&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_020_003.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;카프카 5가지 구성 요소&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_020_005.jpg&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Broker&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터를 수신, 전달하는 서비스&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Message&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;카프카에서 다루는 데이터의 최소 단위&lt;/li&gt;
&lt;li&gt;메시지는 Key와 Value를 갖게 되며 나중에 언급할 메시지 전송할 때 파티셔닝에 이용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Producer&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터의 생산자이며 브로커에 메시지를 보내는 애플리케이션&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Consumer&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;브로커에서 메시지를 취득하는 애플리케이션&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Topic&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메시지를 종류별로 관리하는 스토리지&lt;/li&gt;
&lt;li&gt;브로커에 배치되어 관리됨&lt;/li&gt;
&lt;li&gt;프로듀서와 컨슈머는 특정 토픽을 지정하여 메시지를 송수신함으로써 단일 카프카 클러스터에서 여러 종류의 메시지를 중계함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;더 상세히 살펴보는 카프카 구성 요소&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_020_006.jpg&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Broker / 브로커&lt;/h3&gt;
&lt;p&gt;브로커는 하나의 서버(또는 인스턴스) 당 하나의 데몬 프로세스로 동작하여 메시지 수신/전달 요청을 받아들입니다.&lt;br&gt;
이것을 여러 대의 클러스터로 구성할 수 있으며 브로커를 추가함으로써 수신/전달의 처리량 향상, 스케일 아웃이 가능합니다.&lt;br&gt;
브로커에서 받은 데이터는 모두 디스크로 내보내기(영속화)가 이루어져 디스크의 총 용량에 따라 장기간 데이터를 보존할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;Partition / 파티션&lt;/h3&gt;
&lt;p&gt;토픽에 대한 대량의 메시지 입출력을 지원하기 위해, 브로커 상의 데이터를 읽고 쓰는 것은 파티션이라는 단위로 분할합니다.&lt;br&gt;
토픽을 구성하는 파티션은 브로커 클러스터 안에 분산 배치되며 프로듀서로부터 메시지 수신, 컨슈머에게 배달을 분산 실시함으로써 하나의 토픽에 대한 대규모 데이터 수신과 전달을 지원하게 됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;적정 파티션 수&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;구성 및 요구 사항에 따라 다르기 때문에 시스템을 설계할 때 고려&lt;/li&gt;
&lt;li&gt;메시지 처리 속도, 컨슈머 그룹 내 컨슈머 개수, 컨슈머내 스레드 수 등을 동시에 고려해야 함&lt;/li&gt;
&lt;li&gt;파티션 수는 증가할 수는 있지만 한 번 증가한 파티션 수는 다시 줄일 수 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Producer / 프로듀서&lt;/h3&gt;
&lt;p&gt;프로듀서는 프로듀서 API를 이용하여 브로커에 데이터를 송신하기 위해 구현된 애플리케이션입니다.&lt;br&gt;
각종 로그 전송 및 미들웨어와 연동하여 동작하기 때문에 프로듀서 API를 내포한 도구, 미들웨어를 통해 이용하는 형태 등으로 다양합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로듀서가 토픽의 파티션에 메시지를 송신할 때 버퍼 기능처럼 프로듀서의 메모리를 이용하여 일정량을 축적 후 송신&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;데이터의 송신에 대해서는 지정한 크기까지 메시지가 축적되거나&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;batch.size&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;지정한 대기 시간에 도달하는 것 중 하나를 트리거로 전송&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;linger.ms&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;토픽에 메시지 전송 시 파티셔닝&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Key의 해시값을 사용한 송신&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;메시지는 Key와 Value로 이뤄져 있는데 이 Key를 이용하여 송신처 파티션을 결정&lt;/li&gt;
&lt;li&gt;동일한 Key를 가진 메시지는 동일한 ID를 가진 파티션에 송신&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;partitionkey를 이용하면 메시지 순서 보장이 가능하나 대신 imbalance를 챙겨야 함&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;라운드 로빈에 의한 송신&lt;/li&gt;
&lt;li&gt;메시지 Key를 지정하지 않고 Null로 한 경우 여러 파티션으로 메시지 송신을 라운드 로빈 방식으로 실행&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_020_009.jpg&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;callback을 통해 브로커로 메시지 송신 결과를 비동기 처리 할 수 있음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;future.get()&lt;/strong&gt;을 하면 브로커 상태와 설정에 따라 쓰레드가 무한 점유될 수 있으므로 &lt;strong&gt;매우 위험&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.baeldung.com/java-completablefuture&quot; target=&quot;_blank&quot;&gt;CompletableFuture&lt;/a&gt;를 이용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Consumer&lt;/h3&gt;
&lt;p&gt;컨슈머 API를 이용해 브로커에서 메시지를 취득하도록 구현된 애플리케이션입니다. 브로커는 메시지를 디스크에 영속화하기 위해 브로커에 도달하는 즉시 컨슈머에서 취득해야 하는 제약이 없어 디스크에 보관된 동안은 메시지 취득이 가능합니다. 일정 기간 데이터를 축적한 스토리지에서 데이터 추출 및 시간 처리를 위한 애플리케이션의 데이터 입력 등으로 이용됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RetryTemplate 등을 통해 컨슈머 장애시 재처리를 시도하도록 해야함&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- &lt;script src=&quot;https://gist.github.com/baekdev/d7cff37e191d632dca3a9d9cf662bfcb.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import org.apache.kafka.clients.producer.*;

import java.util.Properties;

public class FirstAppProducer {

    private static String topicName = &quot;first-app&quot;;

    public static void main(String[] args) {

        // 1. KafkaProducer에 필요한 설정
        Properties conf = new Properties();
        conf.setProperty(&quot;bootstrap.servers&quot;, &quot;kafka-broker01:9092,kafka-broker02:9092,kafka-broker03:9092&quot;);
        conf.setProperty(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.IntegerSerializer&quot;);
        conf.setProperty(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);

        // 2. Kafka 클러스터에 메시지를 송신(produce)하는 객체를 생성
        Producer&amp;#x3C;Integer, String&gt; producer = new KafkaProducer&amp;#x3C;&gt;(conf);

        int key;
        String value;
        for(int i = 1; i &amp;#x3C;= 100; i++) {
            key = i;
            value = String.valueOf(i);

            // 3. 송신할 메시지를 생성
            ProducerRecord&amp;#x3C;Integer, String&gt; record = new ProducerRecord&amp;#x3C;&gt;(topicName, key, value);

            // 4. 메시지를 송신하고, Ack을 받았을 때에 실행할 작업(Callback)을 등록한다
            producer.send(record, new Callback() {
                @Override
                public void onCompletion(RecordMetadata metadata, Exception e) {
                    if( metadata != null) {
                        // 송신에 성공한 경우의 처리
                        String infoString = String.format(&quot;Success partition:%d, offset:%d&quot;, metadata.partition(), metadata.offset());
                        System.out.println(infoString);
                    } else {
                        // 송신에 실패한 경우의 처리
                        String infoString = String.format(&quot;Failed:%s&quot;, e.getMessage());
                        System.err.println(infoString);
                    }
                }
            });
        }

        // 5. KafkaProducer를 클로즈하여 종료
        producer.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import org.apache.kafka.clients.consumer.*;
import org.apache.kafka.common.TopicPartition;
import java.util.*;

public class FirstAppConsumer {

    private static String topicName = &quot;first-app&quot;;

    public static void main( String[] args ) {

        // 1. KafkaConsumer에 필요한 설정
        Properties conf = new Properties();
        conf.setProperty(&quot;bootstrap.servers&quot;, &quot;kafka-broker01:9092,kafka-broker02:9092,kafka-broker03:9092&quot;);
        conf.setProperty(&quot;group.id&quot;, &quot;FirstAppConsumerGroup&quot;);
        conf.setProperty(&quot;enable.auto.commit&quot;, &quot;false&quot;);
        conf.setProperty(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.IntegerDeserializer&quot;);
        conf.setProperty(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);

        // 2. Kafka클러스터에서 Message를 수신(Consume)하는 객체를 생성
        Consumer&amp;#x3C;Integer, String&gt; consumer = new KafkaConsumer&amp;#x3C;&gt;(conf);

        // 3. 수신(subscribe)하는 Topic을 등록
        consumer.subscribe(Collections.singletonList(topicName));

        for(int count = 0; count &amp;#x3C; 300; count++) {
            // 4. Message를 수신하여, 콘솔에 표시한다
            ConsumerRecords&amp;#x3C;Integer, String&gt; records = consumer.poll(1);
            for(ConsumerRecord&amp;#x3C;Integer, String&gt; record: records) {
                String msgString = String.format(&quot;key:%d, value:%s&quot;, record.key(), record.value());
                System.out.println(msgString);

                // 5. 처리가 완료한 Message의 Offset을 Commit한다
                TopicPartition tp = new TopicPartition(record.topic(), record.partition());
                OffsetAndMetadata oam = new OffsetAndMetadata(record.offset() + 1);
                Map&amp;#x3C;TopicPartition, OffsetAndMetadata&gt; commitInfo = Collections.singletonMap(tp, oam);
                consumer.commitSync(commitInfo);
            }
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex ) {
                ex.printStackTrace();
            }
        }

        // 6. KafkaConsumer를 클로즈하여 종료
        consumer.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Consumer Group&lt;/h3&gt;
&lt;p&gt;카프카에서는 컨슈머가 카프카 클러스터에서 메시지를 얻어 처리합니다. 이때 컨슈머는 컨슈머그룹이라 불리는 하나 이상의 컨슈머들로 이루어진 그룹을 형성하여 메시지를 얻습니다. 컨슈머 그룹은 Group ID라는 ID로 구분됩니다. 이 Group ID는 KafkaConsumer를 생성할 떄 지정하는 옵션으로 &lt;code&gt;group.id&lt;/code&gt;라는 파라미터로 지정하며, 특정 컨슈머는 여러 컨슈머 그룹에 속하지 않고 항상 하나의 컨슈머 그룹에 속합니다.&lt;br&gt;
카프카 클러스터에서 수신할 메시지는 컨슈머 그룹 안에서 어느 하나의 컨슈머가 수신합니다. 즉, &lt;strong&gt;카프카 클러스터에서 수신할 메시지를 동일 컨슈머 그룹에 속하는 컨슈머 사이에서 분산하여 수신&lt;/strong&gt;합니다. 이는 컨슈머에서 분산 스트림 처리도 고려해 설계된 것입니다.&lt;/p&gt;
&lt;p&gt;메시지를 컨슈머 그룹의 어느 컨슈머가 수신하는가에 대한 할당은 수신할 토픽에 존재하는 파티션과 그룹 내 컨슈머를 매핑함으로써 가능합니다. 컨슈머와 파티션의 매핑은 각 파티션에 반드시 하나의 컨슈머가 매핑됩니다. 반대로 파티션 수에 따라 하나의 컨슈머에 여러 파티션이 할당되는 경우가 있습니다. 컨슈머 그룹에서 기대한 대로 분산하여 메시지를 수신하기 위해서는 &lt;code&gt;파티션 수가 적어도 각 컨슈머 그룹에 속하는 컨슈머보다 많아야 합니다.&lt;/code&gt; 토픽의 파티션보다 컨슈머 쪽이 많을 경우 파티션이 할당되지 않은 컨슈머가 발생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_020_017.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;컨슈머를 생성할 때 partition.assignment.strategy 옵션을 활용하면 Assignor&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;를 선택할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;Offset&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_020_007.jpg&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각 파티션에서 수신한 메시지에는 각각 일려번호를 부여&lt;/li&gt;
&lt;li&gt;파티션 단위로 메시지 위치를 나타내는 오프셋이라는 관리 정보를 이용해 컨슈머가 취득하는 메시지의 범위 및 재시도를 제어&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;오프셋 설정 값 종류&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Log-End-Offsset(LEO) : 파티션 데이터의 끝&lt;/li&gt;
&lt;li&gt;Current Offset : 컨슈머가 어디까지 메시지를 읽었는가를 나타냄&lt;/li&gt;
&lt;li&gt;Commit Offset : 컨슈머가 어디까지 커밋했는지를 나타냄&lt;/li&gt;
&lt;li&gt;컨슈머는 메시지에 대해 확인했음을 다시 브로커에게 알리는데 이것이 바로 Commit Offset임&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;자동 오프셋 리셋&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;컨슈머가 시작할 때 오프셋 커밋 기록이 존재하지 않거나 기록되어 있어도 유효하지 않은 경우 사용하는 정책&lt;/li&gt;
&lt;li&gt;유효하지 않은 경우는 메시지가 retention이 지나 없는 경우&lt;/li&gt;
&lt;li&gt;컨슈머 애플리케이션에서 컨슈머를 생성할 때 지정하는 &lt;code&gt;auto.offset.reset=earliest&lt;/code&gt; 옵션으로 설정&lt;/li&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;정책&lt;/th&gt;
&lt;th&gt;자동 오프셋 리셋의 동작&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;latest&lt;/td&gt;
&lt;td&gt;- 해당 파티션의 가장 새로운 오프셋으로 초기화- 카프카 클러스터에 이미 존재하는 메시지는 처리 되지 않음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;earliest&lt;/td&gt;
&lt;td&gt;- 해당 파티션에 존재하는 가장 오래된 오프셋으로 초기화- 카프카 클러스터에 이미 존재하는 메시지 모두에 대해 처리 실시&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;none&lt;/td&gt;
&lt;td&gt;- 유효한 오프셋 커밋 정보가 없는 경우에 예외를 반환- seek() 메서드 등으로 명시적으로 오프셋을 지정해야 함&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Offset Commit&lt;/h3&gt;
&lt;p&gt;컨슈머는 어느 메시지까지 처리를 완료했는지 카프카 클러스터에 기록을 남길 수 있습니다. 정확하게는 &lt;code&gt;다음 수신 및 처리해야 할 메시지의 오프셋 기록&lt;/code&gt;입니다.&lt;br&gt;
오프셋 커밋의 기록은 컨슈머 그룹 단위로 이루어집니다. 컨슈머 그룹마다 각 토픽의 파티션에서 어느 오프셋까지 처리 완료했는지 정보를 기록합니다.
오프셋 커밋은 처리 완료 여부를 메시지마다 기록하는 것이 아니라 &lt;strong&gt;처리를 완료한 메시지 중에서 최대의 오프셋을 기록&lt;/strong&gt;하는 형태로 이루어집니다.&lt;br&gt;
이것은 카프카가 임의로 메시지를 처리하는 것이 아니라 &lt;strong&gt;파티션 안의 메시지를 연속적으로 처리하는 것을 가정&lt;/strong&gt;하고 있기 때문입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;중간에 메시지가 처리되지 않을 경우 무한 루프가 돌 수 있음 (수기로 메시지 커밋 하는 경우)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__consumer_offsets&lt;/code&gt; 라는 전용 토픽에 기록&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Auto Offset Commit&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자동 오프셋 커밋은 일정 간격마다 자동으로 오프셋 커밋을 하는 방식&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enable.auto.commit=true&lt;/code&gt; 설정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto.commit.interval.ms=5000&lt;/code&gt; 설정을 통해 오프셋 커밋의 간격 설정. 기본 5초&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_020_018.jpg&quot;&gt;&lt;/li&gt;
&lt;li&gt;장점 : 컨슈머는 오프셋 커밋을 명시적으로 실시할 필요가 없음&lt;/li&gt;
&lt;li&gt;단점 : 컨슈머 장애가 발생했을 때 메시지가 손실되거나 메시지 중복이 발생할 수 있음&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_020_019.jpg&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Manual Offset Commit&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;enable.auto.commit=false&lt;/code&gt; 설정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;commitSync()&lt;/code&gt; 메서드를 통해 오프셋을 수동으로 커밋할 수 있음&lt;/li&gt;
&lt;li&gt;애플리케이션 안에서 언제라도 오프셋 커밋을 수행할 수 있음&lt;/li&gt;
&lt;li&gt;카프카 클러스터에서 메시지 취득 후 메시지 처리가 완료한 시점에서 커밋&lt;/li&gt;
&lt;li&gt;장점&lt;/li&gt;
&lt;li&gt;해당 메시지 처리는 반드시 완료되어 있기 때문에 메시지 손실이 발생하지 않음&lt;/li&gt;
&lt;li&gt;컨슈머 장애 발생 시 메시지 중복을 최소화 할 수 있음&lt;/li&gt;
&lt;li&gt;단점&lt;/li&gt;
&lt;li&gt;메시지 양에 따라 다르지만, 수동 오프셋 커밋이 자주 커밋 처리를 하므로 카프카 클러스터 부하가 높아진다는 점에는 주의가 필요&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_020_020.jpg&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ZooKeeper&lt;/h3&gt;
&lt;p&gt;카프카의 브로커에 있어 분산 처리를 위한 관리 도구로 Apache ZooKeeper가 필요합니다. 주키퍼는 하둡 등 병렬 분산 처리용 OSS에 있어서 설정 관리, 이름 관리, 동기화를 위한 잠금 관리를 하는 구조로 자주 사용됩니다. 카프카에 있었어서는 분산 메시징의 메타 데이터(토픽과 파티션 등)를 관리하기 위한 구성 요소로 기능합니다. 주키퍼 클러스터는 주키퍼 앙상블이라고도 하며 &lt;strong&gt;구조상 3,5 처럼 홀수로 구성&lt;/strong&gt;하는 것이 일반적입니다.&lt;/p&gt;
&lt;h3&gt;카프카 클러스터&lt;/h3&gt;
&lt;p&gt;카프카는 여러 대의 브로커 서버, 주키퍼 서버로 이루어진 클러스터링의 메시지 중계 기능과 메시지 송수신을 위한 라이브러리 그룹으로 구성됩니다.&lt;/p&gt;
&lt;h2&gt;카프카 데이터 견고함을 담보하는 복제의 구조&lt;/h2&gt;
&lt;h3&gt;Replica / 레플리카&lt;/h3&gt;
&lt;p&gt;카프카는 메시지를 중계함과 동시에 서버가 고장 났을 때 수신한 메시지를 잃지 않기 위해 복제(Replication) 구조를 갖추고 있습니다. &lt;strong&gt;레플리카 중 하나는 Leader이며, 나머지는 Follower&lt;/strong&gt;라고 불립니다. Follower는 그 이름대로 Leader로부터 메시지를 계속적으로 취득하여 복제를 유지하도록 동작합니다. &lt;strong&gt;다만 프로듀서/컨슈머와의 데이터 교환은 Leader가 맡고 있습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Leader Replica의 복제 상태를 유지하고 있는 레플리카는 &lt;code&gt;In-Sync Replica(ISR)&lt;/code&gt;로 분류됩니다. 또한 복제 수와는 독립적으로 &lt;code&gt;최소 ISR 수(min.insync.replicas) 설정&lt;/code&gt;이 가능합니다. 고장 등으로 인한 일시적인 동기 지연을 허용하여 전체 읽고 쓰기를 계속하는 것이 가능합니다.&lt;/p&gt;
&lt;p&gt;복제 사용 시 오프셋 관리에는 LEO(Log End Offset) 이외에 High Watermark라는 개념이 있습니다. &lt;strong&gt;Hight Watermark는 복제가 완료된 오프셋&lt;/strong&gt;이며, 그 성질에서 반드시 LEO와 동일하거나 오래된 오프셋을 나타냅니다. &lt;code&gt;컨슈머는 High Watermark까지 기록된 메시지를 취득할 수 있습니다.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_020_012.jpg&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Ack&lt;/h3&gt;
&lt;p&gt;복제에 대한 중요한 구성 요소로 프로듀서의 메시지 송신 시 Ack 설정에 대해 알아보겠습니다. &lt;code&gt;브로커에서 프로듀서로 메시지가 송신된 것을 나타내는 Ack&lt;/code&gt;를 어느 타이밍에 송신할 것인지를 제어하는 것은 성능과 내장애성(브로커 서버 고장 시 데이터 분실 방지)에 큰 영향을 줍니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Ack 설정&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;프로듀서는 메시지 송신 시 Ack를 기다리지 않고 다음 메시지를 송신함&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Leader Replica에 메시지가 전달되면 Ack를 반환&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;All&lt;/td&gt;
&lt;td&gt;모든 ISR의 수만큼 복제되면 Ack를 반환&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;프로듀서는 타임아웃 설정으로 Ack가 돌아오지 않고 타임아웃된 Send 처리를 &apos;송신 실패&apos;로 감지&lt;/strong&gt;합니다. 참고로 Ack를 1 또는 all로 설정했을 경우 변환 타이밍이 의미하는 것은 각 복제에 &apos;메시지가 전달&apos;된 것으로 판단해 Ack를 반환하는 타이밍입니다. 이 타이밍에는 &lt;strong&gt;메시지가 디스크에 flush되는 것이 아니라 메모리(OS 버퍼)에 기록&lt;/strong&gt;됩니다. 디스크에 flush하는 영속화 타이밍은 다른 속성에서 제어합니다.&lt;/p&gt;
&lt;h3&gt;In-Sync Replica&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;min.insync.replicas 설정은 서버 고장 시 &apos;메시지를 잃지 않는 것&apos;과 &apos;메시징 시스템을 포함한 전체 시스템의 처리를 계속하는 것&apos;사이의 균형을 조정합니다.&lt;/strong&gt;&lt;br&gt;
아래 예시 중 어느 것이 뛰어나다는 것이 아니라 시스템 요구 사항과 제약 조건에 의해 결정돼야 한다는 점에 주의해야 합니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th colspan=&quot;2&quot;&gt;
&lt;code&gt;In-Sync Replica와 Ack = all, 쓰기 계속성의 관계&lt;/code&gt;
&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;
&lt;th colspan=&quot;2&quot;&gt;
브로커는 4대 레플리카 수는 3으로 브로커 1대가 고장나 레플리카를 하나 잃어버린 경우
&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;th&gt;설정&lt;/th&gt;
&lt;th&gt;상황&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;
min.insync.replicas=3
Ack=all인 경우&lt;/td&gt;
&lt;td&gt;브로커 서버가 1대 고장난 경우 프로듀서는 비정상 상태로 간주하여잃어버린 레플리카가 ISR로 복귀할 때까지 데이터를 쓸 수 없음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;2&quot;&gt;&lt;ResizeImage src=&quot;https://baek.dev/assets/images/post/2020/2020_020_013.jpg&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
min.insync.replicas=2
Ack=all인 경우&lt;/td&gt;
&lt;td&gt;
- 브로커 서버가 1대 고장난 경우에도 Ack를 반환하고 처리하고 처리를 계속함  
- 처리를 계속하는 점에 있어서는 위보다 나은 반면
- 나중에 추가된 파티션이 복제를 완료해 ISR로 승격될 떄까지 복제수가 2가 됨  
- 복구 전에 2대가 고장난 경우는 처리 중인 메시지를 손실할 위험이 높아짐
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;2&quot;&gt;&lt;ResizeImage src=&quot;https://baek.dev/assets/images/post/2020/2020_020_014.jpg&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;min.insync.replicas&lt;/code&gt;는 프로듀서와 메시지를 보낼 때 송신처 파티션의 복제본 중 ISR에 속하는 복제본이 최소 몇 개나 필요한지를 설정하는 브로커와 토픽의 구성입니다. 브로커는 메시지를 수신한 직후에 특정 브로커에 장애가 발생했다고 해도 메시지를 분실하지 않기 위한 안정장치 역할을 합니다. &lt;strong&gt;장애 허용 대수&lt;/strong&gt;만큼의 브로커에 장애가 발생했을 때 카프카 클러스터에 영향 없이 서비스를 계속하기 위해서는 &lt;code&gt;모든 파티션에서 ISR에 속하는 복제본의 수가 min.insync.replicas 수 이상&lt;/code&gt;이어야 합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;위 내용은 &lt;a href=&quot;https://coupa.ng/bwkNyn&quot; target=&quot;_blank&quot;&gt;실전 아파치 카프카&lt;/a&gt;를 읽고 제 경험을 추가하여 정리한 내용으로 카프카 도입 예정이신 분들은 읽어보시면 도움 될 책입니다.&lt;br&gt;
그럼 다음 편에서는 카프카 예제 코드로 찾아 뵙겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;참고하면 좋은 글&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.linkedin.com/pulse/kafka-technical-overview-sylvester-daniel&quot; target=&quot;_blank&quot;&gt;Kafka Technical Overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.popit.kr/kafka-%EC%9A%B4%EC%98%81%EC%9E%90%EA%B0%80-%EB%A7%90%ED%95%98%EB%8A%94-producer-acks/&quot; target=&quot;_blank&quot;&gt;Kafka 운영자가 말하는 Producer ACKS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kafka.apache.org/documentation/#configuration&quot; target=&quot;_blank&quot;&gt;Apache Kafka - CONFIGURATION&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://kafka.apache.org/20/javadoc/org/apache/kafka/clients/consumer/RoundRobinAssignor.html&quot;&gt;Round Robin Assingor&lt;/a&gt; / &lt;a href=&quot;http://kafka.apache.org/20/javadoc/org/apache/kafka/clients/consumer/StickyAssignor.html&quot;&gt;Sticky Assignor&lt;/a&gt; / &lt;a href=&quot;http://kafka.apache.org/20/javadoc/org/apache/kafka/clients/consumer/RangeAssignor.html&quot;&gt;Range Assignor&lt;/a&gt;&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[글쓰는 또라이가 세상을 바꾼다 - 글또 4기에 참여해요]]></title><description><![CDATA[<h2>글쓰기를 하는 이유</h2>
<p>아직은 성장할 날이 더 많은 작은 키의 글쓰기 솜씨이지만, 글쓰기를 통해 많은 것을 배우고 있습니다.</p>
<p>우리는 누구나 다 열심히 살지만 돌이켜 보면 딱히 생각나는 것이 없는 경우가 종종 있습니다. 가까운 예로 회고 작성할 때 이 감정을 많이 느꼈습니다. 1년을 정말 바삐 살아왔는데 손에 쥔 건 아무것도 없는 공허함이 밀려왔습니다. 쉬지 않고 달려왔지만 돌이켜보면 하루하루 연명하기 바빴던 것 같습니다. 같은 날을 보내더라도 블로깅을 하고자 한 뒤부터는 모든 것을 한 번 더 생각하게 되고, 한 번 더 눈여겨보게 되었습니다. 예전에는 그저 지나쳤을 모든 것들이 이제는 글감의 대상이 되고 있습니다. 그래서 개발과 관련된 어떤 이벤트이건 간에 글로 남겨야겠다고 다짐했습니다.</p>
<p>이렇게 글쓰기는 또 하나의 장점이 있는데 <strong>과거 봉착했던 문제를 다시 마주했을 때 저만의 스타일로 정리된 글을 보며 다시 복기할 수</strong> 있습니다. 블로깅 이전에는 단순히 포스트잇에 문제와 답을 작성하는 느낌으로 메모를 갈무리하는 정도였고, 이것은 문제집 뒤에 있는 답안지와 다르지 않아 개발 성숙도에서 바랄 볼 때 효용가치가 크지 않았습니다. 하여 어떤 문제에 직면했고, 어떤 방향으로 해결하는지 <code>스토리를 담아 작성한 글은 설령 해당 기술의 버전이 바뀌었을지라도 미래의 나에게 문제 접근 해결 방식에 대한 영감을 줄 수 있다</code>고 생각합니다.</p>
<p>그래서 저는 글쓰기를 시작하게 되었습니다 :)</p>
<h2>다짐에는 적당한 제약이 있으면 더 좋다</h2>
<p>하지만 아쉽게도 저는 <strong>유연성 좋은 의지를 가지고 있어 매번 나 자신과의 타협에 능한 편</strong>입니다 :) 그래서 지난날 <strong>기간제 목표형 모각코</strong>라는 강제성 프레임을 선택하게 되었고, 그 기간 동안은 알차게 꾸준히 목표한 바를 이루었습니다. <a href="/post/10">퀵퀵각코 회고록</a></p>
<p>이번에는 글쓰기를 좀 더 습관화하고 완성도 있는 글을 작성하고 싶어 <code>글또라는 적당한 강제성 프레임</code>을 선택하게 되었습니다. 많은 지원자가 있어 탈락하면 어쩌나 노심초사했는데 다행히 찰떡같이(?) 붙어 글또 4기에 팀원으로 합류하였습니다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_019_002.png"></p>
<p><strong>글또는</strong></p>
<ul>
<li>2주에 글 1개씩을 작성하는 모임</li>
<li><strong>같은 직군의 팀원들이 서로의 글을 피드백</strong></li>
<li>예치금이 존재하여 글을 작성하지 않으면 예치금 차감</li>
<li>부득이하게 글 작성이 어려운 경우 패스권을 사용하면 예치금을 방어할 수 있는 황금 열쇠 2개 부여</li>
<li>자세한 설명은 <a href="https://www.notion.so/ac5b18a482fb4df497d4e8257ad4d516" target="_blank">요기 클릭</a></li>
</ul>
<p>여기서 예치금이 글쓰기를 실천할 수 있게 하는 프레임이라고 볼 수 있습니다. 글또는 팀원들과 서로의 글에 대해 피드백을 교류하는 장치도 있습니다. 개발할 때 코드가 익숙해져 버그가 잘 보이지 않는 경험을 한 두 번씩 해보는데, 그러다 동료에게 물어보면 단숨에 원인을 찾는 경우가 왕왕 있습니다. 이렇듯 글쓴이 눈에 익숙해진 글이 타인에게는 영 이상할 수도 혹은 허점이 보일 수도 있고 기술적으로 오류를 범할 수 있도 있습니다. 이런 점을 개선할 수 있고 <code>다양한 정보를 교류하는 장이 될 것 같아 글또에 참여하지 않을 이유가 없었습니다</code> :)</p>
<h2>주제와 계획</h2>
<p>머릿속에만 있던 내용을 다시 한 번 정리하는 시간을 갖고 부족했던 부분도 채울 수 있도록 작성할 계획입니다.</p>
<p>가장 먼저 다뤄볼 기술 스택은 <strong>ElasticSearch, Cassandra, Redis, Docker</strong>를 목표하고 있습니다. 가능하다면 최소한의 기능을 하는 토이 프로젝트를 만들 수 있도록 하는 것 역시 또 하나의 목표입니다. 개념이나 튜토리얼은 공식문서가 잘 되어 있기 때문에 글에선 간략한 <code>개념을 정리하고 + 토이 프로젝트로 아웃풋</code>을 만들 계획입니다.</p>
<p>과거 블로깅을 몇 차례 시도했지만 궤도에 오르지 못한 이유는 <strong>글감 찾기가 어려웠기 때문</strong>이라고 생각합니다. 일단 글감이라도 있으면 어떻게든 쥐어짜서라도 글자를 또각또각 타이핑 해보겠는데, 글감마저 없으니 글감 생각하다 지쳤던 것 같습니다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_019_001.png" alt="글감 모으기를 통해 작성한 글들"></p>
<blockquote>
<p>요즘에는 일을 하거나 공부를 할 때 번뜩이는 주제들을 모으고 있다.<br>
모인 주제들을 어떤 내용으로 써 내려가야 할지 구체화되지 않은 경우도 있는데,<br>
일단 리스트업 해놓고 소주제를 계속 추가하다 보면 큰 틀이나 분량이 나오게 된다.<br>
이 글감들은 같은 문제를 겪으며 고민하는 이들과 미래의 나에게 전할 수 있는 메시지가 되니 요즘 점점 재밌어진다.</p>
<p><a href="/post/14/">2019년 회고 - 처음 쓰는 한해 마무리 회고 중</a></p>
</blockquote>
<p>이처럼 글감을 모으고 있다 보니 몇 개의 글감이 항상 대기 중에 있어 이제는 글감이 없어 글을 못 쓴단 이야기는 못 하게 되었습니다 :p</p>
<hr>
<p>앞으로 여러 시각과 다양한 주제들이 넘쳐날 글또 참여가 매우 기대되며, 글또를 통해 많이 배우고 저도 다른 분들에게 적극적인 피드백을 드리며 서로 <strong>상생</strong>하는 과정이 되도록 노력해야겠습니다.</p>]]></description><link>https://baek.dev/post/19/</link><guid isPermaLink="false">https://baek.dev/post/19/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Thu, 27 Feb 2020 13:43:00 GMT</pubDate><content:encoded>&lt;h2&gt;글쓰기를 하는 이유&lt;/h2&gt;
&lt;p&gt;아직은 성장할 날이 더 많은 작은 키의 글쓰기 솜씨이지만, 글쓰기를 통해 많은 것을 배우고 있습니다.&lt;/p&gt;
&lt;p&gt;우리는 누구나 다 열심히 살지만 돌이켜 보면 딱히 생각나는 것이 없는 경우가 종종 있습니다. 가까운 예로 회고 작성할 때 이 감정을 많이 느꼈습니다. 1년을 정말 바삐 살아왔는데 손에 쥔 건 아무것도 없는 공허함이 밀려왔습니다. 쉬지 않고 달려왔지만 돌이켜보면 하루하루 연명하기 바빴던 것 같습니다. 같은 날을 보내더라도 블로깅을 하고자 한 뒤부터는 모든 것을 한 번 더 생각하게 되고, 한 번 더 눈여겨보게 되었습니다. 예전에는 그저 지나쳤을 모든 것들이 이제는 글감의 대상이 되고 있습니다. 그래서 개발과 관련된 어떤 이벤트이건 간에 글로 남겨야겠다고 다짐했습니다.&lt;/p&gt;
&lt;p&gt;이렇게 글쓰기는 또 하나의 장점이 있는데 &lt;strong&gt;과거 봉착했던 문제를 다시 마주했을 때 저만의 스타일로 정리된 글을 보며 다시 복기할 수&lt;/strong&gt; 있습니다. 블로깅 이전에는 단순히 포스트잇에 문제와 답을 작성하는 느낌으로 메모를 갈무리하는 정도였고, 이것은 문제집 뒤에 있는 답안지와 다르지 않아 개발 성숙도에서 바랄 볼 때 효용가치가 크지 않았습니다. 하여 어떤 문제에 직면했고, 어떤 방향으로 해결하는지 &lt;code&gt;스토리를 담아 작성한 글은 설령 해당 기술의 버전이 바뀌었을지라도 미래의 나에게 문제 접근 해결 방식에 대한 영감을 줄 수 있다&lt;/code&gt;고 생각합니다.&lt;/p&gt;
&lt;p&gt;그래서 저는 글쓰기를 시작하게 되었습니다 :)&lt;/p&gt;
&lt;h2&gt;다짐에는 적당한 제약이 있으면 더 좋다&lt;/h2&gt;
&lt;p&gt;하지만 아쉽게도 저는 &lt;strong&gt;유연성 좋은 의지를 가지고 있어 매번 나 자신과의 타협에 능한 편&lt;/strong&gt;입니다 :) 그래서 지난날 &lt;strong&gt;기간제 목표형 모각코&lt;/strong&gt;라는 강제성 프레임을 선택하게 되었고, 그 기간 동안은 알차게 꾸준히 목표한 바를 이루었습니다. &lt;a href=&quot;/post/10&quot;&gt;퀵퀵각코 회고록&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이번에는 글쓰기를 좀 더 습관화하고 완성도 있는 글을 작성하고 싶어 &lt;code&gt;글또라는 적당한 강제성 프레임&lt;/code&gt;을 선택하게 되었습니다. 많은 지원자가 있어 탈락하면 어쩌나 노심초사했는데 다행히 찰떡같이(?) 붙어 글또 4기에 팀원으로 합류하였습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_019_002.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;글또는&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2주에 글 1개씩을 작성하는 모임&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;같은 직군의 팀원들이 서로의 글을 피드백&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;예치금이 존재하여 글을 작성하지 않으면 예치금 차감&lt;/li&gt;
&lt;li&gt;부득이하게 글 작성이 어려운 경우 패스권을 사용하면 예치금을 방어할 수 있는 황금 열쇠 2개 부여&lt;/li&gt;
&lt;li&gt;자세한 설명은 &lt;a href=&quot;https://www.notion.so/ac5b18a482fb4df497d4e8257ad4d516&quot; target=&quot;_blank&quot;&gt;요기 클릭&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여기서 예치금이 글쓰기를 실천할 수 있게 하는 프레임이라고 볼 수 있습니다. 글또는 팀원들과 서로의 글에 대해 피드백을 교류하는 장치도 있습니다. 개발할 때 코드가 익숙해져 버그가 잘 보이지 않는 경험을 한 두 번씩 해보는데, 그러다 동료에게 물어보면 단숨에 원인을 찾는 경우가 왕왕 있습니다. 이렇듯 글쓴이 눈에 익숙해진 글이 타인에게는 영 이상할 수도 혹은 허점이 보일 수도 있고 기술적으로 오류를 범할 수 있도 있습니다. 이런 점을 개선할 수 있고 &lt;code&gt;다양한 정보를 교류하는 장이 될 것 같아 글또에 참여하지 않을 이유가 없었습니다&lt;/code&gt; :)&lt;/p&gt;
&lt;h2&gt;주제와 계획&lt;/h2&gt;
&lt;p&gt;머릿속에만 있던 내용을 다시 한 번 정리하는 시간을 갖고 부족했던 부분도 채울 수 있도록 작성할 계획입니다.&lt;/p&gt;
&lt;p&gt;가장 먼저 다뤄볼 기술 스택은 &lt;strong&gt;ElasticSearch, Cassandra, Redis, Docker&lt;/strong&gt;를 목표하고 있습니다. 가능하다면 최소한의 기능을 하는 토이 프로젝트를 만들 수 있도록 하는 것 역시 또 하나의 목표입니다. 개념이나 튜토리얼은 공식문서가 잘 되어 있기 때문에 글에선 간략한 &lt;code&gt;개념을 정리하고 + 토이 프로젝트로 아웃풋&lt;/code&gt;을 만들 계획입니다.&lt;/p&gt;
&lt;p&gt;과거 블로깅을 몇 차례 시도했지만 궤도에 오르지 못한 이유는 &lt;strong&gt;글감 찾기가 어려웠기 때문&lt;/strong&gt;이라고 생각합니다. 일단 글감이라도 있으면 어떻게든 쥐어짜서라도 글자를 또각또각 타이핑 해보겠는데, 글감마저 없으니 글감 생각하다 지쳤던 것 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_019_001.png&quot; alt=&quot;글감 모으기를 통해 작성한 글들&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;요즘에는 일을 하거나 공부를 할 때 번뜩이는 주제들을 모으고 있다.&lt;br&gt;
모인 주제들을 어떤 내용으로 써 내려가야 할지 구체화되지 않은 경우도 있는데,&lt;br&gt;
일단 리스트업 해놓고 소주제를 계속 추가하다 보면 큰 틀이나 분량이 나오게 된다.&lt;br&gt;
이 글감들은 같은 문제를 겪으며 고민하는 이들과 미래의 나에게 전할 수 있는 메시지가 되니 요즘 점점 재밌어진다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/post/14/&quot;&gt;2019년 회고 - 처음 쓰는 한해 마무리 회고 중&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이처럼 글감을 모으고 있다 보니 몇 개의 글감이 항상 대기 중에 있어 이제는 글감이 없어 글을 못 쓴단 이야기는 못 하게 되었습니다 :p&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;앞으로 여러 시각과 다양한 주제들이 넘쳐날 글또 참여가 매우 기대되며, 글또를 통해 많이 배우고 저도 다른 분들에게 적극적인 피드백을 드리며 서로 &lt;strong&gt;상생&lt;/strong&gt;하는 과정이 되도록 노력해야겠습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[월말회고 - 2020년 01월]]></title><description><![CDATA[<p>import ResizeImage from 'components/ResizeImage'</p>
<p>보통 1년 회고를 연말에 많이 하는데, 올해부터는 매월을 보내고 하는 월말 회고를 시작하려고 합니다. 얼마 전 우연히 '월말 회고' 포스팅을 접했다가 꽤 좋은 아이디어라고 생각했고, 매월 작성하면 1년도 저절로 알차지지 않을까요?<br>
그럼 회고는 높임말 없이 편하게 작성하겠습니다 :)</p>
<h2>블로그 포스팅</h2>
<p><strong>1.5주당 글 1개</strong> 쓰는 것이 개인적인 목표라 이번 달엔 3개를 작성하면 되고, 결과적으로 2개의 글을 작성했다. 반 이상은 성공해서 다행이고(?) 2월은 2.5개를 작성하면 된다.</p>
<p>그리고 2개의 포스팅이 생각보다 반응이 좋았다. 함께 자라기는 워낙 유명한 책이기도 하고, ModelMapper 글은 실제 현업에서 겪었던 내용을 작성해서 반응이 좋았던 것 같다. 함께 자라기 리뷰 역시 개인적인 경험이 글감이다보니 매우 몰입해서 작성했다. 글을 퇴고하고 탈고하는 순간까지도 나의 치부를 드러내는 것 같아 망설여졌지만, 나와 같은 고민을 하고 있을 수도 있는 분들이 계실 것 같아 작성하게 되었다. <strong>내 글들이 조금이나마 도움이 되면 좋겠다.</strong></p>
<p><a href="/post/15/" target="_blank"><ResizeImage src="https://baek.dev/assets/images/post/2020/2020_015.png" width="300px;" alt="찾기 힘든 버그를 유발하는 Java DTO 컨버팅 노가다, 리팩토링하기" /> 찾기 힘든 버그를 유발하는 Java DTO 컨버팅 노가다, 리팩토링하기</a></p>
<p><a href="/post/15/" target="_blank"><ResizeImage src="https://baek.dev/assets/images/post/2020/2020_016.png" width="300px;" alt="털어놓기 어려웠던 개발자로서 고민을 해결해준 책, 함께 자라기" /> 털어놓기 어려웠던 개발자로서 고민을 해결해준 책, 함께 자라기</a></p>
<h2>TF</h2>
<p>1월부터 신규 TF가 출범하여 합류했고 새로운 경험을 하고 있다. 우리 회사는 원래 빠른 피처 적용을 하는 곳이지만, 그보다도 더 빠른 사이클로 피처 릴리즈를 하고 있다. 기존과 다른 방식의 프로세스에 새로 입사한 기분이 들 정도로 회사에서 하루하루가 정신없이 지나갔고, 지금도 그 시간 속에 있다. 그 속에서 블로깅을 자꾸 잊게 되지만 그래도 스스로 정한 1.5주에 글 1개라는 목표는 챙기려 노력한다.</p>
<p>TF 초반엔 조금이라도 더 보탬이 되고 싶어 무조건 많은 성과를 내야겠다고 생각했다. 하지만 <strong>이 소중한 기회를 통해 배워야 할 것, 얻어야 할 것을 정하는 것</strong>이 좋을 것 같았다. 맹목적으로 비즈니스를 쳐내는 것은 결국 돌아보면 눈에 보이는 것만 다 끝나버리지 않을까 싶다.</p>
<ul>
<li>다양한 코드를 보면서 빠르게 코드를 분석하며, 소스 아키텍쳐 살피기</li>
<li>보이스카우트 원칙 지키기</li>
<li>여러 직군과 커뮤니케이션하기</li>
<li>일의 우선순위, 릴리즈 범위 조정하기</li>
</ul>
<p>TF를 통해 코드나 업무를 대하는 시각이 많이 바뀌었다. 이 경험을 잊지 않고 잘 챙겨야겠다.</p>
<h2>호캉스에서 만다라차트를</h2>
<p>지난 2019년 회고에서 언급했던 호캉스를 이번 1월에도 다녀왔다. 지난번엔 1박으로 갔었는데 이번엔 2박 3일로 적당히 여유롭게 다녀왔다. 돈은 벌기 힘든데 돈 쓰는 것은 튜토리얼 깨기만큼 너무 쉽다. 맛있는 것도 먹고 재밌었다. 룸서비스 조식을 받을 땐 세상 호사스러웠다 :)</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_018_001.jpg" alt="오타니 쇼헤이"><br>
만다라차트는 메이저리그 진출의 꿈을 이룬 오타니 쇼헤이가 작성하여 유명해졌다. (<a href="https://m.post.naver.com/viewer/postView.nhn?volumeNo=27240187" target="_blank">참고</a>)</p>
<p>이번 여행은 기간도 넉넉하고, 새해도 맞아 신년 계획을 세우기 위해 <a href="https://coupa.ng/bpa4d5" target="_blank">만다라차트 실천법</a> 책이랑 아이패드를 챙겨 갔다. 신명 나게 놀고 저녁에 호텔로 돌아와서 만다라차트를 작성했다. 만다라차트는 좋은 도구이고 목표를 디테일하게 작성하지만, 저절로 목표가 이뤄지게 하는 것은 아니다. 그래서 함께 가져간 <a href="https://coupa.ng/bpa4d5" target="_blank">만다라차트 실천법</a>은 매일매일 지속하여 습관으로 만들 수 있도록 여러가지 도구를 제시한다.</p>
<p><img src="https://image.aladin.co.kr/product/15091/45/cover500/s372534583_1.jpg"></p>
<h2>평각코</h2>
<p>평일에 하는 모각코로 <del>모여서 폭풍 수다 떨고 각코를 시작하는</del> 정신적 지주들이 있는 모임이다. 함께 고민하는 것이 너무 좋고 자기 개발 장려하는 모임으로 평일에 매주 열리도록 일자를 조정했다. 평각코에서 파이썬 크롤러 뽐뿌를 얻었고, 설날에 그 목표를 작게 이루었다.</p>
<h2>파이썬 입문</h2>
<p>입문하기에 상대적으로 부담 적은 파이썬인데, 몇 년 간 버킷리스트에 담아놓고 실현하기 어려웠다. 아마도 막연히 문법을 익히는 걸로만 끝나면 뇌리에 잘 남지않기도 하고 구체적인 니즈가 없었기 때문이지 않았을까 싶다. 그러다 앞서 소개한 평각코에서 크롤러 감명을 받아 하루동안 파이썬 공부하고 하루만에 크롤러를 만들게 되었다. 크롤러 본격 회고는 2월에 하겠다!<br>
<a href="https://github.com/baekdev/crawler-study-gathering" target="_blank">스터디 모집글을 자동으로 알려주는 파이썬 크롤러</a></p>
<h2>책 구독 서비스 시작</h2>
<p>나는 작년부터 전자책으로 도서 플랫폼을 변경하기 시작했고, 그래서 구독 서비스에도 관심이 생겼다.<br>
yes24 북클럽, 리디북스, 밀리의 서재, 교보문고 샘 등 전자책(+ 종이책) 구독 서비스들이 점차 늘었다. 대부분 1개월 무료 체험을 하고 있어 순서대로 접해보고 가장 괜찮은 곳으로 구독을 시작하려고 한다. 아쉬운 점은 모든 e-book이 서비스 대상이 아니라는 것이다. 물론 모든 e-book이 대상이 될 수 없음은 알지만 그럼에도 대상 도서가 너무 적다. 앞으로 구독 서비스로 만날 도서가 더 다양해지길 바란다.</p>
<p>1월은 먼저 yes24 북클럽으로 시작했다. IT 책도 조금(아니 적게) 있다. 평소 관심 있던 책들이 있었지만, 막상 구매하기 부담스러웠던 책들을 읽는 것으로 나는 구독 서비스에 초점을 맞췄다. 서점에서 읽어보고 구매할 수도 있으나 서점에 매번 가는 것도 일이고, 서점에선 앉아 있는 좌석이 많지 않아 집중해서 읽기는 어려운 부분이 있다. 그래서 구독 서비스로 읽어보고 괜찮은 책은 소장용으로 구매할 계획이다.</p>
<hr>
<p>1월 월말 회고 포스팅이 2월 중순에 게시해서 많이 늦어졌지만 ..)a 돌아볼 수 있어서 좋았고 1월을 그래도 허투루 보내지 않았다는 성취감이 든다.</p>
<h3>2월 목표</h3>
<ul>
<li>스터디 참여하기</li>
</ul>]]></description><link>https://baek.dev/post/18/</link><guid isPermaLink="false">https://baek.dev/post/18/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Fri, 14 Feb 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;import ResizeImage from &apos;components/ResizeImage&apos;&lt;/p&gt;
&lt;p&gt;보통 1년 회고를 연말에 많이 하는데, 올해부터는 매월을 보내고 하는 월말 회고를 시작하려고 합니다. 얼마 전 우연히 &apos;월말 회고&apos; 포스팅을 접했다가 꽤 좋은 아이디어라고 생각했고, 매월 작성하면 1년도 저절로 알차지지 않을까요?&lt;br&gt;
그럼 회고는 높임말 없이 편하게 작성하겠습니다 :)&lt;/p&gt;
&lt;h2&gt;블로그 포스팅&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.5주당 글 1개&lt;/strong&gt; 쓰는 것이 개인적인 목표라 이번 달엔 3개를 작성하면 되고, 결과적으로 2개의 글을 작성했다. 반 이상은 성공해서 다행이고(?) 2월은 2.5개를 작성하면 된다.&lt;/p&gt;
&lt;p&gt;그리고 2개의 포스팅이 생각보다 반응이 좋았다. 함께 자라기는 워낙 유명한 책이기도 하고, ModelMapper 글은 실제 현업에서 겪었던 내용을 작성해서 반응이 좋았던 것 같다. 함께 자라기 리뷰 역시 개인적인 경험이 글감이다보니 매우 몰입해서 작성했다. 글을 퇴고하고 탈고하는 순간까지도 나의 치부를 드러내는 것 같아 망설여졌지만, 나와 같은 고민을 하고 있을 수도 있는 분들이 계실 것 같아 작성하게 되었다. &lt;strong&gt;내 글들이 조금이나마 도움이 되면 좋겠다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/post/15/&quot; target=&quot;_blank&quot;&gt;&lt;ResizeImage src=&quot;https://baek.dev/assets/images/post/2020/2020_015.png&quot; width=&quot;300px;&quot; alt=&quot;찾기 힘든 버그를 유발하는 Java DTO 컨버팅 노가다, 리팩토링하기&quot; /&gt; 찾기 힘든 버그를 유발하는 Java DTO 컨버팅 노가다, 리팩토링하기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/post/15/&quot; target=&quot;_blank&quot;&gt;&lt;ResizeImage src=&quot;https://baek.dev/assets/images/post/2020/2020_016.png&quot; width=&quot;300px;&quot; alt=&quot;털어놓기 어려웠던 개발자로서 고민을 해결해준 책, 함께 자라기&quot; /&gt; 털어놓기 어려웠던 개발자로서 고민을 해결해준 책, 함께 자라기&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;TF&lt;/h2&gt;
&lt;p&gt;1월부터 신규 TF가 출범하여 합류했고 새로운 경험을 하고 있다. 우리 회사는 원래 빠른 피처 적용을 하는 곳이지만, 그보다도 더 빠른 사이클로 피처 릴리즈를 하고 있다. 기존과 다른 방식의 프로세스에 새로 입사한 기분이 들 정도로 회사에서 하루하루가 정신없이 지나갔고, 지금도 그 시간 속에 있다. 그 속에서 블로깅을 자꾸 잊게 되지만 그래도 스스로 정한 1.5주에 글 1개라는 목표는 챙기려 노력한다.&lt;/p&gt;
&lt;p&gt;TF 초반엔 조금이라도 더 보탬이 되고 싶어 무조건 많은 성과를 내야겠다고 생각했다. 하지만 &lt;strong&gt;이 소중한 기회를 통해 배워야 할 것, 얻어야 할 것을 정하는 것&lt;/strong&gt;이 좋을 것 같았다. 맹목적으로 비즈니스를 쳐내는 것은 결국 돌아보면 눈에 보이는 것만 다 끝나버리지 않을까 싶다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다양한 코드를 보면서 빠르게 코드를 분석하며, 소스 아키텍쳐 살피기&lt;/li&gt;
&lt;li&gt;보이스카우트 원칙 지키기&lt;/li&gt;
&lt;li&gt;여러 직군과 커뮤니케이션하기&lt;/li&gt;
&lt;li&gt;일의 우선순위, 릴리즈 범위 조정하기&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TF를 통해 코드나 업무를 대하는 시각이 많이 바뀌었다. 이 경험을 잊지 않고 잘 챙겨야겠다.&lt;/p&gt;
&lt;h2&gt;호캉스에서 만다라차트를&lt;/h2&gt;
&lt;p&gt;지난 2019년 회고에서 언급했던 호캉스를 이번 1월에도 다녀왔다. 지난번엔 1박으로 갔었는데 이번엔 2박 3일로 적당히 여유롭게 다녀왔다. 돈은 벌기 힘든데 돈 쓰는 것은 튜토리얼 깨기만큼 너무 쉽다. 맛있는 것도 먹고 재밌었다. 룸서비스 조식을 받을 땐 세상 호사스러웠다 :)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_018_001.jpg&quot; alt=&quot;오타니 쇼헤이&quot;&gt;&lt;br&gt;
만다라차트는 메이저리그 진출의 꿈을 이룬 오타니 쇼헤이가 작성하여 유명해졌다. (&lt;a href=&quot;https://m.post.naver.com/viewer/postView.nhn?volumeNo=27240187&quot; target=&quot;_blank&quot;&gt;참고&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;이번 여행은 기간도 넉넉하고, 새해도 맞아 신년 계획을 세우기 위해 &lt;a href=&quot;https://coupa.ng/bpa4d5&quot; target=&quot;_blank&quot;&gt;만다라차트 실천법&lt;/a&gt; 책이랑 아이패드를 챙겨 갔다. 신명 나게 놀고 저녁에 호텔로 돌아와서 만다라차트를 작성했다. 만다라차트는 좋은 도구이고 목표를 디테일하게 작성하지만, 저절로 목표가 이뤄지게 하는 것은 아니다. 그래서 함께 가져간 &lt;a href=&quot;https://coupa.ng/bpa4d5&quot; target=&quot;_blank&quot;&gt;만다라차트 실천법&lt;/a&gt;은 매일매일 지속하여 습관으로 만들 수 있도록 여러가지 도구를 제시한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image.aladin.co.kr/product/15091/45/cover500/s372534583_1.jpg&quot;&gt;&lt;/p&gt;
&lt;h2&gt;평각코&lt;/h2&gt;
&lt;p&gt;평일에 하는 모각코로 &lt;del&gt;모여서 폭풍 수다 떨고 각코를 시작하는&lt;/del&gt; 정신적 지주들이 있는 모임이다. 함께 고민하는 것이 너무 좋고 자기 개발 장려하는 모임으로 평일에 매주 열리도록 일자를 조정했다. 평각코에서 파이썬 크롤러 뽐뿌를 얻었고, 설날에 그 목표를 작게 이루었다.&lt;/p&gt;
&lt;h2&gt;파이썬 입문&lt;/h2&gt;
&lt;p&gt;입문하기에 상대적으로 부담 적은 파이썬인데, 몇 년 간 버킷리스트에 담아놓고 실현하기 어려웠다. 아마도 막연히 문법을 익히는 걸로만 끝나면 뇌리에 잘 남지않기도 하고 구체적인 니즈가 없었기 때문이지 않았을까 싶다. 그러다 앞서 소개한 평각코에서 크롤러 감명을 받아 하루동안 파이썬 공부하고 하루만에 크롤러를 만들게 되었다. 크롤러 본격 회고는 2월에 하겠다!&lt;br&gt;
&lt;a href=&quot;https://github.com/baekdev/crawler-study-gathering&quot; target=&quot;_blank&quot;&gt;스터디 모집글을 자동으로 알려주는 파이썬 크롤러&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;책 구독 서비스 시작&lt;/h2&gt;
&lt;p&gt;나는 작년부터 전자책으로 도서 플랫폼을 변경하기 시작했고, 그래서 구독 서비스에도 관심이 생겼다.&lt;br&gt;
yes24 북클럽, 리디북스, 밀리의 서재, 교보문고 샘 등 전자책(+ 종이책) 구독 서비스들이 점차 늘었다. 대부분 1개월 무료 체험을 하고 있어 순서대로 접해보고 가장 괜찮은 곳으로 구독을 시작하려고 한다. 아쉬운 점은 모든 e-book이 서비스 대상이 아니라는 것이다. 물론 모든 e-book이 대상이 될 수 없음은 알지만 그럼에도 대상 도서가 너무 적다. 앞으로 구독 서비스로 만날 도서가 더 다양해지길 바란다.&lt;/p&gt;
&lt;p&gt;1월은 먼저 yes24 북클럽으로 시작했다. IT 책도 조금(아니 적게) 있다. 평소 관심 있던 책들이 있었지만, 막상 구매하기 부담스러웠던 책들을 읽는 것으로 나는 구독 서비스에 초점을 맞췄다. 서점에서 읽어보고 구매할 수도 있으나 서점에 매번 가는 것도 일이고, 서점에선 앉아 있는 좌석이 많지 않아 집중해서 읽기는 어려운 부분이 있다. 그래서 구독 서비스로 읽어보고 괜찮은 책은 소장용으로 구매할 계획이다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;1월 월말 회고 포스팅이 2월 중순에 게시해서 많이 늦어졌지만 ..)a 돌아볼 수 있어서 좋았고 1월을 그래도 허투루 보내지 않았다는 성취감이 든다.&lt;/p&gt;
&lt;h3&gt;2월 목표&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;스터디 참여하기&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[자동으로 스터디 모집 글을 모아 알림을 주는 파이썬 크롤러 만들기(with Github Actions)]]></title><description><![CDATA[<p>이번 설 연휴 동안 다짐했던 목표가 있었습니다. 바로 파이썬 공부 시작과 함께 파이썬 크롤러 만들기! 파이썬 기본 문법과 자료구조를 빠르게 공부한 뒤, 바로 파이썬 크롤러 만들기에 들어갔습니다. 파이썬 크롤러 코드가 이해가 되고 해보고 싶은 만큼 조금씩 변형해볼 수 있으니 너무 재밌었습니다.</p>
<p>이번에 단순히 크롤링하는 라이브러리를 익혀보는 것으로 끝내기보다, 평소 갈증이 있었던 스터디 모집 새글 알림을 받도록하는 크롤링을 목표로 발전시켰습니다. 그럼 이번 공부를 <strong><code>아웃풋</code></strong> 할 수 있을 것 같았습니다. 그래서 <code>Python + Github Issue + Github Actions</code>를 이용하여 진행하기로 했습니다.</p>
<blockquote>
<ol>
<li>파이썬 문법 기초 익히기 + 파이썬 크롤러 만들기</li>
<li>스터디 모집 글 크롤링하기</li>
<li>주기적으로 정해진 시각이 크롤러 동작하기</li>
<li>새글이 있다면 핸드폰으로 알림 받기</li>
</ol>
</blockquote>
<p>이 크롤러 코드는 <a href="https://github.com/baekdev/crawler-study-gathering" target="_blank">Github</a>에 오픈해두었습니다 :)</p>
<h2>1. 크롤링 사이트의 html 구조 살펴보기</h2>
<p><img src="https://baek.dev/assets/images/post/2020/2020_017_002.png" alt="okky - 정기모임/스터디"></p>
<p>오늘 우리가 크롤링해볼 사이트는 <a href="https://okky.kr/articles/gathering" target="_blank">okky - 정기모임/스터디</a> 게시판입니다. 해당 페이지에서 인터넷 브라우저의 개발자 도구를 이용해 html 구조를 확인해봅니다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_017_003.png" alt="게시글 html code"></p>
<p>html code 스크린샷의 두번째 줄의 div가 <code>list-article</code>이라는 id를 가지고 있네요. html tag의 id값은 페이지 내에서 고유하므로 우리는 여기서부터 태그 계층 구조를 시작하려고 합니다. 코드 내 &#x3C; !-- Table -- > 주석이 있고 그 아래 <code>ul 태그</code> 부분이 글 작성 시각을 역순으로 정렬한 최신 스터디 모집 게시글 리스트 부분입니다.</p>
<pre><code class="language-html">#list-article > div > ul > li.list-group-item
</code></pre>
<p><img src="https://baek.dev/assets/images/post/2020/2020_017_004.png" alt="제목과 작성 시각 html code"><br>
li element는 글 1개와 대응되는데, 이 안에는 링크와 제목, 글 작성 시각이 담겨있습니다. <code>h5</code> 태그 안에는 제목과 링크가 있고, data-created class를 갖는 div 밑에 <code>span.timeago</code> 태그 안에 작성 시각이 있습니다. 글 작성 시각이 필요한 이유는 당일에 작성된 글만 필터하기 위함입니다.</p>
<p>이렇게 화면에서 보여진 정보를 html 소스 코드 내에서 위치를 찾고 필요한 정보가 있는지 확인하는 시간을 가져 준비를 끝냈습니다.</p>
<h2>2. 파이썬 크롤러 만들기</h2>
<p>크롤러 만들기 할일을 리스트업하면 다음과 같습니다.</p>
<blockquote>
<ol>
<li>okky 사이트를 호출하여 응답을 받아온다.</li>
<li>bs4를 이용하여 응답 결과를 html tag 타입으로 파싱한다.</li>
<li>게시글(li) tag elements를 list로 담는다.</li>
<li>마감이란 텍스트가 포함된 글 역시 제외하고 대상 글들만 모은다.</li>
<li>KST로 timezone을 설정한다.</li>
<li>기준 시각부터 하루 전 사이에 작성된 글만 추출한다.</li>
<li>오늘 작성된 글이 있다면 Github issue로 등록하여 메일로 알림을 받는다.</li>
<li>매일 정해진 시각에 자동으로 파이썬 크롤러가 작동되도록 github actions를 만든다.</li>
</ol>
</blockquote>
<p>과정을 구체적으로 나누다 보니 단계가 많지만 사실 매우 간단합니다. 그럼 바로 시작해보죠!</p>
<h3>필요한 파이썬 라이브러리를 import</h3>
<p><img src="https://baek.dev/assets/images/post/2020/2020_017_001.png"></p>
<p>필요한 라이브러리들의 사용 목적을 간략히 정리해보면,</p>
<ul>
<li>
<p>urllib</p>
<ul>
<li>지정한 url을 호출하고 돌려받은 응답을 담기 위함</li>
</ul>
</li>
<li>
<p>bs4(Beautiful Soup)</p>
<ul>
<li>Beautiful Soup은 HTML 구문 분석하기 위함</li>
</ul>
</li>
<li>
<p>github</p>
<ul>
<li>github에 issue 생성하기 위함</li>
</ul>
</li>
<li>
<p>datetime</p>
<ul>
<li>현재 시각과 시간 포멧팅을 하기 위함</li>
</ul>
</li>
<li>
<p>pytz</p>
<ul>
<li>타임 존을 사용하기 위함</li>
</ul>
</li>
<li>
<p>dateutil.parser</p>
<ul>
<li>문자열 날짜를 date로 변환하기 위함</li>
</ul>
</li>
<li>
<p>os</p>
<ul>
<li>환경 변수를 사용하기 위함</li>
</ul>
</li>
</ul>
<p>여기서 github, os, pytz는 알림을 받기 위해 필요한 것이므로 개발 스펙에 따라 없어도 무방합니다.</p>
<h3>게시글 리스트를 추출</h3>
<p><img src="https://baek.dev/assets/images/post/2020/2020_017_005.png"></p>
<blockquote>
<p>1 - okky 사이트를 호출하여 응답을 받아온다.<br>
2 - bs4를 이용하여 응답 결과를 html tag 타입으로 파싱한다.<br>
3 - 게시글(li) tag elements를 list로 담는다.</p>
</blockquote>
<p>이 단계는 할일 1~3까지의 과정입니다. 처음에 li element가 글 1개에 대응된다고 했었던 것을 기억하실 겁니다. 위 코드에서 select()메서드는 리턴 타입이 array입니다. 즉, article_list에는 게시글이 여러개 담겨 있습니다.</p>
<h3>필요한 게시글만 추출하기</h3>
<blockquote>
<p>4 - 마감이란 텍스트가 포함된 글 역시 제외하고 대상 글들만 모은다.<br>
5 - KST로 timezone을 설정한다.<br>
6 - 기준 시각부터 하루 전 사이에 작성된 글만 추출한다.</p>
</blockquote>
<p>이 단계는 할일 4~6까지의 과정입니다. <strong>article_list</strong>는 array형태기 때문에 반복문으로 각 row마다 전처리를 합니다.<br>
row는 앞서 언급한 li element입니다. 이 row 역시 html tag 타입이기 때문에 하위 태그들을 다시 선택할 수 있습니다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_017_006.png"></p>
<p>대상 글들만 필터하기 위해 날짜 구현 부를 살펴보겠습니다. 이 크롤러가 작동할 서버의 타임 존은 UTC(Github)로 날짜 생성시 KST 타임 존 설정해줘야 합니다. 타임 존을 설정하지 않을 경우, today가 글이 작성된 KST보다 과거 시간이기 때문에 일부 글들은 누락 될 수 있습니다. <strong>isDateInRange()</strong> 함수를 정의하여 날짜 계산을 합니다. 대상은 <strong>24시간 전 ~ 작동 시간</strong></p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_017_007.png"></p>
<p>더불어 모집이 끝난 게시글은 대부분 <strong>마감</strong>이란 텍스트가 포함되므로 마감된 모집 글을 제외하는 로직도 추가합니다.
이제 대상이 되는 글들은 따로 변수에 담아 분류합니다. 이 내용은 Github issue의 내용으로 사용합니다.</p>
<h2>3. Github issue로 등록하기</h2>
<blockquote>
<p>7 - 오늘 작성된 글이 있다면 Github issue로 등록하여 메일로 알림을 받는다.</p>
</blockquote>
<p>깃허브 이슈는 등록되거나 이슈에 새로운 코멘트가 달렸을 때 이메일로 알림을 받을 수 있습니다. 이 점을 이용하면 따로 Notification server를 구축하지 않고 손쉽게 알림을 받을 수 있습니다.<br>
깃허브 이슈를 생성하기 위해서는 2가지가 필요합니다.</p>
<ul>
<li>이슈를 등록할 레포지토리</li>
<li>깃허브 접근 권한이 있는 토큰</li>
</ul>
<p>토큰은 <a href="https://github.com/settings/tokens" target="_blank">Github Tokens</a>에서 발급할 수 있습니다. 하지만 토큰을 코드상에 직접 하드코딩하는 것은 매우 위험합니다. 현업에서도 이와 같이 민감한 값은 암호화에서 코드상에서 분리하여 관리합니다. 깃허브에서도 동일한 기능을 제공하는데 바로 <code>secrets</code><sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>입니다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_017_010.png"></p>
<p>secrets에 등록한 값은 추후 Github Actions에서 사용할 예정이고 값은 ENV에 담았기 때문에 os 모듈을 이용하여 토큰 값을 가져옵니다. 가져온 토큰을 이용하여 Github issue를 생성합니다.<br>
<img src="https://baek.dev/assets/images/post/2020/2020_017_008.png"></p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_017_011.png" alt="파이썬 코드로 생성한 Github issue"><br>
<img src="https://baek.dev/assets/images/post/2020/2020_017_012.png" alt="이메일로 알림"></p>
<h2>4. Github Actions으로 파이썬 크롤링 자동화하기</h2>
<blockquote>
<p>8 - 매일 정해진 시각에 자동으로 파이썬 크롤러가 작동되도록 github actions를 만든다.</p>
</blockquote>
<h3>Github Actions란?</h3>
<p><img src="https://baek.dev/assets/images/post/2020/2020_017_013.png" alt="config.yml"></p>
<p>GitHub Actions는 워크 플로우 모든 단계에 통합된 강력한 실행 환경을 제공합니다. 원하는 작업을 수행하기위한 작업을 검색, 생성 및 공유하고 이를 결합하여 워크 플로우를 커스텀할 수 있습니다.<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup></p>
<h4>YAML 설정</h4>
<p>파이썬을 일정 시각마다 자동으로 실행하고, 필요한 라이브러리 디펜던시를 명세합니다. 또한 미리 발행하여 secrets에 저장한 Github Token을 환경 변수에 설정 할 수 있습니다. 해당 잡이 도는 시각은 UTC 기준이므로 cron 패턴 작성시 유의하시면 됩니다. 우리는 KST기준 오후 6시에 한 번 수행하도록 셋팅했습니다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_017_009.png" alt="config.yml"></p>
<!-- <script src="https://gist.github.com/baekdev/8a0434f32e55a52aaae571555eaa867a.js"></script> -->
<pre><code class="language-yaml">name: ['크롤러 이름']

on:
  schedule:
    - cron: ['분 시간 월 일 년'] UTC임을 유의

jobs:
  run:
    runs-on: ['운영체제']
    steps: // job이 실행되었을 때 처리 단계
      - uses: actions/checkout@v1 // 최신의 커밋으로 가져옴
      - name: Set up Python  // 파이썬 설치
        uses: actions/setup-python@v1 // 최신의 파이썬 버전 설치
      - name: Install dependencies  // 파이썬 필요 라이브러리
        run: |
          pip install --upgrade pip // pip version up
          pip install beautifulsoup4 // bs4 설치
          pip install pytz // 타임 존 설치
          pip install PyGithub // github 설치
          pip install python-dateutil // 날짜 파서 설치
      - name: Run Crawler  // 실제 파이썬 크롤러 실행 단계
        run: |
          python crwaler.py // github repo root 경로임
        env:
          GITHUB_TOKEN: ${{ secrets.GithubToken }} // secrets에 등록해둔 토큰을 환경변수로 셋팅
</code></pre>
<p>자동으로 실행된 액션은 단계별 진행상황을 확인할 수 있습니다. 만약 job이 실패하면 즉시 메일 알림이 오기 때문에 잡이 깨지는 경우를 놓치지 않을 수 있어서 좋습니다.<br>
<img src="https://baek.dev/assets/images/post/2020/2020_017_014.png" alt="Github Action log"></p>
<h3>마치며</h3>
<p>오늘 함께 만들어본 크롤러는 <strong>매우 작고 귀엽지만</strong> 단순히 파이썬 크롤러를 만들어보는 것에 그치지 않고 자동화로 발전시켜 더욱 흥미로운 토이 프로젝트가 되었습니다. 지금은 스터디 게시판이 okky 한 곳이지만, 다른 사이트도 계속해서 추가하여 더 디벨롭하려고 합니다. 미뤄왔던 파이썬을 익혀보고 아웃풋까지 낸 이번 프로젝트를 통해 크롤링의 세계로 입문해보시면 어떨까요?<br>
<code>다른 스터디 모집 게시판이 있다면 댓글로 남겨주세요!</code> 해당 사이트도 추가해보겠습니다 :)</p>
<p>참고로 <a href="https://github.com/baekdev/crawler-study-gathering" target="_blank">baekdev/crawler-study-gathering</a> 레포지토리를 Watching하시면 스터디 모집 글 모음 알림을 받을 수 있습니다!</p>
<h3>참고 할만한 글</h3>
<ul>
<li><a href="https://ahnheejong.name/articles/receive-new-room-notification-mails-using-github-action/" target="_blank">GitHub Action을 사용해 새로 올라온 전월세 방 목록 받아보기</a></li>
<li><a href="https://jonnung.dev/devops/2020/01/31/github_action_getting_started/" target="_blank">Github Action 빠르게 시작하기</a></li>
</ul>
<div class="footnotes">
<hr>
<ol>
<li id="fn-1">
<p>Encrypted secrets allow you to store sensitive information, such as access tokens, in your repository. <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/creating-and-using-encrypted-secrets" target="_blank">Github Secrets</a></p>
<a href="#fnref-1" class="footnote-backref">↩</a>
</li>
<li id="fn-2">
<p>GitHub Actions features a powerful execution environment integrated into every step of your workflow. You can discover, create, and share actions to perform any job you'd like, and combine them to customize your workflow. <a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions" target="_blank">Github Actions</a></p>
<a href="#fnref-2" class="footnote-backref">↩</a>
</li>
</ol>
</div>]]></description><link>https://baek.dev/post/17/</link><guid isPermaLink="false">https://baek.dev/post/17/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Fri, 07 Feb 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;이번 설 연휴 동안 다짐했던 목표가 있었습니다. 바로 파이썬 공부 시작과 함께 파이썬 크롤러 만들기! 파이썬 기본 문법과 자료구조를 빠르게 공부한 뒤, 바로 파이썬 크롤러 만들기에 들어갔습니다. 파이썬 크롤러 코드가 이해가 되고 해보고 싶은 만큼 조금씩 변형해볼 수 있으니 너무 재밌었습니다.&lt;/p&gt;
&lt;p&gt;이번에 단순히 크롤링하는 라이브러리를 익혀보는 것으로 끝내기보다, 평소 갈증이 있었던 스터디 모집 새글 알림을 받도록하는 크롤링을 목표로 발전시켰습니다. 그럼 이번 공부를 &lt;strong&gt;&lt;code&gt;아웃풋&lt;/code&gt;&lt;/strong&gt; 할 수 있을 것 같았습니다. 그래서 &lt;code&gt;Python + Github Issue + Github Actions&lt;/code&gt;를 이용하여 진행하기로 했습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;파이썬 문법 기초 익히기 + 파이썬 크롤러 만들기&lt;/li&gt;
&lt;li&gt;스터디 모집 글 크롤링하기&lt;/li&gt;
&lt;li&gt;주기적으로 정해진 시각이 크롤러 동작하기&lt;/li&gt;
&lt;li&gt;새글이 있다면 핸드폰으로 알림 받기&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 크롤러 코드는 &lt;a href=&quot;https://github.com/baekdev/crawler-study-gathering&quot; target=&quot;_blank&quot;&gt;Github&lt;/a&gt;에 오픈해두었습니다 :)&lt;/p&gt;
&lt;h2&gt;1. 크롤링 사이트의 html 구조 살펴보기&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_017_002.png&quot; alt=&quot;okky - 정기모임/스터디&quot;&gt;&lt;/p&gt;
&lt;p&gt;오늘 우리가 크롤링해볼 사이트는 &lt;a href=&quot;https://okky.kr/articles/gathering&quot; target=&quot;_blank&quot;&gt;okky - 정기모임/스터디&lt;/a&gt; 게시판입니다. 해당 페이지에서 인터넷 브라우저의 개발자 도구를 이용해 html 구조를 확인해봅니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_017_003.png&quot; alt=&quot;게시글 html code&quot;&gt;&lt;/p&gt;
&lt;p&gt;html code 스크린샷의 두번째 줄의 div가 &lt;code&gt;list-article&lt;/code&gt;이라는 id를 가지고 있네요. html tag의 id값은 페이지 내에서 고유하므로 우리는 여기서부터 태그 계층 구조를 시작하려고 합니다. 코드 내 &amp;#x3C; !-- Table -- &gt; 주석이 있고 그 아래 &lt;code&gt;ul 태그&lt;/code&gt; 부분이 글 작성 시각을 역순으로 정렬한 최신 스터디 모집 게시글 리스트 부분입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;#list-article &gt; div &gt; ul &gt; li.list-group-item
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_017_004.png&quot; alt=&quot;제목과 작성 시각 html code&quot;&gt;&lt;br&gt;
li element는 글 1개와 대응되는데, 이 안에는 링크와 제목, 글 작성 시각이 담겨있습니다. &lt;code&gt;h5&lt;/code&gt; 태그 안에는 제목과 링크가 있고, data-created class를 갖는 div 밑에 &lt;code&gt;span.timeago&lt;/code&gt; 태그 안에 작성 시각이 있습니다. 글 작성 시각이 필요한 이유는 당일에 작성된 글만 필터하기 위함입니다.&lt;/p&gt;
&lt;p&gt;이렇게 화면에서 보여진 정보를 html 소스 코드 내에서 위치를 찾고 필요한 정보가 있는지 확인하는 시간을 가져 준비를 끝냈습니다.&lt;/p&gt;
&lt;h2&gt;2. 파이썬 크롤러 만들기&lt;/h2&gt;
&lt;p&gt;크롤러 만들기 할일을 리스트업하면 다음과 같습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;okky 사이트를 호출하여 응답을 받아온다.&lt;/li&gt;
&lt;li&gt;bs4를 이용하여 응답 결과를 html tag 타입으로 파싱한다.&lt;/li&gt;
&lt;li&gt;게시글(li) tag elements를 list로 담는다.&lt;/li&gt;
&lt;li&gt;마감이란 텍스트가 포함된 글 역시 제외하고 대상 글들만 모은다.&lt;/li&gt;
&lt;li&gt;KST로 timezone을 설정한다.&lt;/li&gt;
&lt;li&gt;기준 시각부터 하루 전 사이에 작성된 글만 추출한다.&lt;/li&gt;
&lt;li&gt;오늘 작성된 글이 있다면 Github issue로 등록하여 메일로 알림을 받는다.&lt;/li&gt;
&lt;li&gt;매일 정해진 시각에 자동으로 파이썬 크롤러가 작동되도록 github actions를 만든다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;과정을 구체적으로 나누다 보니 단계가 많지만 사실 매우 간단합니다. 그럼 바로 시작해보죠!&lt;/p&gt;
&lt;h3&gt;필요한 파이썬 라이브러리를 import&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_017_001.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;필요한 라이브러리들의 사용 목적을 간략히 정리해보면,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;urllib&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;지정한 url을 호출하고 돌려받은 응답을 담기 위함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bs4(Beautiful Soup)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Beautiful Soup은 HTML 구문 분석하기 위함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;github&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github에 issue 생성하기 위함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;datetime&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;현재 시각과 시간 포멧팅을 하기 위함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pytz&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;타임 존을 사용하기 위함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dateutil.parser&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;문자열 날짜를 date로 변환하기 위함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;os&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;환경 변수를 사용하기 위함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여기서 github, os, pytz는 알림을 받기 위해 필요한 것이므로 개발 스펙에 따라 없어도 무방합니다.&lt;/p&gt;
&lt;h3&gt;게시글 리스트를 추출&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_017_005.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1 - okky 사이트를 호출하여 응답을 받아온다.&lt;br&gt;
2 - bs4를 이용하여 응답 결과를 html tag 타입으로 파싱한다.&lt;br&gt;
3 - 게시글(li) tag elements를 list로 담는다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 단계는 할일 1~3까지의 과정입니다. 처음에 li element가 글 1개에 대응된다고 했었던 것을 기억하실 겁니다. 위 코드에서 select()메서드는 리턴 타입이 array입니다. 즉, article_list에는 게시글이 여러개 담겨 있습니다.&lt;/p&gt;
&lt;h3&gt;필요한 게시글만 추출하기&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;4 - 마감이란 텍스트가 포함된 글 역시 제외하고 대상 글들만 모은다.&lt;br&gt;
5 - KST로 timezone을 설정한다.&lt;br&gt;
6 - 기준 시각부터 하루 전 사이에 작성된 글만 추출한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 단계는 할일 4~6까지의 과정입니다. &lt;strong&gt;article_list&lt;/strong&gt;는 array형태기 때문에 반복문으로 각 row마다 전처리를 합니다.&lt;br&gt;
row는 앞서 언급한 li element입니다. 이 row 역시 html tag 타입이기 때문에 하위 태그들을 다시 선택할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_017_006.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;대상 글들만 필터하기 위해 날짜 구현 부를 살펴보겠습니다. 이 크롤러가 작동할 서버의 타임 존은 UTC(Github)로 날짜 생성시 KST 타임 존 설정해줘야 합니다. 타임 존을 설정하지 않을 경우, today가 글이 작성된 KST보다 과거 시간이기 때문에 일부 글들은 누락 될 수 있습니다. &lt;strong&gt;isDateInRange()&lt;/strong&gt; 함수를 정의하여 날짜 계산을 합니다. 대상은 &lt;strong&gt;24시간 전 ~ 작동 시간&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_017_007.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;더불어 모집이 끝난 게시글은 대부분 &lt;strong&gt;마감&lt;/strong&gt;이란 텍스트가 포함되므로 마감된 모집 글을 제외하는 로직도 추가합니다.
이제 대상이 되는 글들은 따로 변수에 담아 분류합니다. 이 내용은 Github issue의 내용으로 사용합니다.&lt;/p&gt;
&lt;h2&gt;3. Github issue로 등록하기&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;7 - 오늘 작성된 글이 있다면 Github issue로 등록하여 메일로 알림을 받는다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;깃허브 이슈는 등록되거나 이슈에 새로운 코멘트가 달렸을 때 이메일로 알림을 받을 수 있습니다. 이 점을 이용하면 따로 Notification server를 구축하지 않고 손쉽게 알림을 받을 수 있습니다.&lt;br&gt;
깃허브 이슈를 생성하기 위해서는 2가지가 필요합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이슈를 등록할 레포지토리&lt;/li&gt;
&lt;li&gt;깃허브 접근 권한이 있는 토큰&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;토큰은 &lt;a href=&quot;https://github.com/settings/tokens&quot; target=&quot;_blank&quot;&gt;Github Tokens&lt;/a&gt;에서 발급할 수 있습니다. 하지만 토큰을 코드상에 직접 하드코딩하는 것은 매우 위험합니다. 현업에서도 이와 같이 민감한 값은 암호화에서 코드상에서 분리하여 관리합니다. 깃허브에서도 동일한 기능을 제공하는데 바로 &lt;code&gt;secrets&lt;/code&gt;&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_017_010.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;secrets에 등록한 값은 추후 Github Actions에서 사용할 예정이고 값은 ENV에 담았기 때문에 os 모듈을 이용하여 토큰 값을 가져옵니다. 가져온 토큰을 이용하여 Github issue를 생성합니다.&lt;br&gt;
&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_017_008.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_017_011.png&quot; alt=&quot;파이썬 코드로 생성한 Github issue&quot;&gt;&lt;br&gt;
&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_017_012.png&quot; alt=&quot;이메일로 알림&quot;&gt;&lt;/p&gt;
&lt;h2&gt;4. Github Actions으로 파이썬 크롤링 자동화하기&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;8 - 매일 정해진 시각에 자동으로 파이썬 크롤러가 작동되도록 github actions를 만든다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Github Actions란?&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_017_013.png&quot; alt=&quot;config.yml&quot;&gt;&lt;/p&gt;
&lt;p&gt;GitHub Actions는 워크 플로우 모든 단계에 통합된 강력한 실행 환경을 제공합니다. 원하는 작업을 수행하기위한 작업을 검색, 생성 및 공유하고 이를 결합하여 워크 플로우를 커스텀할 수 있습니다.&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h4&gt;YAML 설정&lt;/h4&gt;
&lt;p&gt;파이썬을 일정 시각마다 자동으로 실행하고, 필요한 라이브러리 디펜던시를 명세합니다. 또한 미리 발행하여 secrets에 저장한 Github Token을 환경 변수에 설정 할 수 있습니다. 해당 잡이 도는 시각은 UTC 기준이므로 cron 패턴 작성시 유의하시면 됩니다. 우리는 KST기준 오후 6시에 한 번 수행하도록 셋팅했습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_017_009.png&quot; alt=&quot;config.yml&quot;&gt;&lt;/p&gt;
&lt;!-- &lt;script src=&quot;https://gist.github.com/baekdev/8a0434f32e55a52aaae571555eaa867a.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;name: [&apos;크롤러 이름&apos;]

on:
  schedule:
    - cron: [&apos;분 시간 월 일 년&apos;] UTC임을 유의

jobs:
  run:
    runs-on: [&apos;운영체제&apos;]
    steps: // job이 실행되었을 때 처리 단계
      - uses: actions/checkout@v1 // 최신의 커밋으로 가져옴
      - name: Set up Python  // 파이썬 설치
        uses: actions/setup-python@v1 // 최신의 파이썬 버전 설치
      - name: Install dependencies  // 파이썬 필요 라이브러리
        run: |
          pip install --upgrade pip // pip version up
          pip install beautifulsoup4 // bs4 설치
          pip install pytz // 타임 존 설치
          pip install PyGithub // github 설치
          pip install python-dateutil // 날짜 파서 설치
      - name: Run Crawler  // 실제 파이썬 크롤러 실행 단계
        run: |
          python crwaler.py // github repo root 경로임
        env:
          GITHUB_TOKEN: ${{ secrets.GithubToken }} // secrets에 등록해둔 토큰을 환경변수로 셋팅
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;자동으로 실행된 액션은 단계별 진행상황을 확인할 수 있습니다. 만약 job이 실패하면 즉시 메일 알림이 오기 때문에 잡이 깨지는 경우를 놓치지 않을 수 있어서 좋습니다.&lt;br&gt;
&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_017_014.png&quot; alt=&quot;Github Action log&quot;&gt;&lt;/p&gt;
&lt;h3&gt;마치며&lt;/h3&gt;
&lt;p&gt;오늘 함께 만들어본 크롤러는 &lt;strong&gt;매우 작고 귀엽지만&lt;/strong&gt; 단순히 파이썬 크롤러를 만들어보는 것에 그치지 않고 자동화로 발전시켜 더욱 흥미로운 토이 프로젝트가 되었습니다. 지금은 스터디 게시판이 okky 한 곳이지만, 다른 사이트도 계속해서 추가하여 더 디벨롭하려고 합니다. 미뤄왔던 파이썬을 익혀보고 아웃풋까지 낸 이번 프로젝트를 통해 크롤링의 세계로 입문해보시면 어떨까요?&lt;br&gt;
&lt;code&gt;다른 스터디 모집 게시판이 있다면 댓글로 남겨주세요!&lt;/code&gt; 해당 사이트도 추가해보겠습니다 :)&lt;/p&gt;
&lt;p&gt;참고로 &lt;a href=&quot;https://github.com/baekdev/crawler-study-gathering&quot; target=&quot;_blank&quot;&gt;baekdev/crawler-study-gathering&lt;/a&gt; 레포지토리를 Watching하시면 스터디 모집 글 모음 알림을 받을 수 있습니다!&lt;/p&gt;
&lt;h3&gt;참고 할만한 글&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ahnheejong.name/articles/receive-new-room-notification-mails-using-github-action/&quot; target=&quot;_blank&quot;&gt;GitHub Action을 사용해 새로 올라온 전월세 방 목록 받아보기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jonnung.dev/devops/2020/01/31/github_action_getting_started/&quot; target=&quot;_blank&quot;&gt;Github Action 빠르게 시작하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;Encrypted secrets allow you to store sensitive information, such as access tokens, in your repository. &lt;a href=&quot;https://help.github.com/en/actions/automating-your-workflow-with-github-actions/creating-and-using-encrypted-secrets&quot; target=&quot;_blank&quot;&gt;Github Secrets&lt;/a&gt;&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-2&quot;&gt;
&lt;p&gt;GitHub Actions features a powerful execution environment integrated into every step of your workflow. You can discover, create, and share actions to perform any job you&apos;d like, and combine them to customize your workflow. &lt;a href=&quot;https://help.github.com/en/actions/automating-your-workflow-with-github-actions&quot; target=&quot;_blank&quot;&gt;Github Actions&lt;/a&gt;&lt;/p&gt;
&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[털어놓기 어려웠던 개발자로서 고민을 해결해준 책, 함께 자라기]]></title><description><![CDATA[<div class="row">
  <div class="col-md-5">
      <a href="https://coupa.ng/bl0Era" target="_blank"><ResizeImage src="https://image.aladin.co.kr/product/17597/74/cover500/8966262333_1.jpg" height="300px;" alt="함께 자라기 - 애자일로 가는 길" /></a>  
  </div>
  
  <div class="col-md-7">
  
    <blockquote>
      <p>
      내가 정말 잘할 수 있을까?
      아니, 우리가 정말 자랄 수 있을까?
      스스로 변하고 싶지만 계속 실패하는 사람, 혹은 조직을 개선하기 위한 시도를 하다가 오히려 데어 본 사람,
      하루하루가 답답한 사람들을 위해 이 책을 썼습니다.
      (함께 자라기, 김창준 저)
      </p>
    </blockquote>
  
  </div>
</div>
<h2>고민의 굴레, 슬럼프</h2>
<p>저는 작년 한 해 동안 많은 고민과 번뇌에 둘러싸여었습니다. 더 많이 공부하고 노력하는데 어찌 된 일인지 성장하고 있지 않다는 느낌은 점점 짙어져만 갔습니다. 제 능력이 부족한지 의심하기도 하고 환경을 탓하기도 했습니다. 핑계는 참 많았고 타협은 늘 이어졌습니다. 하지만 결국 나아지는 것은 없었습니다. 지금에서야 여유 갖고 돌아보니 오히려 당시엔 부정적인 생각에 점점 더 갇혔던 것 같습니다.</p>
<p>개발자란 직업을 갖고 있는 한 공부는 계속 이어져야 하고 쉴 때도 손에서 노트북을 놓지 않았습니다. 끊임없이 공부해야 하는 직군이라 더 심적인 부담도 있었습니다. 제가 이렇게 방황하고 있는 와중에도 다른 유능하신 분들의 발자국과 비교하며 제 한계를 무의식중에 정해버린 적도 있습니다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_016_002.jpg"></p>
<p>개발자가 되고 싶었던 꿈은 이뤘지만 하고 싶은 개발보다 해야 되는 개발을 하면서 회사 코드는 제 것이 아니라는 생각이 더 커졌습니다. 퇴근 후에는 제가 하고 싶은 공부를 하지만 막상 써볼 곳이 없으니 크게 진도가 나가지 않고 이것저것 들춰보다 끝나기 일쑤였습니다. 회사에서는 업무 처리하기도 바쁜데 다른 분들은 어찌 그렇게 러닝 커브도 좋으신지 더 자괴감이 들었습니다.</p>
<h2>네가 오길 기다렸어</h2>
<p>점점 현실로부터 도망치고 싶어지기 시작한 저는, 어쩌면 개발자가 적성에 맞지 않나라는 생각마저 들기 시작했습니다. 이대로는 안 되겠다 싶어 주저하다 친한 개발자분에게 고민을 털어놨습니다.
그때 그분은 구구절절 많은 대답 대신 <a href="https://coupa.ng/bl0Era" target="_blank">&#x3C;함께 자라기></a> 책을 읽어보라고 권해줬습니다. 함께 자라기는 이미 제가 소장하고 있었지만, 아직 읽기 전이었습니다. 가지고 있던 책이라 그날부터 바로 읽기 시작해 단숨에 읽었습니다. 좋은 내용이 너무 많아 밑줄이 없는 쪽이 없을 정도였습니다.</p>
<blockquote>
<p>이 책은 마치 저를 기다린 것 같았습니다</p>
</blockquote>
<p>'스스로 변하고 싶지만 계속 실패하는 사람, 혹은 조직을 개선하기 위한 시도를 하다가 오히려 데어 본 사람, 하루하루가 답답한 사람들을 위해 이 책을 썼습니다.'로 머리말을 시작하는데 가슴이 벅차올랐습니다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_016_047.jpg" alt="책에 밑줄 치지 않은 곳이 없을 정도로, 즐겨찾기가 무의미할 정도로 모든 페이지가 주옥같은 책입니다"></p>
<h2>잘하기에서 자라기로</h2>
<p>학교 교과 과정을 이수하며 배운 학습 방법은 대부분 개별적이고 순차적이며, 교과서와 교재에서 시험 범위가 정해져 있습니다. 이 시험이라는 도구를 통해 학생 성취도 평가를 진행합니다. 결국, 그 이야기는 정답이란 것이 늘 존재한다는 것이죠. 정답은 더 나아가 합격과 자격증이라는 목표로 이어지게 됩니다. 이러한 학습 방법은 <em>학교 학습</em>이라고 칭하며 결과 중심적이고 수치에 치중된 방식입니다. 이와 반대되는 개념을 소개하는 것으로 책은 시작합니다. 바로 <code>야생 학습</code>입니다.</p>
<p>야생 학습은</p>
<ul>
<li>대부분 협력적이며</li>
<li>대부분 비순차적이고</li>
<li>대부분 자료에 한정이 없으며</li>
<li>대부분 명확한 평가도 없고</li>
<li>대부분 정답이 없으며</li>
<li>대부분 목표가 불분명하고 바뀌기도 합니다.</li>
</ul>
<p>야생 학습이란 표현은 낯설지만 사실 제가 지금 하고 있는 개발 과정과 다르지 않았습니다. 하나의 요구사항을 끝냈다고 해서 그 기능은 그것으로 정답이고 불변하지 않으며 그 기능의 평가가 절대적이라고 보기 어렵습니다. 더 나은 비즈니스를 모색하며 새로운 목표를 짧은 기간 안에 정하고 그 목표를 실현하기 위해 다양한 기술 스택을 모색하기도 합니다. fail fast를 위해 우리는 새로운 기술의 도큐먼트를 목차대로 모두 정독한 뒤 개발을 시작하지 않습니다. 자바 API를 A to Z로 읽지 않는 것처럼 말이죠.</p>
<h2>당신이 제자리 걸음인 이유</h2>
<p>1만 시간의 법칙을 모두 한 번쯤은 들어보셨을 것입니다. 그럼 우리는 양치질과 세수를 평생 해왔으니 이 분야의 달인일까요? 우리는 양치질 전문가라고 할 수 있을까요? 좀 더 나아가 회사에서 하는 개발은 1만 시간 안에 해당까요? 시간이 흐름에 따라 매년 연차가 저절로 쌓이다 어느 날 10년 차의 경력자가 되었을 때 저는 전문가라고 말할 수 있을까요?</p>
<p>어떠한 장치 없이 흐른 업무 시간은 1만 시간에 포함되지 않습니다. 저는 이 또한 제 노력의 시간에 포함된 것이라고 착각했고 저와 같은 분들도 계실 거로 생각합니다. 하루 8시간에 퇴근 후 추가로 하는 공부까지 했지만 성장하지 못한다는 느낌은 틀린 것이 아니었습니다. 하지만 회사 일을 하는 시간도 1만 시간에 포함할 수 있는 수련법이 있습니다.</p>
<p>바로 <code>의도적 수련</code>입니다. 악기 연주자에게 공연 시간은 이런 의도적 수련이 되지 못한다는 연구가 있습니다. 자신의 기량을 향상할 목적으로 반복해야 의도적 수련이 되는 것이죠.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_016_049.jpg" alt="작업 난이도"></p>
<p>위 그림에서 A 영역의 일은 실력이 작업 난이도를 초과하는 지역으로 지금 당장은 쉽지만 조금만 지나면 지루함을 느끼게 됩니다.<br>
B 영역은 실력보다 작업 난이도가 더 높은 지역으로 불안함이나 두려움을 느끼게 됩니다.<br>
그럼 가운데 위치한 C 영역은 실력과 작업 난이도가 엇비슷한 부분으로 미하이<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>는 이 부분에서 인간이 몰입을 경험한다고 말합니다. 교육학에서는 학습 시 불필요하게 인지적인 부담을 주면 어떤 것도 제대로 학습하기 어렵다는 말을 합니다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_016_042.jpg"><br>
즉, <strong>의도적 수련을 위해서는 적절한 난이도가 필수 요건</strong>입니다. 자신이 업무 시간 중에 불안함이나 지루함을 느끼는 때가 대부분이라면, 실력이 도무지 늘지 않는 환경에 있는 겁니다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_016_048.jpg" alt="작업 난이도"></p>
<p><strong>제자리걸음에서 벗어나는 방법은 난이도를 조절하며 몰입 영역의 안으로 이동하는 것입니다.</strong> 평소 마우스를 많이 사용해 개발 했다면 이번에는 마우스를 사용하지 않고 키보드로만 개발 하거나, 디버거를 늘 쓰는 경우 디버거를 쓰지 않거나 하는 것이죠. 혹은 이번에 개발 해야 되는 내용이 쉽다고 느껴지면 시간 제약을 두는 것입니다. 10분 안에 동작할 수 있는 코드 만들기 또는 TDD를 사용하지 않았다면 TDD를 적용해 개발해보기 등으로 내게 스스로 미션을 주는 것입니다.</p>
<p>저도 TDD에 관해서 공부는 했지만, 실무에서 막상 쓰기 어려웠습니다. 늘 비즈니스에서 쫓겨 TDD를 실천할 마음의 여유가 없었습니다. 그러다 며칠 전 매우 작은 컨버터를 하나 추가해야 했습니다. 사용자 이름이 긴 경우 일정 길이까지만 보여주고 나머지는 ...으로 줄임 표시를 하는 것이죠. 평소 같았으면 쉬운 내용이니 빨리 개발해놓고 여유를 부렸겠지만, 이번에는 TDD를 적용해보기 마음먹었습니다. 빨간 줄의 압박을 받으며 단계별로 코드를 작성하고 녹색 신호등을 보고, 다시 빨간 줄을 보고 녹색 신호등을 보며 재밌게 코딩했습니다. 막상 TDD를 실무에서 해보니 테스트 코드를 추후 작성해야 한다는 부담감도 없어졌고, 생각보다 지속적으로 도입해볼 만 하겠다는 용기도 생겼습니다.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/5/54/HK_Star_Bruce_Lee_16.jpg" alt="이소룡은 3분안에 상대를 제압한다는 셀프 미션을 가지고 훈련했습니다."></p>
<p>실력보다 작업 난이도가 높은 경우가 찾아올 수도 있습니다. 이때는 혼자서 해결하기는 어려우므로 페어 프로그래밍을 하거나 다른 툴 사용을 도입하거나 과거 비슷한 일을 했던 경험을 복기하며 이미지 트레이닝을 하면 도움이 됩니다. 혹은 작업 난이도를 낮춰 시작하면서 점차 살을 붙여가는 것이죠.</p>
<h2>의도적 수련</h2>
<p>이런 의도적 수련을 좀 더 깊이 있게 다룬 글이 있어 소개하고 싶습니다. <a href="https://www.popit.kr/si-%EA%B0%9C%EB%B0%9C-10%EB%85%84%EC%B0%A8%EC%9D%B8%EB%8D%B0-%EC%BD%94%EB%93%9C-%EC%A2%80-%EB%B4%90%EC%A3%BC%EC%84%B8%EC%9A%94/" target="_blank">SI 개발 10년 차인데 코드 좀 봐주세요</a>란 기고입니다.</p>
<p>본문 중 업무와 관련되지 않는 분야에 대해 별도의 시간을 투자하여 하는 공부는 깊이 있는 기술을 익히는데 한계가 있고 효율적이지 않기 때문에 권장하지 않는다고 합니다. 실무에서 얻은 지식과의 차이는 매우 크기 때문입니다. 현재 개발/운영 환경을 개선하며 견고하게 만들려는 미션을 스스로 제시하고 이 부분에 대해 깊이 파고들면 기능 하나를 만드는 것도 시간이 오래 걸리게 된다고 말합니다. 이렇게 부족한 시간은 원래 다른 기술 스택을 공부하려고 했던 시간을 이용해서 채울 수가 있고 실무에 적용해보며 계속 순환을 하도록 하는 것을 강조합니다.</p>
<p>그럼 여기서부터 이제 회사 일과 나를 위한 학습의 경계가 모호해지게 되며 좀 더 몰입의 영역으로 다가갈 수 있게 됩니다. 이렇게 의도적 수련을 할 수 있는 것이라 소개합니다.</p>
<p>초반에 제 고민을 설명했을 때 저는 효율적이지도 못하고 깊이 있게 들어가기 어려운 공부를 계속하며 정체되었다고 느낀다고 했습니다. 잘못된 수련을 하고 있었던 것이죠. 물론 새로운 것을 익히며 도입해볼 수 있겠지만, 기존 환경에 대해 깊게 관심을 갖지 않았다면 새로운 기술도 크게 빛을 바라기는 어렵습니다.</p>
<h2>빠른 피드백</h2>
<p>불확실한 환경에서 빠른 실행과 피드백을 요하는 애자일은 소프트웨어 개발 중 학습을 병목 요인 중 하나로 봅니다. 일반적인 프로젝트는 설계 단계의 피드백을 몇 달 후에 받게 됩니다. 애자일 프로젝트는 지금 내가 한 행동의 피드백을 하루 후, 일주일 후 등 여러 주기를 통해 지속적으로 얻을 수 있습니다. 직전에 저지른 실수는 바로 다음 주기에 교정할 수 있어 사이클을 빠르게 수정하며 운영할 수 있죠.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_016_044.jpg" alt="쾌속 학습"></p>
<p>이상향의 프로그램을 한 번에 만들기보다는 지금 동작 가능한 작은 단위로 빠르게 피처를 만들어 나가며 계속 피드백을 받는 것이 중요합니다. 저는 전자의 방식을 채택했으며 마치 수영을 배우러 갔는데 풀장 밖에서 선생님이 수영하는 모습만 보고, 책에 쓰여있는 팔다리 움직이는 방법만 보고 있는 격이었습니다. 작게라도 만들어보는 것이 중요하며 새로운 기술을 마주할 때 무엇을 만들지를 정해놓고 빠르게 훑고 만들어 나가는 것이 중요합니다.</p>
<h2>한계는 스스로 정해버리는 것</h2>
<p>저는 잘못된 수련을 하면서 좌절감을 느끼며 제 한계를 낮추기도 했습니다. 깊고 어려운 영역의 일은 내가 할 수 있지 않다고 말이죠. 그러던 와중에 인프런의 한 통의 광고 메일이 제게 경종을 울렸습니다.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_016_050.jpg"></p>
<p>피터 드러커<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup>는 사람은 스스로가 성취하고 획득할 수 있다고 생각하는 바에 따라 성장한다고 했습니다. 제가 정한 한계에 부딪혀 더 깊은 슬럼프로 빠지게 되고 결국 극복할 수 없게 되었을지도 모르겠습니다. 물론 아직 야생 학습과 의도적 수련을 십분 활용하진 못하지만 적어도 학교 학습과 실행 프레임에 가두는 수련은 하지 않고 있습니다. 그리고 무엇보다 할 수 있다는 자신감을 되찾았고 남들과 비교하지 않고 제 길을 걸어가리라 다짐했습니다.</p>
<p>그동안은 트렌드를 쫓기에 바빴고 만들어지는 결과물이 없으니 피드백을 받을 일도 없었습니다. 그럴수록 회사 업무에서 더 멀어지고 싶다는 생각만 짙어지는 악순환이었습니다. 그래서 러닝 커브가 좋아지지 못했죠. 하루는 개발자 선배에게 여쭈었습니다.</p>
<blockquote>
<p>어떻게 러닝 커브를 좋게 할 수 있을까요?<br>
단순히 튜토리얼에 있는 내용으로 프로그래밍했다고 해서 러닝 커브가 좋다고 하지는 않잖아요.</p>
</blockquote>
<p>선배 역시 단 한 단어로 답했습니다. 바로 <code>관심</code>입니다. 관심의 차이가 좋은 러닝 커브를 만든다고 합니다. 관심이 없으면 더 나아갈 지식이나 원리를 알고 싶어 하지 않는다는 것이죠. 더 좋은 성능이나 더 빠른 적용을 위해 어떻게 하면 될지 고민하는 것은 관심 없이는 어렵다는 것입니다. 이 이야기는 앞서 의도적 수련에서 언급한 맥락과 이어진다는 것을 알아차릴 수 있죠.</p>
<p><img src="https://baek.dev/assets/images/post/2020/2020_016_041.jpg" alt="인공지능으로 대체 가능한 위험군에 속하는 컴퓨터 프로그래머"><br>
다른 사람이 준 스펙대로 개발하는 것을 주 업무로 하는 컴퓨터 프로그래머가 있습니다. 협상과 설득이 크게 필요치 않죠. 반대로 소프트웨어를 뭘 만들지 고민하고 설계하는 부분이 포함되며, 과정에서 타인과 상호 작용하는 업무가 많은 소프트웨어 개발자가 있습니다. 개발자라는 같은 범주에 속하지만 일하는 과정은 다른 두 직업 중 컴퓨터 프로그래머는 인공지능으로 대체 가능한 위험군에 속합니다. 이런 위험에서 살아남기 위해서는 인공지능이 대체하기 어려운 암묵지와 직관을 잘 학습하는 사람들이 높은 경쟁력을 가질 것입니다. 이 지점에서 중요한 포인트 역시 관심이라고 생각합니다.</p>
<h2>강력 추천</h2>
<p>돌이켜보니 작년은 슬럼프였습니다. 성장이 정체되고 잘못된 방법으로 수련했으니 나아지기 어려웠습니다. <a href="https://coupa.ng/bl0Era" target="_blank">&#x3C;함께 자라기></a> 를 통해 저를 돌아볼 수 있었고 슬럼프에서 벗어날 수 있었습니다. 저와 같은 고민을 하고 계신 분이라면 <a href="https://coupa.ng/bl0Era" target="_blank">&#x3C;함께 자라기></a> 일독을 추천합니다. 이 리뷰 글에서는 주로 야생 학습과 의도적 수련에 관한 이야기를 중점으로 다뤘으나 팀원들과 함께 성장하는 방법, 애자일 도입 방법에 관한 이야기도 있습니다.</p>
<p>마지막으로 책은 읽을 책을 사는 것이 아니라 산 책중에 읽는 것이라고 합니다 :-)<br>
<img src="https://baek.dev/assets/images/post/2020/2020_016_001.jpg" alt="Thanks to 숨비"></p>
<h3>참고 할만한 글</h3>
<ul>
<li><a href="https://www.popit.kr/si-%EA%B0%9C%EB%B0%9C-10%EB%85%84%EC%B0%A8%EC%9D%B8%EB%8D%B0-%EC%BD%94%EB%93%9C-%EC%A2%80-%EB%B4%90%EC%A3%BC%EC%84%B8%EC%9A%94/" target="_blank">SI 개발 10년차인데 코드 좀 봐주세요</a></li>
<li><a href="https://www.popit.kr/%ED%8F%89%EB%B2%94%ED%95%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EA%B7%B8-%EC%9D%B4%EC%83%81%EC%9D%B4-%EB%90%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EC%95%BC%EC%83%9D-%ED%95%99%EC%8A%B5-%EB%B9%84%EA%B2%B0/" target="_blank">평범한 개발자 그 이상이 되기 위한 야생 학습 비결</a></li>
</ul>
<div class="footnotes">
<hr>
<ol>
<li id="fn-1">
<p>미하이. 미국의 저명한 심리학자로 몰입에 대한 연구로 유명합니다.</p>
<a href="#fnref-1" class="footnote-backref">↩</a>
</li>
<li id="fn-2">
<p>피터 드러커. 미국의 경영학자. 현대 경영학을 창시한 학자로 평가받으며 경제적 제원을 잘 활용하고 관리하면 인간생활의 향상과 사회발전을 이룰 수 있다고 생각했습니다. 그는 이런 신념을 바탕으로 한 경영관리의 방법을 체계화시켜 현대 경영학을 확립하였습니다.</p>
<a href="#fnref-2" class="footnote-backref">↩</a>
</li>
</ol>
</div>]]></description><link>https://baek.dev/post/16/</link><guid isPermaLink="false">https://baek.dev/post/16/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Mon, 13 Jan 2020 00:00:00 GMT</pubDate><content:encoded>&lt;div class=&quot;row&quot;&gt;
  &lt;div class=&quot;col-md-5&quot;&gt;
      &lt;a href=&quot;https://coupa.ng/bl0Era&quot; target=&quot;_blank&quot;&gt;&lt;ResizeImage src=&quot;https://image.aladin.co.kr/product/17597/74/cover500/8966262333_1.jpg&quot; height=&quot;300px;&quot; alt=&quot;함께 자라기 - 애자일로 가는 길&quot; /&gt;&lt;/a&gt;  
  &lt;/div&gt;
  
  &lt;div class=&quot;col-md-7&quot;&gt;
  
    &lt;blockquote&gt;
      &lt;p&gt;
      내가 정말 잘할 수 있을까?
      아니, 우리가 정말 자랄 수 있을까?
      스스로 변하고 싶지만 계속 실패하는 사람, 혹은 조직을 개선하기 위한 시도를 하다가 오히려 데어 본 사람,
      하루하루가 답답한 사람들을 위해 이 책을 썼습니다.
      (함께 자라기, 김창준 저)
      &lt;/p&gt;
    &lt;/blockquote&gt;
  
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;고민의 굴레, 슬럼프&lt;/h2&gt;
&lt;p&gt;저는 작년 한 해 동안 많은 고민과 번뇌에 둘러싸여었습니다. 더 많이 공부하고 노력하는데 어찌 된 일인지 성장하고 있지 않다는 느낌은 점점 짙어져만 갔습니다. 제 능력이 부족한지 의심하기도 하고 환경을 탓하기도 했습니다. 핑계는 참 많았고 타협은 늘 이어졌습니다. 하지만 결국 나아지는 것은 없었습니다. 지금에서야 여유 갖고 돌아보니 오히려 당시엔 부정적인 생각에 점점 더 갇혔던 것 같습니다.&lt;/p&gt;
&lt;p&gt;개발자란 직업을 갖고 있는 한 공부는 계속 이어져야 하고 쉴 때도 손에서 노트북을 놓지 않았습니다. 끊임없이 공부해야 하는 직군이라 더 심적인 부담도 있었습니다. 제가 이렇게 방황하고 있는 와중에도 다른 유능하신 분들의 발자국과 비교하며 제 한계를 무의식중에 정해버린 적도 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_016_002.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;개발자가 되고 싶었던 꿈은 이뤘지만 하고 싶은 개발보다 해야 되는 개발을 하면서 회사 코드는 제 것이 아니라는 생각이 더 커졌습니다. 퇴근 후에는 제가 하고 싶은 공부를 하지만 막상 써볼 곳이 없으니 크게 진도가 나가지 않고 이것저것 들춰보다 끝나기 일쑤였습니다. 회사에서는 업무 처리하기도 바쁜데 다른 분들은 어찌 그렇게 러닝 커브도 좋으신지 더 자괴감이 들었습니다.&lt;/p&gt;
&lt;h2&gt;네가 오길 기다렸어&lt;/h2&gt;
&lt;p&gt;점점 현실로부터 도망치고 싶어지기 시작한 저는, 어쩌면 개발자가 적성에 맞지 않나라는 생각마저 들기 시작했습니다. 이대로는 안 되겠다 싶어 주저하다 친한 개발자분에게 고민을 털어놨습니다.
그때 그분은 구구절절 많은 대답 대신 &lt;a href=&quot;https://coupa.ng/bl0Era&quot; target=&quot;_blank&quot;&gt;&amp;#x3C;함께 자라기&gt;&lt;/a&gt; 책을 읽어보라고 권해줬습니다. 함께 자라기는 이미 제가 소장하고 있었지만, 아직 읽기 전이었습니다. 가지고 있던 책이라 그날부터 바로 읽기 시작해 단숨에 읽었습니다. 좋은 내용이 너무 많아 밑줄이 없는 쪽이 없을 정도였습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;이 책은 마치 저를 기다린 것 같았습니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&apos;스스로 변하고 싶지만 계속 실패하는 사람, 혹은 조직을 개선하기 위한 시도를 하다가 오히려 데어 본 사람, 하루하루가 답답한 사람들을 위해 이 책을 썼습니다.&apos;로 머리말을 시작하는데 가슴이 벅차올랐습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_016_047.jpg&quot; alt=&quot;책에 밑줄 치지 않은 곳이 없을 정도로, 즐겨찾기가 무의미할 정도로 모든 페이지가 주옥같은 책입니다&quot;&gt;&lt;/p&gt;
&lt;h2&gt;잘하기에서 자라기로&lt;/h2&gt;
&lt;p&gt;학교 교과 과정을 이수하며 배운 학습 방법은 대부분 개별적이고 순차적이며, 교과서와 교재에서 시험 범위가 정해져 있습니다. 이 시험이라는 도구를 통해 학생 성취도 평가를 진행합니다. 결국, 그 이야기는 정답이란 것이 늘 존재한다는 것이죠. 정답은 더 나아가 합격과 자격증이라는 목표로 이어지게 됩니다. 이러한 학습 방법은 &lt;em&gt;학교 학습&lt;/em&gt;이라고 칭하며 결과 중심적이고 수치에 치중된 방식입니다. 이와 반대되는 개념을 소개하는 것으로 책은 시작합니다. 바로 &lt;code&gt;야생 학습&lt;/code&gt;입니다.&lt;/p&gt;
&lt;p&gt;야생 학습은&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대부분 협력적이며&lt;/li&gt;
&lt;li&gt;대부분 비순차적이고&lt;/li&gt;
&lt;li&gt;대부분 자료에 한정이 없으며&lt;/li&gt;
&lt;li&gt;대부분 명확한 평가도 없고&lt;/li&gt;
&lt;li&gt;대부분 정답이 없으며&lt;/li&gt;
&lt;li&gt;대부분 목표가 불분명하고 바뀌기도 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;야생 학습이란 표현은 낯설지만 사실 제가 지금 하고 있는 개발 과정과 다르지 않았습니다. 하나의 요구사항을 끝냈다고 해서 그 기능은 그것으로 정답이고 불변하지 않으며 그 기능의 평가가 절대적이라고 보기 어렵습니다. 더 나은 비즈니스를 모색하며 새로운 목표를 짧은 기간 안에 정하고 그 목표를 실현하기 위해 다양한 기술 스택을 모색하기도 합니다. fail fast를 위해 우리는 새로운 기술의 도큐먼트를 목차대로 모두 정독한 뒤 개발을 시작하지 않습니다. 자바 API를 A to Z로 읽지 않는 것처럼 말이죠.&lt;/p&gt;
&lt;h2&gt;당신이 제자리 걸음인 이유&lt;/h2&gt;
&lt;p&gt;1만 시간의 법칙을 모두 한 번쯤은 들어보셨을 것입니다. 그럼 우리는 양치질과 세수를 평생 해왔으니 이 분야의 달인일까요? 우리는 양치질 전문가라고 할 수 있을까요? 좀 더 나아가 회사에서 하는 개발은 1만 시간 안에 해당까요? 시간이 흐름에 따라 매년 연차가 저절로 쌓이다 어느 날 10년 차의 경력자가 되었을 때 저는 전문가라고 말할 수 있을까요?&lt;/p&gt;
&lt;p&gt;어떠한 장치 없이 흐른 업무 시간은 1만 시간에 포함되지 않습니다. 저는 이 또한 제 노력의 시간에 포함된 것이라고 착각했고 저와 같은 분들도 계실 거로 생각합니다. 하루 8시간에 퇴근 후 추가로 하는 공부까지 했지만 성장하지 못한다는 느낌은 틀린 것이 아니었습니다. 하지만 회사 일을 하는 시간도 1만 시간에 포함할 수 있는 수련법이 있습니다.&lt;/p&gt;
&lt;p&gt;바로 &lt;code&gt;의도적 수련&lt;/code&gt;입니다. 악기 연주자에게 공연 시간은 이런 의도적 수련이 되지 못한다는 연구가 있습니다. 자신의 기량을 향상할 목적으로 반복해야 의도적 수련이 되는 것이죠.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_016_049.jpg&quot; alt=&quot;작업 난이도&quot;&gt;&lt;/p&gt;
&lt;p&gt;위 그림에서 A 영역의 일은 실력이 작업 난이도를 초과하는 지역으로 지금 당장은 쉽지만 조금만 지나면 지루함을 느끼게 됩니다.&lt;br&gt;
B 영역은 실력보다 작업 난이도가 더 높은 지역으로 불안함이나 두려움을 느끼게 됩니다.&lt;br&gt;
그럼 가운데 위치한 C 영역은 실력과 작업 난이도가 엇비슷한 부분으로 미하이&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;는 이 부분에서 인간이 몰입을 경험한다고 말합니다. 교육학에서는 학습 시 불필요하게 인지적인 부담을 주면 어떤 것도 제대로 학습하기 어렵다는 말을 합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_016_042.jpg&quot;&gt;&lt;br&gt;
즉, &lt;strong&gt;의도적 수련을 위해서는 적절한 난이도가 필수 요건&lt;/strong&gt;입니다. 자신이 업무 시간 중에 불안함이나 지루함을 느끼는 때가 대부분이라면, 실력이 도무지 늘지 않는 환경에 있는 겁니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_016_048.jpg&quot; alt=&quot;작업 난이도&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;제자리걸음에서 벗어나는 방법은 난이도를 조절하며 몰입 영역의 안으로 이동하는 것입니다.&lt;/strong&gt; 평소 마우스를 많이 사용해 개발 했다면 이번에는 마우스를 사용하지 않고 키보드로만 개발 하거나, 디버거를 늘 쓰는 경우 디버거를 쓰지 않거나 하는 것이죠. 혹은 이번에 개발 해야 되는 내용이 쉽다고 느껴지면 시간 제약을 두는 것입니다. 10분 안에 동작할 수 있는 코드 만들기 또는 TDD를 사용하지 않았다면 TDD를 적용해 개발해보기 등으로 내게 스스로 미션을 주는 것입니다.&lt;/p&gt;
&lt;p&gt;저도 TDD에 관해서 공부는 했지만, 실무에서 막상 쓰기 어려웠습니다. 늘 비즈니스에서 쫓겨 TDD를 실천할 마음의 여유가 없었습니다. 그러다 며칠 전 매우 작은 컨버터를 하나 추가해야 했습니다. 사용자 이름이 긴 경우 일정 길이까지만 보여주고 나머지는 ...으로 줄임 표시를 하는 것이죠. 평소 같았으면 쉬운 내용이니 빨리 개발해놓고 여유를 부렸겠지만, 이번에는 TDD를 적용해보기 마음먹었습니다. 빨간 줄의 압박을 받으며 단계별로 코드를 작성하고 녹색 신호등을 보고, 다시 빨간 줄을 보고 녹색 신호등을 보며 재밌게 코딩했습니다. 막상 TDD를 실무에서 해보니 테스트 코드를 추후 작성해야 한다는 부담감도 없어졌고, 생각보다 지속적으로 도입해볼 만 하겠다는 용기도 생겼습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/5/54/HK_Star_Bruce_Lee_16.jpg&quot; alt=&quot;이소룡은 3분안에 상대를 제압한다는 셀프 미션을 가지고 훈련했습니다.&quot;&gt;&lt;/p&gt;
&lt;p&gt;실력보다 작업 난이도가 높은 경우가 찾아올 수도 있습니다. 이때는 혼자서 해결하기는 어려우므로 페어 프로그래밍을 하거나 다른 툴 사용을 도입하거나 과거 비슷한 일을 했던 경험을 복기하며 이미지 트레이닝을 하면 도움이 됩니다. 혹은 작업 난이도를 낮춰 시작하면서 점차 살을 붙여가는 것이죠.&lt;/p&gt;
&lt;h2&gt;의도적 수련&lt;/h2&gt;
&lt;p&gt;이런 의도적 수련을 좀 더 깊이 있게 다룬 글이 있어 소개하고 싶습니다. &lt;a href=&quot;https://www.popit.kr/si-%EA%B0%9C%EB%B0%9C-10%EB%85%84%EC%B0%A8%EC%9D%B8%EB%8D%B0-%EC%BD%94%EB%93%9C-%EC%A2%80-%EB%B4%90%EC%A3%BC%EC%84%B8%EC%9A%94/&quot; target=&quot;_blank&quot;&gt;SI 개발 10년 차인데 코드 좀 봐주세요&lt;/a&gt;란 기고입니다.&lt;/p&gt;
&lt;p&gt;본문 중 업무와 관련되지 않는 분야에 대해 별도의 시간을 투자하여 하는 공부는 깊이 있는 기술을 익히는데 한계가 있고 효율적이지 않기 때문에 권장하지 않는다고 합니다. 실무에서 얻은 지식과의 차이는 매우 크기 때문입니다. 현재 개발/운영 환경을 개선하며 견고하게 만들려는 미션을 스스로 제시하고 이 부분에 대해 깊이 파고들면 기능 하나를 만드는 것도 시간이 오래 걸리게 된다고 말합니다. 이렇게 부족한 시간은 원래 다른 기술 스택을 공부하려고 했던 시간을 이용해서 채울 수가 있고 실무에 적용해보며 계속 순환을 하도록 하는 것을 강조합니다.&lt;/p&gt;
&lt;p&gt;그럼 여기서부터 이제 회사 일과 나를 위한 학습의 경계가 모호해지게 되며 좀 더 몰입의 영역으로 다가갈 수 있게 됩니다. 이렇게 의도적 수련을 할 수 있는 것이라 소개합니다.&lt;/p&gt;
&lt;p&gt;초반에 제 고민을 설명했을 때 저는 효율적이지도 못하고 깊이 있게 들어가기 어려운 공부를 계속하며 정체되었다고 느낀다고 했습니다. 잘못된 수련을 하고 있었던 것이죠. 물론 새로운 것을 익히며 도입해볼 수 있겠지만, 기존 환경에 대해 깊게 관심을 갖지 않았다면 새로운 기술도 크게 빛을 바라기는 어렵습니다.&lt;/p&gt;
&lt;h2&gt;빠른 피드백&lt;/h2&gt;
&lt;p&gt;불확실한 환경에서 빠른 실행과 피드백을 요하는 애자일은 소프트웨어 개발 중 학습을 병목 요인 중 하나로 봅니다. 일반적인 프로젝트는 설계 단계의 피드백을 몇 달 후에 받게 됩니다. 애자일 프로젝트는 지금 내가 한 행동의 피드백을 하루 후, 일주일 후 등 여러 주기를 통해 지속적으로 얻을 수 있습니다. 직전에 저지른 실수는 바로 다음 주기에 교정할 수 있어 사이클을 빠르게 수정하며 운영할 수 있죠.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_016_044.jpg&quot; alt=&quot;쾌속 학습&quot;&gt;&lt;/p&gt;
&lt;p&gt;이상향의 프로그램을 한 번에 만들기보다는 지금 동작 가능한 작은 단위로 빠르게 피처를 만들어 나가며 계속 피드백을 받는 것이 중요합니다. 저는 전자의 방식을 채택했으며 마치 수영을 배우러 갔는데 풀장 밖에서 선생님이 수영하는 모습만 보고, 책에 쓰여있는 팔다리 움직이는 방법만 보고 있는 격이었습니다. 작게라도 만들어보는 것이 중요하며 새로운 기술을 마주할 때 무엇을 만들지를 정해놓고 빠르게 훑고 만들어 나가는 것이 중요합니다.&lt;/p&gt;
&lt;h2&gt;한계는 스스로 정해버리는 것&lt;/h2&gt;
&lt;p&gt;저는 잘못된 수련을 하면서 좌절감을 느끼며 제 한계를 낮추기도 했습니다. 깊고 어려운 영역의 일은 내가 할 수 있지 않다고 말이죠. 그러던 와중에 인프런의 한 통의 광고 메일이 제게 경종을 울렸습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_016_050.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;피터 드러커&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;는 사람은 스스로가 성취하고 획득할 수 있다고 생각하는 바에 따라 성장한다고 했습니다. 제가 정한 한계에 부딪혀 더 깊은 슬럼프로 빠지게 되고 결국 극복할 수 없게 되었을지도 모르겠습니다. 물론 아직 야생 학습과 의도적 수련을 십분 활용하진 못하지만 적어도 학교 학습과 실행 프레임에 가두는 수련은 하지 않고 있습니다. 그리고 무엇보다 할 수 있다는 자신감을 되찾았고 남들과 비교하지 않고 제 길을 걸어가리라 다짐했습니다.&lt;/p&gt;
&lt;p&gt;그동안은 트렌드를 쫓기에 바빴고 만들어지는 결과물이 없으니 피드백을 받을 일도 없었습니다. 그럴수록 회사 업무에서 더 멀어지고 싶다는 생각만 짙어지는 악순환이었습니다. 그래서 러닝 커브가 좋아지지 못했죠. 하루는 개발자 선배에게 여쭈었습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;어떻게 러닝 커브를 좋게 할 수 있을까요?&lt;br&gt;
단순히 튜토리얼에 있는 내용으로 프로그래밍했다고 해서 러닝 커브가 좋다고 하지는 않잖아요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;선배 역시 단 한 단어로 답했습니다. 바로 &lt;code&gt;관심&lt;/code&gt;입니다. 관심의 차이가 좋은 러닝 커브를 만든다고 합니다. 관심이 없으면 더 나아갈 지식이나 원리를 알고 싶어 하지 않는다는 것이죠. 더 좋은 성능이나 더 빠른 적용을 위해 어떻게 하면 될지 고민하는 것은 관심 없이는 어렵다는 것입니다. 이 이야기는 앞서 의도적 수련에서 언급한 맥락과 이어진다는 것을 알아차릴 수 있죠.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_016_041.jpg&quot; alt=&quot;인공지능으로 대체 가능한 위험군에 속하는 컴퓨터 프로그래머&quot;&gt;&lt;br&gt;
다른 사람이 준 스펙대로 개발하는 것을 주 업무로 하는 컴퓨터 프로그래머가 있습니다. 협상과 설득이 크게 필요치 않죠. 반대로 소프트웨어를 뭘 만들지 고민하고 설계하는 부분이 포함되며, 과정에서 타인과 상호 작용하는 업무가 많은 소프트웨어 개발자가 있습니다. 개발자라는 같은 범주에 속하지만 일하는 과정은 다른 두 직업 중 컴퓨터 프로그래머는 인공지능으로 대체 가능한 위험군에 속합니다. 이런 위험에서 살아남기 위해서는 인공지능이 대체하기 어려운 암묵지와 직관을 잘 학습하는 사람들이 높은 경쟁력을 가질 것입니다. 이 지점에서 중요한 포인트 역시 관심이라고 생각합니다.&lt;/p&gt;
&lt;h2&gt;강력 추천&lt;/h2&gt;
&lt;p&gt;돌이켜보니 작년은 슬럼프였습니다. 성장이 정체되고 잘못된 방법으로 수련했으니 나아지기 어려웠습니다. &lt;a href=&quot;https://coupa.ng/bl0Era&quot; target=&quot;_blank&quot;&gt;&amp;#x3C;함께 자라기&gt;&lt;/a&gt; 를 통해 저를 돌아볼 수 있었고 슬럼프에서 벗어날 수 있었습니다. 저와 같은 고민을 하고 계신 분이라면 &lt;a href=&quot;https://coupa.ng/bl0Era&quot; target=&quot;_blank&quot;&gt;&amp;#x3C;함께 자라기&gt;&lt;/a&gt; 일독을 추천합니다. 이 리뷰 글에서는 주로 야생 학습과 의도적 수련에 관한 이야기를 중점으로 다뤘으나 팀원들과 함께 성장하는 방법, 애자일 도입 방법에 관한 이야기도 있습니다.&lt;/p&gt;
&lt;p&gt;마지막으로 책은 읽을 책을 사는 것이 아니라 산 책중에 읽는 것이라고 합니다 :-)&lt;br&gt;
&lt;img src=&quot;https://baek.dev/assets/images/post/2020/2020_016_001.jpg&quot; alt=&quot;Thanks to 숨비&quot;&gt;&lt;/p&gt;
&lt;h3&gt;참고 할만한 글&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.popit.kr/si-%EA%B0%9C%EB%B0%9C-10%EB%85%84%EC%B0%A8%EC%9D%B8%EB%8D%B0-%EC%BD%94%EB%93%9C-%EC%A2%80-%EB%B4%90%EC%A3%BC%EC%84%B8%EC%9A%94/&quot; target=&quot;_blank&quot;&gt;SI 개발 10년차인데 코드 좀 봐주세요&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.popit.kr/%ED%8F%89%EB%B2%94%ED%95%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EA%B7%B8-%EC%9D%B4%EC%83%81%EC%9D%B4-%EB%90%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EC%95%BC%EC%83%9D-%ED%95%99%EC%8A%B5-%EB%B9%84%EA%B2%B0/&quot; target=&quot;_blank&quot;&gt;평범한 개발자 그 이상이 되기 위한 야생 학습 비결&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;미하이. 미국의 저명한 심리학자로 몰입에 대한 연구로 유명합니다.&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-2&quot;&gt;
&lt;p&gt;피터 드러커. 미국의 경영학자. 현대 경영학을 창시한 학자로 평가받으며 경제적 제원을 잘 활용하고 관리하면 인간생활의 향상과 사회발전을 이룰 수 있다고 생각했습니다. 그는 이런 신념을 바탕으로 한 경영관리의 방법을 체계화시켜 현대 경영학을 확립하였습니다.&lt;/p&gt;
&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[찾기 힘든 버그를 유발하는 Java DTO 컨버팅 노가다, 리팩토링하기]]></title><description><![CDATA[<p>자바에서 DTO 컨버팅을 할 때 멤버 필드를 하나하나 명시해서 변환을 많이 하곤 합니다.<br>
이럴 경우 휴먼 에러가 발생 할 확률이 매우 높습니다. 같이 아래 예시를 볼까요?<br>
(본문 코드는 <a href="https://github.com/baekdev/modelmapper-ex" target="_blank">github</a>에서 확인 가능합니다.)</p>
<p>여기 BookDTO와 BookVO가 있습니다.<br>
DTO에서 VO로 혹은 반대로 VO에서 DTO로, 엔티티로 등등 다른 객체 타입으로 컨버팅을 하는 일은 실무에서 비일비재합니다.</p>
<!-- <script src="https://gist.github.com/baekdev/9d4844fdaa66393d8106893bf88c1a85.js"></script> -->
<pre><code class="language-java">public class BookDTO {
    private String title;
    private String author;
    private CurrencyType currencyType;
    private Date publishedAt;
    private Long price;
}

public class BookVO {
    private String title;
    private String author;
    private CurrencyType currencyType;
    private Date createAt;
    private Long price;
}
</code></pre>
<h2>휴먼 에러 예시</h2>
<h3>1. 필드를 잘못 매핑</h3>
<p>손가락이 가는대로 타이핑을 신명나게 하다보니 2번째 setAuthor에 getTitle로 set을 하고 말았습니다. 하지만 컴파일 에러가 없기 때문에 값 비교를 하지 않는 한 알기 어렵죠. 이런 케이스는 운영에 배포 후 버그나 장애로 발견되지 않는 한 개발 단계에서 사실 눈으로 확인하기 어렵습니다.</p>
<!-- <script src="https://gist.github.com/baekdev/5da43099aa3528cb6ea404d753de336b.js"></script> -->
<pre><code class="language-java">private BookVO convert(BookDTO bookDTO) {
    BookVO bookVO = new BookVO();
    bookVO.setTitle(bookDTO.getTitle());
    bookVO.setAuthor(bookDTO.getTitle()); // 다른 필드를 set 해줬지만 컴파일 에러가 없기 때문에 인지하기 어렵습니다.
    bookVO.setPrice(bookDTO.getPrice());
    bookVO.setCurrencyType(bookDTO.getCurrencyType());
    bookVO.setCreateAt(bookDTO.getPublishedAt());
    return bookVO;
}
</code></pre>
<p>Book 예제는 멤버 필드가 한눈에 들어오지만 대부분의 서비스에서는 수십개의 필드들이 줄을 서 있습니다. 비슷한 필드명이 많아 헷갈리기 쉽고, 필요한 모든 필드를 set 해줘야 하는 수고로움도 많습니다.</p>
<h3>2. 신규 필드 추가시 매핑 비용 추가</h3>
<p>이번엔 부제목이 필요하여 subTitle field를 신규 추가했습니다.</p>
<!-- <script src="https://gist.github.com/baekdev/e3c3168fc29acb98817857f82d452061.js"></script> -->
<pre><code class="language-java">public class BookDTO {
    private String title;
    private String subTitle;
    // (이하 생략)
}
public class BookVO {
    private String title;
    private String subTitle;
    // (이하 생략)
}
</code></pre>
<p>제가 이 코드 주인이기에 다행이도 convert() 메서드가 생각나서 신규 필드 매핑을 추가해줬습니다. 하지만 코드 주인도 신규 필드 매핑을 놓칠 수도 있고 새롭게 인수인계 받은 개발자도 이 컨버터를 놓칠 수 있어서 신규 필드 매핑 누락이 발생할 수 있는 여지가 충분히 있습니다.</p>
<!-- <script src="https://gist.github.com/baekdev/cdb00d92014719e1bac781511f563351.js"></script> -->
<pre><code class="language-java">private BookVO convert(BookDTO bookDTO) {
    BookVO bookVO = new BookVO();
    bookVO.setTitle(bookDTO.getTitle());
    bookVO.setAuthor(bookDTO.getAuthor());
    bookVO.setSubTitle(bookDTO.getSubTitle()); // 새로운 subTitle 매핑을 추가해줘야 합니다.
    bookVO.setPrice(bookDTO.getPrice());
    bookVO.setCurrencyType(bookDTO.getCurrencyType());
    bookVO.setCreateAt(bookDTO.getPublishedAt());
    return bookVO;
}
</code></pre>
<p>물론 TC를 잘 작성했다면 충분히 발견 가능합니다. 하지만 그 전에 좀 더 쉽고 빠르게 코드를 작성 할 수 있다면 불필요한 비용을 줄이고 리팩토링을 할 수 있는 포인트가 될 수 있습니다. 이와 같은 기능을 제공하는 라이브러리가 바로 <code>ModelMapper</code>입니다.</p>
<h2>ModelMapper</h2>
<blockquote>
<p>ModelMapper의 목표는 오브젝트 매핑을 쉽게 만드는 것이다.<br>
사람이 하는 것과 같이 규칙 기반으로 매핑방법을 자동으로 결정하는데,<br>
이는 특정 케이스 핸들링을 위한 리팩토링 안전 API를 제공함으로써 가능하다.<br>
<a href="http://modelmapper.org/" target="_blank">modelmapper.org</a></p>
</blockquote>
<h2>Dependency</h2>
<ul>
<li><a href="https://mvnrepository.com/artifact/org.modelmapper/modelmapper" target="_blank">model-mapper dependency</a></li>
<li>
<p>gradle</p>
<pre><code class="language-groovy">compile group: 'org.modelmapper', name: 'modelmapper', version: '2.3.0'
</code></pre>
</li>
<li>
<p>maven</p>
<pre><code class="language-xml">&#x3C;dependency>
  &#x3C;groupId>org.modelmapper&#x3C;/groupId>
  &#x3C;artifactId>modelmapper&#x3C;/artifactId>
  &#x3C;version>2.3.0&#x3C;/version>
&#x3C;/dependency>
</code></pre>
</li>
</ul>
<p>필드 매핑을 한땀 한땀 손으로 해주었던 convert() 코드를 ModelMapper를 이용해 바꿔보겠습니다.</p>
<!-- <script src="https://gist.github.com/baekdev/ebabfbdca85e137f7c38317635026221.js"></script> -->
<pre><code class="language-java">@Test
public void test_use_model_mapper() {
    ModelMapper modelMapper = new ModelMapper();
    BookVO bookVO = modelMapper.map(bookDTO, BookVO.class);

    Assert.assertEquals(bookVO.getTitle(), bookDTO.getTitle());
    Assert.assertEquals(bookVO.getAuthor(), bookDTO.getAuthor());
    Assert.assertEquals(bookVO.getSubTitle(), bookDTO.getSubTitle());
    Assert.assertEquals(bookVO.getCurrencyType(), bookDTO.getCurrencyType());
}
</code></pre>
<p>검증 코드를 빼면 단 2줄 만에 오브젝트 매핑이 이뤄졌습니다.<br>
자 이번에는 BookDTO 및 BookVO는 필드명이 서로 같았지만 필드명이 서로 다르고, 사용자 정의 타입으로 선언된 필드들을 갖는 Order객체를 OrderDTO로 컨버팅 해보겠습니다.</p>
<!-- <script src="https://gist.github.com/baekdev/42cab7cedb24e2caf8642b32de364463.js"></script>
<script src="https://gist.github.com/baekdev/5b099ae3d7e18a22f06355d93d02f111.js"></script> -->
<pre><code class="language-java">public class Order {
    Customer customer;
    Address billingAddress;

    public static class Customer {
        Name name;
    }

    public static class Name {
        String firstName;
        String lastName;
    }

    public static class Address {
        String street;
        String city;
    }

}

public class OrderDTO {
    String customerFirstName;
    String customerLastName;
    String billingStreet;
    String billingCity;
}
</code></pre>
<pre><code class="language-java">@Test
public void test_convert_order_to_dto() {
    Order order = new Order()
        .setCustomer(new Order.Customer()
            .setName(new Order.Name()
            .setFirstName("DEV")
            .setLastName("BAEK")))
        .setBillingAddress(new Order.Address()
            .setCity("SEOUL")
            .setStreet("GAROSU-GIL"));

    ModelMapper modelMapper = new ModelMapper();
    OrderDTO orderDTO = modelMapper.map(order, OrderDTO.class);

    log.debug("order={}", order);
    log.debug("dto={}", orderDTO);

    Assert.assertEquals(order.getCustomer().getName().getFirstName(), orderDTO.getCustomerFirstName());
    Assert.assertEquals(order.getCustomer().getName().getLastName(), orderDTO.getCustomerLastName());
    Assert.assertEquals(order.getBillingAddress().getStreet(), orderDTO.getBillingStreet());
    Assert.assertEquals(order.getBillingAddress().getCity(), orderDTO.getBillingCity());
}
</code></pre>
<h2>Matching Strategy</h2>
<p>위와 같이 필드명이 정확히 일치하지 않아도 객체 필드명을 유추하여 지능적으로 맵핑해주는 전략은 <code>Standard Matching Strategy</code> 라고 합니다.
ModelMapper를 생성자로 생성하면 기본 STANDARD 전략이 셋팅됩니다. 맵핑 전략은 STANDARD 외에 LOOSE와 STRICT가 있습니다.</p>
<ul>
<li>
<p>STANDARD ( <em>default</em> )</p>
<ul>
<li>소스 속성을 대상 속성과 지능적으로 일치시킬 수 있음</li>
<li>모든 대상 속성이 일치하고, 모든 소스 속성 이름에 토큰이 하나 이상 일치해야 함</li>
<li>규칙</li>
<li>토큰은 어떤 순서 로도 일치시킬 수 있음</li>
<li>모든 대상 속성 이름 토큰이 일치해야 함</li>
<li>모든 소스 속성 이름에는 일치하는 토큰이 하나 이상 있어야 함</li>
</ul>
</li>
<li>
<p>LOOSE</p>
<ul>
<li>계층 구조의 마지막 대상 속성 만 일치하도록 하여 소스 속성을 대상 속성에 느슨하게 일치시킬 수 있음</li>
<li>규칙</li>
<li>토큰은 어떤 순서 로도 일치시킬 수 있음</li>
<li>마지막 대상 속성 이름은 모든 토큰이 일치해야 함</li>
<li>마지막 소스 특성 이름에는 일치하는 토큰이 하나 이상 있어야함</li>
</ul>
</li>
<li>
<p>STRICT</p>
<ul>
<li>소스 속성을 대상 속성과 엄격하게 일치</li>
<li>완벽한 일치 정확도를 허용하여 불일치 또는 모호성이 발생하지 않도록함</li>
<li>소스와 대상 측의 속성 이름 토큰이 서로 정확하게 일치해야 함</li>
<li>규칙</li>
<li>토큰은 엄격한 순서로 일치</li>
<li>모든 대상 속성 이름 토큰이 일치해야 함</li>
<li>모든 소스 속성 이름에는 모든 토큰이 일치해야 함</li>
</ul>
</li>
</ul>
<p>반드시 필드명이 일치해야만 매핑을 하고자 한다면 <code>STRICT</code> 전략을 선택해야 합니다.</p>
<h2>필드명이 다르지만 맵핑해야하는 경우</h2>
<p>DTO와 VO에서 Date 타입의 필드명(createdAt, publishedAt)이 서로 다릅니다.</p>
<!-- <script src="https://gist.github.com/baekdev/9d4844fdaa66393d8106893bf88c1a85.js"></script> -->
<pre><code class="language-java">public class BookDTO {
    private String title;
    private String author;
    private CurrencyType currencyType;
    private Date publishedAt;
    private Long price;
}

public class BookVO {
    private String title;
    private String author;
    private CurrencyType currencyType;
    private Date createAt;
    private Long price;
}
</code></pre>
<p>따라서 두 필드는 서로 매핑되지 않습니다. 토큰에 유사포인트가 하나도 없죠.</p>
<!-- <script src="https://gist.github.com/baekdev/1d7636c30be0e90ac6ec719878b83864.js"></script> -->
<pre><code class="language-java">@Test
public void test_not_mapping_createdAt_by_publishedAt() {
    ModelMapper modelMapper = new ModelMapper();
    BookVO bookVO = modelMapper.map(bookDTO, BookVO.class);
    Assert.assertNotEquals(bookVO.getCreateAt(), bookDTO.getPublishedAt());
}
</code></pre>
<p>저는 이 두개의 필드가 서로 매핑이 되면 좋겠습니다. 방법은 객체에 setter를 별로도 추가하거나 혹은 수기로 setter로 맵핑 작성해 해결 할 수 있습니다.
하지만 ModelMapper의 PropertyMap을 사용해서 매핑룰을 추가할 수 있습니다.</p>
<!-- <script src="https://gist.github.com/baekdev/1aad2d6fda3292fc22602f8179299c39.js"></script> -->
<pre><code class="language-java">@Test
public void test_add_mappings() {
    PropertyMap&#x3C;BookDTO, BookVO> bookMap = new PropertyMap&#x3C;BookDTO, BookVO>() {
        protected void configure() {
            map().setCreateAt(source.getPublishedAt());
        }
    };

    ModelMapper modelMapper = new ModelMapper();
    modelMapper.addMappings(bookMap);
    BookVO bookVO = modelMapper.map(bookDTO, BookVO.class);

    Assert.assertEquals(bookVO.getCreateAt(), bookDTO.getPublishedAt());
}
</code></pre>
<p>잘 매핑이 되는 군요! PropertyMap의 제너릭의 순서의 의미는 &#x3C;Source, Destination>인 점을 유의하면 됩니다.</p>
<h2>매핑이 잘 되었는지 확인</h2>
<p>만약 위에서 언급한 PropertyMap을 이용한 맵핑 룰을 추가하지 않았다면 createdAt과 publishedAt은 다른 값을 가지므로 매핑이 제대로 되지 않았다고 볼 수 있습니다.<br>
필요하다면 두 객체간 필드가 잘 매핑되었는지 검증도 해볼 수 있는데 ModelMapper#validation 을 이용하면 됩니다. 이 메서드는 검증에 실패한 경우 Exception을 throw하기 때문에 호출 부에서 이를 반드시 고려해야 합니다.</p>
<p>먼저 검증에 실패한 경우는 다음과 같은 에러를 확인 할 수 있습니다.</p>
<!-- <script src="https://gist.github.com/baekdev/16de8d0d1f13e96a56d77f0a903aa58c.js"></script> -->
<pre><code class="language-java">org.modelmapper.ValidationException: ModelMapper validation errors:
1) Unmapped destination properties found in TypeMap[BookDTO -> BookVO]:
    dev.baek.modelmapper.book.BookVO.setCreateAt()
1 error
    at org.modelmapper.internal.Errors.throwValidationExceptionIfErrorsExist(Errors.java:246)
    at org.modelmapper.ModelMapper.validate(ModelMapper.java:547)
</code></pre>
<p>맵핑 룰을 추가해서 검증을 다시 수행하면 에러없이 성공합니다.</p>
<!-- <script src="https://gist.github.com/baekdev/ec8bf6fab958424df24e23d561603b64.js"></script> -->
<pre><code class="language-java">@Test
public void test_validate() {
    ModelMapper modelMapper = new ModelMapper();

    PropertyMap&#x3C;BookDTO, BookVO> bookMap = new PropertyMap&#x3C;BookDTO, BookVO>() {
        protected void configure() {
            map().setCreateAt(source.getPublishedAt());
        }
    };
    modelMapper.addMappings(bookMap);

    modelMapper.map(bookDTO, BookVO.class);
    modelMapper.validate();
}
</code></pre>
<hr>
<p>자, 이렇게 간단히 ModelMapper 라이브러리를 살펴봤습니다.<br>
적용이 어렵지 않기 때문에 현재 소스상에서 get/set을 정성스레 작성하고 계셨다면 이 라이브러리 도입을 통해 코드 리팩토링을 해보시는 건 어떨까요?<br>
본문 코드는 <a href="https://github.com/baekdev/modelmapper-ex" target="_blank">github</a>에서 확인 가능하며, 공식 사이트는 <a href="http://modelmapper.org/" target="_blank">modelmapper.org</a> 입니다.</p>]]></description><link>https://baek.dev/post/15/</link><guid isPermaLink="false">https://baek.dev/post/15/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Fri, 03 Jan 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;자바에서 DTO 컨버팅을 할 때 멤버 필드를 하나하나 명시해서 변환을 많이 하곤 합니다.&lt;br&gt;
이럴 경우 휴먼 에러가 발생 할 확률이 매우 높습니다. 같이 아래 예시를 볼까요?&lt;br&gt;
(본문 코드는 &lt;a href=&quot;https://github.com/baekdev/modelmapper-ex&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;에서 확인 가능합니다.)&lt;/p&gt;
&lt;p&gt;여기 BookDTO와 BookVO가 있습니다.&lt;br&gt;
DTO에서 VO로 혹은 반대로 VO에서 DTO로, 엔티티로 등등 다른 객체 타입으로 컨버팅을 하는 일은 실무에서 비일비재합니다.&lt;/p&gt;
&lt;!-- &lt;script src=&quot;https://gist.github.com/baekdev/9d4844fdaa66393d8106893bf88c1a85.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class BookDTO {
    private String title;
    private String author;
    private CurrencyType currencyType;
    private Date publishedAt;
    private Long price;
}

public class BookVO {
    private String title;
    private String author;
    private CurrencyType currencyType;
    private Date createAt;
    private Long price;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;휴먼 에러 예시&lt;/h2&gt;
&lt;h3&gt;1. 필드를 잘못 매핑&lt;/h3&gt;
&lt;p&gt;손가락이 가는대로 타이핑을 신명나게 하다보니 2번째 setAuthor에 getTitle로 set을 하고 말았습니다. 하지만 컴파일 에러가 없기 때문에 값 비교를 하지 않는 한 알기 어렵죠. 이런 케이스는 운영에 배포 후 버그나 장애로 발견되지 않는 한 개발 단계에서 사실 눈으로 확인하기 어렵습니다.&lt;/p&gt;
&lt;!-- &lt;script src=&quot;https://gist.github.com/baekdev/5da43099aa3528cb6ea404d753de336b.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private BookVO convert(BookDTO bookDTO) {
    BookVO bookVO = new BookVO();
    bookVO.setTitle(bookDTO.getTitle());
    bookVO.setAuthor(bookDTO.getTitle()); // 다른 필드를 set 해줬지만 컴파일 에러가 없기 때문에 인지하기 어렵습니다.
    bookVO.setPrice(bookDTO.getPrice());
    bookVO.setCurrencyType(bookDTO.getCurrencyType());
    bookVO.setCreateAt(bookDTO.getPublishedAt());
    return bookVO;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Book 예제는 멤버 필드가 한눈에 들어오지만 대부분의 서비스에서는 수십개의 필드들이 줄을 서 있습니다. 비슷한 필드명이 많아 헷갈리기 쉽고, 필요한 모든 필드를 set 해줘야 하는 수고로움도 많습니다.&lt;/p&gt;
&lt;h3&gt;2. 신규 필드 추가시 매핑 비용 추가&lt;/h3&gt;
&lt;p&gt;이번엔 부제목이 필요하여 subTitle field를 신규 추가했습니다.&lt;/p&gt;
&lt;!-- &lt;script src=&quot;https://gist.github.com/baekdev/e3c3168fc29acb98817857f82d452061.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class BookDTO {
    private String title;
    private String subTitle;
    // (이하 생략)
}
public class BookVO {
    private String title;
    private String subTitle;
    // (이하 생략)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;제가 이 코드 주인이기에 다행이도 convert() 메서드가 생각나서 신규 필드 매핑을 추가해줬습니다. 하지만 코드 주인도 신규 필드 매핑을 놓칠 수도 있고 새롭게 인수인계 받은 개발자도 이 컨버터를 놓칠 수 있어서 신규 필드 매핑 누락이 발생할 수 있는 여지가 충분히 있습니다.&lt;/p&gt;
&lt;!-- &lt;script src=&quot;https://gist.github.com/baekdev/cdb00d92014719e1bac781511f563351.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private BookVO convert(BookDTO bookDTO) {
    BookVO bookVO = new BookVO();
    bookVO.setTitle(bookDTO.getTitle());
    bookVO.setAuthor(bookDTO.getAuthor());
    bookVO.setSubTitle(bookDTO.getSubTitle()); // 새로운 subTitle 매핑을 추가해줘야 합니다.
    bookVO.setPrice(bookDTO.getPrice());
    bookVO.setCurrencyType(bookDTO.getCurrencyType());
    bookVO.setCreateAt(bookDTO.getPublishedAt());
    return bookVO;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물론 TC를 잘 작성했다면 충분히 발견 가능합니다. 하지만 그 전에 좀 더 쉽고 빠르게 코드를 작성 할 수 있다면 불필요한 비용을 줄이고 리팩토링을 할 수 있는 포인트가 될 수 있습니다. 이와 같은 기능을 제공하는 라이브러리가 바로 &lt;code&gt;ModelMapper&lt;/code&gt;입니다.&lt;/p&gt;
&lt;h2&gt;ModelMapper&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;ModelMapper의 목표는 오브젝트 매핑을 쉽게 만드는 것이다.&lt;br&gt;
사람이 하는 것과 같이 규칙 기반으로 매핑방법을 자동으로 결정하는데,&lt;br&gt;
이는 특정 케이스 핸들링을 위한 리팩토링 안전 API를 제공함으로써 가능하다.&lt;br&gt;
&lt;a href=&quot;http://modelmapper.org/&quot; target=&quot;_blank&quot;&gt;modelmapper.org&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Dependency&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mvnrepository.com/artifact/org.modelmapper/modelmapper&quot; target=&quot;_blank&quot;&gt;model-mapper dependency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gradle&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-groovy&quot;&gt;compile group: &apos;org.modelmapper&apos;, name: &apos;modelmapper&apos;, version: &apos;2.3.0&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;maven&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;#x3C;dependency&gt;
  &amp;#x3C;groupId&gt;org.modelmapper&amp;#x3C;/groupId&gt;
  &amp;#x3C;artifactId&gt;modelmapper&amp;#x3C;/artifactId&gt;
  &amp;#x3C;version&gt;2.3.0&amp;#x3C;/version&gt;
&amp;#x3C;/dependency&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;필드 매핑을 한땀 한땀 손으로 해주었던 convert() 코드를 ModelMapper를 이용해 바꿔보겠습니다.&lt;/p&gt;
&lt;!-- &lt;script src=&quot;https://gist.github.com/baekdev/ebabfbdca85e137f7c38317635026221.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Test
public void test_use_model_mapper() {
    ModelMapper modelMapper = new ModelMapper();
    BookVO bookVO = modelMapper.map(bookDTO, BookVO.class);

    Assert.assertEquals(bookVO.getTitle(), bookDTO.getTitle());
    Assert.assertEquals(bookVO.getAuthor(), bookDTO.getAuthor());
    Assert.assertEquals(bookVO.getSubTitle(), bookDTO.getSubTitle());
    Assert.assertEquals(bookVO.getCurrencyType(), bookDTO.getCurrencyType());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;검증 코드를 빼면 단 2줄 만에 오브젝트 매핑이 이뤄졌습니다.&lt;br&gt;
자 이번에는 BookDTO 및 BookVO는 필드명이 서로 같았지만 필드명이 서로 다르고, 사용자 정의 타입으로 선언된 필드들을 갖는 Order객체를 OrderDTO로 컨버팅 해보겠습니다.&lt;/p&gt;
&lt;!-- &lt;script src=&quot;https://gist.github.com/baekdev/42cab7cedb24e2caf8642b32de364463.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://gist.github.com/baekdev/5b099ae3d7e18a22f06355d93d02f111.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Order {
    Customer customer;
    Address billingAddress;

    public static class Customer {
        Name name;
    }

    public static class Name {
        String firstName;
        String lastName;
    }

    public static class Address {
        String street;
        String city;
    }

}

public class OrderDTO {
    String customerFirstName;
    String customerLastName;
    String billingStreet;
    String billingCity;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Test
public void test_convert_order_to_dto() {
    Order order = new Order()
        .setCustomer(new Order.Customer()
            .setName(new Order.Name()
            .setFirstName(&quot;DEV&quot;)
            .setLastName(&quot;BAEK&quot;)))
        .setBillingAddress(new Order.Address()
            .setCity(&quot;SEOUL&quot;)
            .setStreet(&quot;GAROSU-GIL&quot;));

    ModelMapper modelMapper = new ModelMapper();
    OrderDTO orderDTO = modelMapper.map(order, OrderDTO.class);

    log.debug(&quot;order={}&quot;, order);
    log.debug(&quot;dto={}&quot;, orderDTO);

    Assert.assertEquals(order.getCustomer().getName().getFirstName(), orderDTO.getCustomerFirstName());
    Assert.assertEquals(order.getCustomer().getName().getLastName(), orderDTO.getCustomerLastName());
    Assert.assertEquals(order.getBillingAddress().getStreet(), orderDTO.getBillingStreet());
    Assert.assertEquals(order.getBillingAddress().getCity(), orderDTO.getBillingCity());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Matching Strategy&lt;/h2&gt;
&lt;p&gt;위와 같이 필드명이 정확히 일치하지 않아도 객체 필드명을 유추하여 지능적으로 맵핑해주는 전략은 &lt;code&gt;Standard Matching Strategy&lt;/code&gt; 라고 합니다.
ModelMapper를 생성자로 생성하면 기본 STANDARD 전략이 셋팅됩니다. 맵핑 전략은 STANDARD 외에 LOOSE와 STRICT가 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;STANDARD ( &lt;em&gt;default&lt;/em&gt; )&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;소스 속성을 대상 속성과 지능적으로 일치시킬 수 있음&lt;/li&gt;
&lt;li&gt;모든 대상 속성이 일치하고, 모든 소스 속성 이름에 토큰이 하나 이상 일치해야 함&lt;/li&gt;
&lt;li&gt;규칙&lt;/li&gt;
&lt;li&gt;토큰은 어떤 순서 로도 일치시킬 수 있음&lt;/li&gt;
&lt;li&gt;모든 대상 속성 이름 토큰이 일치해야 함&lt;/li&gt;
&lt;li&gt;모든 소스 속성 이름에는 일치하는 토큰이 하나 이상 있어야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LOOSE&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;계층 구조의 마지막 대상 속성 만 일치하도록 하여 소스 속성을 대상 속성에 느슨하게 일치시킬 수 있음&lt;/li&gt;
&lt;li&gt;규칙&lt;/li&gt;
&lt;li&gt;토큰은 어떤 순서 로도 일치시킬 수 있음&lt;/li&gt;
&lt;li&gt;마지막 대상 속성 이름은 모든 토큰이 일치해야 함&lt;/li&gt;
&lt;li&gt;마지막 소스 특성 이름에는 일치하는 토큰이 하나 이상 있어야함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STRICT&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;소스 속성을 대상 속성과 엄격하게 일치&lt;/li&gt;
&lt;li&gt;완벽한 일치 정확도를 허용하여 불일치 또는 모호성이 발생하지 않도록함&lt;/li&gt;
&lt;li&gt;소스와 대상 측의 속성 이름 토큰이 서로 정확하게 일치해야 함&lt;/li&gt;
&lt;li&gt;규칙&lt;/li&gt;
&lt;li&gt;토큰은 엄격한 순서로 일치&lt;/li&gt;
&lt;li&gt;모든 대상 속성 이름 토큰이 일치해야 함&lt;/li&gt;
&lt;li&gt;모든 소스 속성 이름에는 모든 토큰이 일치해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;반드시 필드명이 일치해야만 매핑을 하고자 한다면 &lt;code&gt;STRICT&lt;/code&gt; 전략을 선택해야 합니다.&lt;/p&gt;
&lt;h2&gt;필드명이 다르지만 맵핑해야하는 경우&lt;/h2&gt;
&lt;p&gt;DTO와 VO에서 Date 타입의 필드명(createdAt, publishedAt)이 서로 다릅니다.&lt;/p&gt;
&lt;!-- &lt;script src=&quot;https://gist.github.com/baekdev/9d4844fdaa66393d8106893bf88c1a85.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class BookDTO {
    private String title;
    private String author;
    private CurrencyType currencyType;
    private Date publishedAt;
    private Long price;
}

public class BookVO {
    private String title;
    private String author;
    private CurrencyType currencyType;
    private Date createAt;
    private Long price;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;따라서 두 필드는 서로 매핑되지 않습니다. 토큰에 유사포인트가 하나도 없죠.&lt;/p&gt;
&lt;!-- &lt;script src=&quot;https://gist.github.com/baekdev/1d7636c30be0e90ac6ec719878b83864.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Test
public void test_not_mapping_createdAt_by_publishedAt() {
    ModelMapper modelMapper = new ModelMapper();
    BookVO bookVO = modelMapper.map(bookDTO, BookVO.class);
    Assert.assertNotEquals(bookVO.getCreateAt(), bookDTO.getPublishedAt());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;저는 이 두개의 필드가 서로 매핑이 되면 좋겠습니다. 방법은 객체에 setter를 별로도 추가하거나 혹은 수기로 setter로 맵핑 작성해 해결 할 수 있습니다.
하지만 ModelMapper의 PropertyMap을 사용해서 매핑룰을 추가할 수 있습니다.&lt;/p&gt;
&lt;!-- &lt;script src=&quot;https://gist.github.com/baekdev/1aad2d6fda3292fc22602f8179299c39.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Test
public void test_add_mappings() {
    PropertyMap&amp;#x3C;BookDTO, BookVO&gt; bookMap = new PropertyMap&amp;#x3C;BookDTO, BookVO&gt;() {
        protected void configure() {
            map().setCreateAt(source.getPublishedAt());
        }
    };

    ModelMapper modelMapper = new ModelMapper();
    modelMapper.addMappings(bookMap);
    BookVO bookVO = modelMapper.map(bookDTO, BookVO.class);

    Assert.assertEquals(bookVO.getCreateAt(), bookDTO.getPublishedAt());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;잘 매핑이 되는 군요! PropertyMap의 제너릭의 순서의 의미는 &amp;#x3C;Source, Destination&gt;인 점을 유의하면 됩니다.&lt;/p&gt;
&lt;h2&gt;매핑이 잘 되었는지 확인&lt;/h2&gt;
&lt;p&gt;만약 위에서 언급한 PropertyMap을 이용한 맵핑 룰을 추가하지 않았다면 createdAt과 publishedAt은 다른 값을 가지므로 매핑이 제대로 되지 않았다고 볼 수 있습니다.&lt;br&gt;
필요하다면 두 객체간 필드가 잘 매핑되었는지 검증도 해볼 수 있는데 ModelMapper#validation 을 이용하면 됩니다. 이 메서드는 검증에 실패한 경우 Exception을 throw하기 때문에 호출 부에서 이를 반드시 고려해야 합니다.&lt;/p&gt;
&lt;p&gt;먼저 검증에 실패한 경우는 다음과 같은 에러를 확인 할 수 있습니다.&lt;/p&gt;
&lt;!-- &lt;script src=&quot;https://gist.github.com/baekdev/16de8d0d1f13e96a56d77f0a903aa58c.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;org.modelmapper.ValidationException: ModelMapper validation errors:
1) Unmapped destination properties found in TypeMap[BookDTO -&gt; BookVO]:
    dev.baek.modelmapper.book.BookVO.setCreateAt()
1 error
    at org.modelmapper.internal.Errors.throwValidationExceptionIfErrorsExist(Errors.java:246)
    at org.modelmapper.ModelMapper.validate(ModelMapper.java:547)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;맵핑 룰을 추가해서 검증을 다시 수행하면 에러없이 성공합니다.&lt;/p&gt;
&lt;!-- &lt;script src=&quot;https://gist.github.com/baekdev/ec8bf6fab958424df24e23d561603b64.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Test
public void test_validate() {
    ModelMapper modelMapper = new ModelMapper();

    PropertyMap&amp;#x3C;BookDTO, BookVO&gt; bookMap = new PropertyMap&amp;#x3C;BookDTO, BookVO&gt;() {
        protected void configure() {
            map().setCreateAt(source.getPublishedAt());
        }
    };
    modelMapper.addMappings(bookMap);

    modelMapper.map(bookDTO, BookVO.class);
    modelMapper.validate();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;자, 이렇게 간단히 ModelMapper 라이브러리를 살펴봤습니다.&lt;br&gt;
적용이 어렵지 않기 때문에 현재 소스상에서 get/set을 정성스레 작성하고 계셨다면 이 라이브러리 도입을 통해 코드 리팩토링을 해보시는 건 어떨까요?&lt;br&gt;
본문 코드는 &lt;a href=&quot;https://github.com/baekdev/modelmapper-ex&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;에서 확인 가능하며, 공식 사이트는 &lt;a href=&quot;http://modelmapper.org/&quot; target=&quot;_blank&quot;&gt;modelmapper.org&lt;/a&gt; 입니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[2019년 회고 - 처음 쓰는 한해 마무리 회고]]></title><description><![CDATA[<p>import ExternalLink from 'components/ExternalLink';</p>
<p>2~3년 전부터 작성하고 싶었던 <strong>한해 마무리 회고</strong>를 드디어 처음으로 작성한다.<br>
매년 바쁘고 글감이 부족하단 이유로 흐지부지되었는데, 얼마 전 잠실 모각코<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 송년회 모임을 하면서 한해 회고를 가볍게 진행했다. 이때 작성한 회고를 좀 더 발전시켜 첫 회고 포스팅을 시작한다.</p>
<h2>블로그 개설</h2>
<p>먼저 4분기에 이 포스팅을 작성할 수 있는 블로그를 개설했다.<br>
이전에 사용하던 개발 블로그가 있었지만 바쁘단 핑계로 방치되고 무엇보다 포스팅들이 퀄리티가 좋지 않았다. 문제 해결을 위한 단편적인 답들이 나열되어 있고 튜토리얼을 따라 해본 글들이 전부였다. <strong>그 당시에는 어떤 주제로 글을 써야 할지 몰라 더 그랬던 것 같다.</strong> 막연히 에세이를 쓸 수도 없고 그렇다고 난이도 높은 기술 이야기를 쓰기도 어렵다. 때문에 글쓰기에 대한 부담이 매우 컸다.</p>
<p>물론 지금의 블로그도 양질의 글을 쓰고 있는 것은 아니지만, <strong>그래도 과거의 포스트 유형들은 지양하려고 많은 고심을 하고 있다.</strong><br>
요즘에는 일을 하거나 공부를 할 때 번뜩이는 <code>주제들을 모으고 있다.</code> 모인 주제들을 어떤 내용으로 써 내려가야 할지 구체화되지 않은 경우도 있는데, 일단 리스트업 해놓고 소주제를 계속 추가하다 보면 큰 틀이나 분량이 나오게 된다.</p>
<p><img src="https://baek.dev/assets/images/post/2019/2019_014_001.png" alt="노션으로 블로그 글감 모으기"></p>
<p>이 글감들은 <strong>같은 문제를 겪으며 고민하는 이들과 미래의 나에게 전할 수 있는 메시지</strong>가 되니 요즘 점점 재밌어진다. 야심 차게 도메인도 사고 독자가 컨텐츠에 더 집중할 수 있도록 테마를 조금씩 내게 맞게 고쳐가며 단장 중이다. 올해가 가기 전에 10개 글을 쓸 수 있을까 싶었는데, 그래도 벌써 이 글을 포함하면 14개나 작성했다. 블로그 오픈하고 더 바빠져서 중간에 텀이 좀 있었지만 그래도 평균 1~2주에 1개씩은 포스팅했으니 나름 선방했다.</p>
<h2>회사</h2>
<p>그동안 내게 숨겨져 있던 일복 유전이 드디어 올초부터 터졌다. 직장인이 된 이후 가장 바빴던 한해고, 야근도 많이 했다. 항상 일정은 빠듯한 ETA를 달고 오니 많이 아쉽다.</p>
<p>특히 연초에는 시스템이 많이 불안정했다. 현 회사 입사 이후부터 트래픽이 시간이 흐를 수록 증가폭이 매우 가파랐다. 시스템은 그정도 트래픽을 견딜 여력이 되지 않아 작년 말부터 신호를 보내다가, 결국 견디지 못하는 시스템을 안정화하기로 팀내 최우선 과제로 삼았다. 모든 서스테이닝과 우선순위가 낮은 과제는 홀딩하고 부하가 많이 걸리는 비즈니스 서버 분리에 집중했다. 시스템이 흔들리게된 과정에 대해 말할 기회가 있을지 모르겠지만 간략히 요약하면<br>
<strong>DB 성능 저하 -> 카프카 컨슘 처리 성능 저하 -> 트래픽이 떨어질 때까지 계속 리밸런싱 -> failover 처리로 과부하 -> 전체 시스템 여파</strong> 정도로 정리할 수 있겠다.<br>
내가 맡았던 프로젝트는 혼자 진행하게 되서 많이 불안하기도했고 일손이 부족해 과부하가 걸리기도했다. 1달이란 시간 안에 신규 시스템으로 유관 도메인 전환 완료까지 진행했어야 하니 숨가쁘게 달렸었다. 그래도 덕분에 많이 안정화된 시스템을 보고 있으면 뿌듯하기도 하지만 좀 더 예쁘게 만들지 못한 아쉬움이 있다.</p>
<h2>퀵퀵각코, 모각코 운영</h2>
<p>2년 전 평균 <strong>15명</strong>이 정원인 모각코를 각각 2개월, 3개월씩 2번 운영했었다.<br>
보통의 모각코가 기간 제약이 없이 운영되는 반면, 나는 <code>기간을 명시하고 구체화된 목표를 마련할 것을 강조</code>했다.</p>
<p>이 같은 형태의 모각코를 생각하게 된 것은 바로..!</p>
<p><img src="https://baek.dev/assets/images/post/2019/2019_014_002.png" alt="모각코 발표 중"><br>
<img src="https://baek.dev/assets/images/post/2019/2019_014_003.png" alt="모각코 발표 중"><br>
<img src="https://baek.dev/assets/images/post/2019/2019_014_004.png" alt="모각코 발표 중"><br>
<img src="https://baek.dev/assets/images/post/2019/2019_014_005.png" alt="모각코 발표 중"></p>
<p>위 사진은 내가 기간제 모각코를 해야 하는 이유를 설명했던 발표 자료 중 일부다.<br>
그렇다. 나는 혼자서 하지 않는 사람이기에 반강제로 프로젝트를 수밖에 없는 환경을 만들고자 시작했다.<br>
하지만 <strong>두루뭉술한 목표는 무엇보다 실패로 가는 지름길</strong>이기에 모각코에 참가하고자 한다면 구체화된 목표를 함께 제출해야 했다.</p>
<ul>
<li>나쁜 목표 예시) Vue.js 공부하기</li>
<li>
<p>구체화된 좋은 목표 예시) Vue.js를 이용하여 모각코 목표 및 회고 기록 SPA 만들기</p>
<ul>
<li>1개월차 목표</li>
<li>부트스트랩 3.0 템플릿 선택</li>
<li>간단하게 레이아웃 스케치</li>
<li>json 데이터로 조회화면 개발</li>
<li>firebase로 json 데이터 조회 개발</li>
<li>페이스북 로그인 연동</li>
<li>2개월차 목표</li>
<li>글 수정 기능 추가</li>
<li>페이스북 공유 기능 추가</li>
<li>유저별 기수 표시 추</li>
<li>가능하다면 추가 목표</li>
<li>장소 체크인 기능 추가</li>
<li>사진 첨부 기능 추가</li>
<li>댓글 기능 추가</li>
</ul>
</li>
</ul>
<p>이렇게 구체화된 목표를 마련하지 않으면 중간에 삽질을 해서 제한된 시간을 소모하고, 삼천포로 빠지거나 목표가 바뀌게 된다. 그래서 이런 목표 구체화를 가이드 했고, 14명에 대한 운영을 나 혼자서 진행했다. 목표한 기간 마지막에는 소규모 세미나도 열어 공유하는 시간도 가졌다. 이 모각코를 참여한 참가자들은 모두가 만족했고 다들 괄목할만한 목표 성취를 이뤄냈다.</p>
<p>네트워킹도 되고 공부도 되는 이 모각코는 2018년 1월을 끝으로 추억 속에 잠겼다. 일이 점차 바빠지고 다른 일들도 많다 보니 이렇게 타이트한 운영을 혼자서 하기는 쉽지 않았기 때문이다. 부담되어 다시 시작할 엄두가 나지 않았다. 그러다 다시 또 혼자서는 안 하는 내 자신을 발견하고 버전2 기간제 모각코를 시작했다. 바로 퀵퀵각코!</p>
<p><img src="https://baek.dev/assets/images/post/2019/2019_003.png" alt="퀵퀵각코"></p>
<ul>
<li>
<ExternalLink href="https://www.notion.so/baekdev/4-0a3e47e8583e4019b5215a1ec83d5a1a" target="_blank" text="단기속성 4주완성 퀵퀵각코 모집글" />
</li>
<li><a href="/post/3">퀵퀵각코를 통해 진행한 쿠버네티스 목표 회고록</a></li>
<li><a href="/post/10">퀵퀵각코 회고록</a></li>
</ul>
<p><code>퀵퀵각코 슬로건은 단기속성 4주완성</code>이다. 기간을 4주로 줄여서 <strong>호흡을 짧게 가져가고 성취감을 좀 더 빨리 느낄 수 있도록</strong> 앞당겼다. 더불어 운영 리소스는 최대한 줄여서 운영자인 나도 최대한 온전히 참여자로서 녹아들길 바랬다.<br>
생각보다 4주란 시간은 정말 짧았다. 기간이 짧아 아쉽기도 했지만 정말 퀵하게 한 사이클을 돌려보아 만족스럽고, 목표도 83%를 달성해서 나름 꽤 성취감이 있었다.</p>
<p>또한 이번 퀵퀵각코에서는 참가자들 전원에서 모각코 참여 회고록을 매주 작성하도록 했으며, <strong>회고를 작성하는 곳은 반드시 검색엔진에 검색이 되는 플랫폼</strong>이어야 한다고 가이드를 했다. 이것은 바로 앞서 소개한 커리어 스킬책의 영향을 받아 시작하게 되었는데, 블로그를 하는 사람에게는 글감을 주고 블로그를 하지 않는 사람에게는 블로그에 입문할 수 있도록 계기를 마련해주고 싶었다. 더불어 프로젝트를 진행하면서 겪는 <strong>시행착오를 포스팅하면 나와 같은 고민에 놓인 다른 개발자에게 해결책이 될 수도 있는 선순환 구조가 될 수 있기 때문</strong>에 플랫폼을 마련하고 게시하도록 했다.</p>
<p>올해는 드디어 수면 아래 있었던 모각코를 버전2로 다시 꺼내본 해였다. 내년에도 모각코를 할지는 모르겠으나 4주라는 기간은 너무 짧고, 8주 남짓인 <strong>2달이 가장 적당</strong>하며, 회고를 반드시 개인 플랫폼에 게시할 수 있도록 하는 것이 좋겠다는 결론이다.</p>
<h2>올해의 컨퍼런스</h2>
<p><img src="https://baek.dev/assets/images/post/2019/2019_011.jpg" alt="99콘"><br>
올해도 몇개의 행사를 다녀왔지만 그 중 최고는 이상한 모임의 99콘을 꼽고 싶다. 같은 분야의 더구나 같은 직군 개발자들의 생생한 경험담과 꿀팁들을 고스란이 전수 받을 수 있어서 정말 좋았다. 총 4회 중에 3회를 참석했고 참석했던 후기는 지난 포스트 링크를 첨부하겠다!</p>
<ul>
<li><a href="/post/2">99콘 이력서 후기 - 개발자 이력서 작성 방법</a></li>
<li><a href="/post/11">99콘 연봉협상 후기 - 개발자 연봉협상을 똑똑하게 하는 방법</a></li>
</ul>
<h2>올해의 책(들)</h2>
<p>좋은 책들이 많았지만 그 중 나를 변화시키고 많은 인사이트를 줬던 책을 소개하고 싶다.</p>
<ExternalLink href="http://www.yes24.com/Product/Goods/67350256?Acode=101" target="_blank" src="http://image.yes24.com/Goods/67350256/200x0" alt="함께 자라기" />
<p><strong>함께 자리기</strong><br>
함께 자라기는 애자일 컨설팅을 하시는 김창준님께서 <ExternalLink href="http://agile.egloos.com/" target="_blank" text="블로그" />에 작성하셨던 글들을 다듬어 출판한 책이다. 책은 진작 사놨었지만 읽지 않고 있다가 지인의 적극적인 추천으로 단숨에 읽은 책이다.<br>
올해 개발자로서 고민이 참 많았던 해인데 그런 고민들 대부분의 답이 이 책에 있었다. 특히 함께 자라기에 나온 <code>야생 학습</code>은 그간 갖고 있던 고정관념을 바꿔준 키워드로 칭하고 싶다. 조만간 책 리뷰를 작성해야겠다.</p>
<ul>
<li><a href="/post/16">털어놓기 어려웠던 개발자로서 고민을 해결해준 책, 함께 자라기</a></li>
</ul>
<ExternalLink href="http://www.yes24.com/Product/Goods/71829578?Acode=101" target="_blank" alt="커리어 스킬" src="http://image.yes24.com/Goods/71829578/200x0" />
<p><strong>커리어 스킬</strong><br>
이 책 역시 많이 회자되는 책 중 하나일 것인데, 나는 이 책을 통해 블로깅을 다시 할 원동력을 얻은 책이다. 외국 개발자가 작성한 책이라 중간중간 한국과 정서가 맞지 않지 부분이 몇 개 있지만 그럼에도 불구하고 읽어볼 만한 책이다. 나는 이 책을 순서대로 읽지 않고 내가 궁금했던 챕터들을 먼저 읽어 나가 궁금한 점부터 빠르게 채웠다.</p>
<ExternalLink href="http://www.yes24.com/Product/Goods/69406695?Acode=101" target="_blank" alt="아웃풋 트레이닝" src="http://image.yes24.com/Goods/69406695/200x0" />
<p><strong>아웃풋 트레이닝</strong><br>
지금 블로그 제목이기도 한 아웃풋 트레이닝은 눈과 귀로 듣기만 하는 100번의 인풋보다, 소리 내어 친구에게 말하거나 블로그로 정리하거나 혹은 다른 사람 앞에서 발표하는 1번의 아웃풋이 더 내 것이 된다고 강조하는 책이다. 이 책 역시 블로깅을 하도록 결심하게 된 책 중 하나인데 그동안 나는 인풋이 많았지만 성장한다는 느낌이 적었다. 그것을 깨닫게 된 책이기도 한데 이 책은 가볍게 한 번 읽어봄직한 책이다.</p>
<h2>올해의 앱</h2>
<p><img src="https://www.notion.so/front/product/use-case-screenshot-task.png" alt="Notion"></p>
<p>바로 <code>노션</code>이다! 노션을 1년 정도 써오면서 중간에 나랑 맞지 않는다고 생각해 결제를 후회한 적도 있었다. 처음 접했을 때는 신세계였고, 수많은 공개된 템플릿도 매력적이었다. 허나 많이 써보려 시도 했지만 보이지 않는 허들이 느껴졌다. 결제한 돈이 아까워서라도 남은 기간만이라도 써보자는 심정으로 꾸준히 써보면서 여러 시도를 했고, 그결과 요즘에는 내 최애 앱이 되었다. 1년간 써본 노션은 <strong>러닝 커브</strong>가 있다고 말하고 싶다. 개인형 다이어리를 넘어선 위키 시스템이라고 볼 수 있는데 요즘은 모든 메모와 북마크, 데이터 정리를 노션으로 하고 있다. 역시 조만간 노션 1년 사용기를 포스팅할 예정이다.</p>
<h2>올해의 디바이스</h2>
<p><img src="https://baek.dev/assets/images/post/2019/2019_014_010.jpg" alt="iPad Pro3"></p>
<p>아이패드 에어2부터 태블릿을 써왔는데 주로 영상을 보는 위주였다. 이후 아이패드 프로 3세대를 구입하면서 태블릿을 사용하는 패턴이 많이 바뀌었다.</p>
<p>먼저 <strong>종이책 대신 전자책 비중이 많이 늘었다.</strong> 그 전에는 종이책에 대한 확고한 취향이 있었으나 점점 보유하는 책 수가 많아지고 두꺼워지는 IT 서적은 물리적으로 많은 부담이 되었다. 전자책이 나오는 책들은 대부분 이북을 구입하지만 기술 서적은 또 아쉽게도 전자책 출판이 별로 없다. 그래서 이를 극복하고자 개인적으로 전자책을 만들고, 아이패드에 넣어 보고 있다. 사용하고 있는 어플이 아이폰용도 있어서 아이폰/아이패드 스위칭해서 전자책을 보고 있다.</p>
<p><img src="https://baek.dev/assets/images/post/2019/2019_014_011.jpg" alt="iPad Pro3"></p>
<p>두번째로 펜슬이 지원되는 모델이다보니 손으로 메모하는 종이 노트 사용이 대체 되었다. 종이 노트에 사용하면 메모 수정이 쉽지 않고 중구난방이 되어 매번 다시 한 번 정리하는 수고로움이 따른다. 현재 메모앱으로 굿노트를 사용하고 있는데 목적별로 노트 생성할 수 있으니 별도 정리하는 수고로움은 덜었고, 웹에 저장하여 분실 위험도 적고 모든 디바이스에 동기화가 되니 접근성의 편리함도 있다. 또한 <strong>전자 장치를 사용 하지만 손으로 메모를 하는 장점</strong>은 유지된다! 그래서 회의에서도 아이패드를 꾸준히 들고 다녀 메모한다.</p>
<p>그리고 맥북을 15인치를 사용하고 있어서 외부에 들고다닐 때는 무게 부담이 꽤 된다. 그래서 세미나를 갈 때는 아이패드를 간단하게 들고가면 되니 너무 쾌적해졌다.</p>
<p>마지막으로 사진이나 영상 시청의 퀄리티가 달라졌다. 베젤이 최소화된 유일한 애플 태플릿 모델로 디스플레이도 심도 있어지고 사운드도 더 공간감이 있어졌다. 때문에 같은 영상을 보더라도 아이패드로 보면 좀 더 몰입해서 볼 수 있어서 요즘엔 넷플릭스로 액션영화 보는 재미가 쏠쏠하다!</p>
<h2>호캉스</h2>
<p>호캉스란 호텔(hotel)과 바캉스(vacance)을 합친 말로, 호텔에서 휴가를 보내는 것을 말한다.<br>
다음은 김영하 작가님 책 "여행의 이유"에 나오는 호캉스 설명이다.</p>
<blockquote>
<p><img src="https://baek.dev/assets/images/post/2019/2019_014_008.png" alt="알쓸신잡3 김영하 작가 ‘호캉스를 가는 이유’"><br>
작가들 중에 좋든 나쁘든 호텔 가서 글 쓰는 사람들 많아요.<br>
미국 베스트셀러 작가의 경우 싸구려 모텔을 빌려 작품을 집필한다고 해요. 그래야 써진다는 거예요.</p>
<p>왜 그럴까 생각해보면 호텔에는 우리 일상의 근심이 없어요.</p>
<p>집에서는 가만있다가 세탁기만 봐도 저거 돌려야 하나 이런 생각도 들고<br>
설거지를 해야 하나? 렌지를 닦아야 하나? 집에선 여러 가지 근심들이 있어요.</p>
<p>또 하나는 어떤 작가의 에세이에서 본 건데, '우리가 오래 살아온 공간에는 상처가 있다.'<br>
집에는 좋은 것만 있지 않아요. 오래 살아왔기 때문에.</p>
<p>호텔에 들어가는 순간 잘 정돈되어 있고 깔끔하고, 거기서는 그거 자기에게만 집중하면 되는 공간이죠.</p>
<p>그래서 '훌쩍 떠나고 싶다.' 그렇게만 생각한다면 굳이 먼 나라로 갈 필요가 없는 거예요.<br>
오직 일상의 상처와 기억을 피하기 위해서라면 시내 호텔도 괜찮아요.</p>
</blockquote>
<p>여행 목적이 아닌 오로지 휴식을 위한 호캉스를 처음 갔다. 특별한 목적 없이 단순히 쉬러 가는 호텔 여행이 무엇이 재밌을까 싶었는데, 돌이켜보면 그동안 여행에선 호텔 이외의 관광지를 여행하려다 보니 정작 좋은 호텔에서 잠만 자고 나오는 아쉬움이 많았다. <strong>쫓기는 마음 없이 적당히 휴식을 취하고 컨디션 리듬에 맞게 움직이고 싶다는 생각은 늘 여행마다 들었다.</strong></p>
<p>서울 시내 호텔에 체크인한 뒤 <strong>무엇인가 해야 한다는 쫓김에 긴강되지 않고</strong> 주변 맛집에서 편안하게 저녁을 먹고 커피를 마시며 룸에서는 세상 한량처럼 미드를 보고 잠을 잤다. 다음날 일어나 남이 차려준 조식을 먹고 유유자적 집으로 돌아왔다. 일과는 집에서 했던 것과 크게 다르지 않았지만 늘 항상 마주하고 있는 해야 할 일들로 부터 잠시 벗어나 한숨 돌리고 왔다. 다음 호캉스에는 일이나 프로젝트에 좀 더 집중하고 싶을 때 찾아가 보려 한다.</p>
<p><img src="https://baek.dev/assets/images/post/2019/2019_014_007.jpg" alt="호캉스"></p>
<h2>마무리</h2>
<p>처음 써보는 회고라 무엇을 써야 할지도 어떻게 써야 할지도 막막했는데 막상 쓰다보니 쓰고 싶은 항목이 계속 늘어났다. 이쯤에서 마무리하고 회고를 바탕으로 내년 목표를 세워 좀 더 체계적이고 알찬 2020년을 보낼 것이다!</p>
<div class="footnotes">
<hr>
<ol>
<li id="fn-1">
<p>잠실 모각코 : 매주 토요일 잠실에 모여 모각코를 하는 모임. 하지만 팀원들의 거주지 거리상 거의 강남에서 이뤄짐.</p>
<a href="#fnref-1" class="footnote-backref">↩</a>
</li>
</ol>
</div>]]></description><link>https://baek.dev/post/14/</link><guid isPermaLink="false">https://baek.dev/post/14/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Mon, 30 Dec 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;import ExternalLink from &apos;components/ExternalLink&apos;;&lt;/p&gt;
&lt;p&gt;2~3년 전부터 작성하고 싶었던 &lt;strong&gt;한해 마무리 회고&lt;/strong&gt;를 드디어 처음으로 작성한다.&lt;br&gt;
매년 바쁘고 글감이 부족하단 이유로 흐지부지되었는데, 얼마 전 잠실 모각코&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 송년회 모임을 하면서 한해 회고를 가볍게 진행했다. 이때 작성한 회고를 좀 더 발전시켜 첫 회고 포스팅을 시작한다.&lt;/p&gt;
&lt;h2&gt;블로그 개설&lt;/h2&gt;
&lt;p&gt;먼저 4분기에 이 포스팅을 작성할 수 있는 블로그를 개설했다.&lt;br&gt;
이전에 사용하던 개발 블로그가 있었지만 바쁘단 핑계로 방치되고 무엇보다 포스팅들이 퀄리티가 좋지 않았다. 문제 해결을 위한 단편적인 답들이 나열되어 있고 튜토리얼을 따라 해본 글들이 전부였다. &lt;strong&gt;그 당시에는 어떤 주제로 글을 써야 할지 몰라 더 그랬던 것 같다.&lt;/strong&gt; 막연히 에세이를 쓸 수도 없고 그렇다고 난이도 높은 기술 이야기를 쓰기도 어렵다. 때문에 글쓰기에 대한 부담이 매우 컸다.&lt;/p&gt;
&lt;p&gt;물론 지금의 블로그도 양질의 글을 쓰고 있는 것은 아니지만, &lt;strong&gt;그래도 과거의 포스트 유형들은 지양하려고 많은 고심을 하고 있다.&lt;/strong&gt;&lt;br&gt;
요즘에는 일을 하거나 공부를 할 때 번뜩이는 &lt;code&gt;주제들을 모으고 있다.&lt;/code&gt; 모인 주제들을 어떤 내용으로 써 내려가야 할지 구체화되지 않은 경우도 있는데, 일단 리스트업 해놓고 소주제를 계속 추가하다 보면 큰 틀이나 분량이 나오게 된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_014_001.png&quot; alt=&quot;노션으로 블로그 글감 모으기&quot;&gt;&lt;/p&gt;
&lt;p&gt;이 글감들은 &lt;strong&gt;같은 문제를 겪으며 고민하는 이들과 미래의 나에게 전할 수 있는 메시지&lt;/strong&gt;가 되니 요즘 점점 재밌어진다. 야심 차게 도메인도 사고 독자가 컨텐츠에 더 집중할 수 있도록 테마를 조금씩 내게 맞게 고쳐가며 단장 중이다. 올해가 가기 전에 10개 글을 쓸 수 있을까 싶었는데, 그래도 벌써 이 글을 포함하면 14개나 작성했다. 블로그 오픈하고 더 바빠져서 중간에 텀이 좀 있었지만 그래도 평균 1~2주에 1개씩은 포스팅했으니 나름 선방했다.&lt;/p&gt;
&lt;h2&gt;회사&lt;/h2&gt;
&lt;p&gt;그동안 내게 숨겨져 있던 일복 유전이 드디어 올초부터 터졌다. 직장인이 된 이후 가장 바빴던 한해고, 야근도 많이 했다. 항상 일정은 빠듯한 ETA를 달고 오니 많이 아쉽다.&lt;/p&gt;
&lt;p&gt;특히 연초에는 시스템이 많이 불안정했다. 현 회사 입사 이후부터 트래픽이 시간이 흐를 수록 증가폭이 매우 가파랐다. 시스템은 그정도 트래픽을 견딜 여력이 되지 않아 작년 말부터 신호를 보내다가, 결국 견디지 못하는 시스템을 안정화하기로 팀내 최우선 과제로 삼았다. 모든 서스테이닝과 우선순위가 낮은 과제는 홀딩하고 부하가 많이 걸리는 비즈니스 서버 분리에 집중했다. 시스템이 흔들리게된 과정에 대해 말할 기회가 있을지 모르겠지만 간략히 요약하면&lt;br&gt;
&lt;strong&gt;DB 성능 저하 -&gt; 카프카 컨슘 처리 성능 저하 -&gt; 트래픽이 떨어질 때까지 계속 리밸런싱 -&gt; failover 처리로 과부하 -&gt; 전체 시스템 여파&lt;/strong&gt; 정도로 정리할 수 있겠다.&lt;br&gt;
내가 맡았던 프로젝트는 혼자 진행하게 되서 많이 불안하기도했고 일손이 부족해 과부하가 걸리기도했다. 1달이란 시간 안에 신규 시스템으로 유관 도메인 전환 완료까지 진행했어야 하니 숨가쁘게 달렸었다. 그래도 덕분에 많이 안정화된 시스템을 보고 있으면 뿌듯하기도 하지만 좀 더 예쁘게 만들지 못한 아쉬움이 있다.&lt;/p&gt;
&lt;h2&gt;퀵퀵각코, 모각코 운영&lt;/h2&gt;
&lt;p&gt;2년 전 평균 &lt;strong&gt;15명&lt;/strong&gt;이 정원인 모각코를 각각 2개월, 3개월씩 2번 운영했었다.&lt;br&gt;
보통의 모각코가 기간 제약이 없이 운영되는 반면, 나는 &lt;code&gt;기간을 명시하고 구체화된 목표를 마련할 것을 강조&lt;/code&gt;했다.&lt;/p&gt;
&lt;p&gt;이 같은 형태의 모각코를 생각하게 된 것은 바로..!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_014_002.png&quot; alt=&quot;모각코 발표 중&quot;&gt;&lt;br&gt;
&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_014_003.png&quot; alt=&quot;모각코 발표 중&quot;&gt;&lt;br&gt;
&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_014_004.png&quot; alt=&quot;모각코 발표 중&quot;&gt;&lt;br&gt;
&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_014_005.png&quot; alt=&quot;모각코 발표 중&quot;&gt;&lt;/p&gt;
&lt;p&gt;위 사진은 내가 기간제 모각코를 해야 하는 이유를 설명했던 발표 자료 중 일부다.&lt;br&gt;
그렇다. 나는 혼자서 하지 않는 사람이기에 반강제로 프로젝트를 수밖에 없는 환경을 만들고자 시작했다.&lt;br&gt;
하지만 &lt;strong&gt;두루뭉술한 목표는 무엇보다 실패로 가는 지름길&lt;/strong&gt;이기에 모각코에 참가하고자 한다면 구체화된 목표를 함께 제출해야 했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;나쁜 목표 예시) Vue.js 공부하기&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구체화된 좋은 목표 예시) Vue.js를 이용하여 모각코 목표 및 회고 기록 SPA 만들기&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1개월차 목표&lt;/li&gt;
&lt;li&gt;부트스트랩 3.0 템플릿 선택&lt;/li&gt;
&lt;li&gt;간단하게 레이아웃 스케치&lt;/li&gt;
&lt;li&gt;json 데이터로 조회화면 개발&lt;/li&gt;
&lt;li&gt;firebase로 json 데이터 조회 개발&lt;/li&gt;
&lt;li&gt;페이스북 로그인 연동&lt;/li&gt;
&lt;li&gt;2개월차 목표&lt;/li&gt;
&lt;li&gt;글 수정 기능 추가&lt;/li&gt;
&lt;li&gt;페이스북 공유 기능 추가&lt;/li&gt;
&lt;li&gt;유저별 기수 표시 추&lt;/li&gt;
&lt;li&gt;가능하다면 추가 목표&lt;/li&gt;
&lt;li&gt;장소 체크인 기능 추가&lt;/li&gt;
&lt;li&gt;사진 첨부 기능 추가&lt;/li&gt;
&lt;li&gt;댓글 기능 추가&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이렇게 구체화된 목표를 마련하지 않으면 중간에 삽질을 해서 제한된 시간을 소모하고, 삼천포로 빠지거나 목표가 바뀌게 된다. 그래서 이런 목표 구체화를 가이드 했고, 14명에 대한 운영을 나 혼자서 진행했다. 목표한 기간 마지막에는 소규모 세미나도 열어 공유하는 시간도 가졌다. 이 모각코를 참여한 참가자들은 모두가 만족했고 다들 괄목할만한 목표 성취를 이뤄냈다.&lt;/p&gt;
&lt;p&gt;네트워킹도 되고 공부도 되는 이 모각코는 2018년 1월을 끝으로 추억 속에 잠겼다. 일이 점차 바빠지고 다른 일들도 많다 보니 이렇게 타이트한 운영을 혼자서 하기는 쉽지 않았기 때문이다. 부담되어 다시 시작할 엄두가 나지 않았다. 그러다 다시 또 혼자서는 안 하는 내 자신을 발견하고 버전2 기간제 모각코를 시작했다. 바로 퀵퀵각코!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_003.png&quot; alt=&quot;퀵퀵각코&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ExternalLink href=&quot;https://www.notion.so/baekdev/4-0a3e47e8583e4019b5215a1ec83d5a1a&quot; target=&quot;_blank&quot; text=&quot;단기속성 4주완성 퀵퀵각코 모집글&quot; /&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/3&quot;&gt;퀵퀵각코를 통해 진행한 쿠버네티스 목표 회고록&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/10&quot;&gt;퀵퀵각코 회고록&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;퀵퀵각코 슬로건은 단기속성 4주완성&lt;/code&gt;이다. 기간을 4주로 줄여서 &lt;strong&gt;호흡을 짧게 가져가고 성취감을 좀 더 빨리 느낄 수 있도록&lt;/strong&gt; 앞당겼다. 더불어 운영 리소스는 최대한 줄여서 운영자인 나도 최대한 온전히 참여자로서 녹아들길 바랬다.&lt;br&gt;
생각보다 4주란 시간은 정말 짧았다. 기간이 짧아 아쉽기도 했지만 정말 퀵하게 한 사이클을 돌려보아 만족스럽고, 목표도 83%를 달성해서 나름 꽤 성취감이 있었다.&lt;/p&gt;
&lt;p&gt;또한 이번 퀵퀵각코에서는 참가자들 전원에서 모각코 참여 회고록을 매주 작성하도록 했으며, &lt;strong&gt;회고를 작성하는 곳은 반드시 검색엔진에 검색이 되는 플랫폼&lt;/strong&gt;이어야 한다고 가이드를 했다. 이것은 바로 앞서 소개한 커리어 스킬책의 영향을 받아 시작하게 되었는데, 블로그를 하는 사람에게는 글감을 주고 블로그를 하지 않는 사람에게는 블로그에 입문할 수 있도록 계기를 마련해주고 싶었다. 더불어 프로젝트를 진행하면서 겪는 &lt;strong&gt;시행착오를 포스팅하면 나와 같은 고민에 놓인 다른 개발자에게 해결책이 될 수도 있는 선순환 구조가 될 수 있기 때문&lt;/strong&gt;에 플랫폼을 마련하고 게시하도록 했다.&lt;/p&gt;
&lt;p&gt;올해는 드디어 수면 아래 있었던 모각코를 버전2로 다시 꺼내본 해였다. 내년에도 모각코를 할지는 모르겠으나 4주라는 기간은 너무 짧고, 8주 남짓인 &lt;strong&gt;2달이 가장 적당&lt;/strong&gt;하며, 회고를 반드시 개인 플랫폼에 게시할 수 있도록 하는 것이 좋겠다는 결론이다.&lt;/p&gt;
&lt;h2&gt;올해의 컨퍼런스&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_011.jpg&quot; alt=&quot;99콘&quot;&gt;&lt;br&gt;
올해도 몇개의 행사를 다녀왔지만 그 중 최고는 이상한 모임의 99콘을 꼽고 싶다. 같은 분야의 더구나 같은 직군 개발자들의 생생한 경험담과 꿀팁들을 고스란이 전수 받을 수 있어서 정말 좋았다. 총 4회 중에 3회를 참석했고 참석했던 후기는 지난 포스트 링크를 첨부하겠다!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/post/2&quot;&gt;99콘 이력서 후기 - 개발자 이력서 작성 방법&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/11&quot;&gt;99콘 연봉협상 후기 - 개발자 연봉협상을 똑똑하게 하는 방법&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;올해의 책(들)&lt;/h2&gt;
&lt;p&gt;좋은 책들이 많았지만 그 중 나를 변화시키고 많은 인사이트를 줬던 책을 소개하고 싶다.&lt;/p&gt;
&lt;ExternalLink href=&quot;http://www.yes24.com/Product/Goods/67350256?Acode=101&quot; target=&quot;_blank&quot; src=&quot;http://image.yes24.com/Goods/67350256/200x0&quot; alt=&quot;함께 자라기&quot; /&gt;
&lt;p&gt;&lt;strong&gt;함께 자리기&lt;/strong&gt;&lt;br&gt;
함께 자라기는 애자일 컨설팅을 하시는 김창준님께서 &lt;ExternalLink href=&quot;http://agile.egloos.com/&quot; target=&quot;_blank&quot; text=&quot;블로그&quot; /&gt;에 작성하셨던 글들을 다듬어 출판한 책이다. 책은 진작 사놨었지만 읽지 않고 있다가 지인의 적극적인 추천으로 단숨에 읽은 책이다.&lt;br&gt;
올해 개발자로서 고민이 참 많았던 해인데 그런 고민들 대부분의 답이 이 책에 있었다. 특히 함께 자라기에 나온 &lt;code&gt;야생 학습&lt;/code&gt;은 그간 갖고 있던 고정관념을 바꿔준 키워드로 칭하고 싶다. 조만간 책 리뷰를 작성해야겠다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/post/16&quot;&gt;털어놓기 어려웠던 개발자로서 고민을 해결해준 책, 함께 자라기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ExternalLink href=&quot;http://www.yes24.com/Product/Goods/71829578?Acode=101&quot; target=&quot;_blank&quot; alt=&quot;커리어 스킬&quot; src=&quot;http://image.yes24.com/Goods/71829578/200x0&quot; /&gt;
&lt;p&gt;&lt;strong&gt;커리어 스킬&lt;/strong&gt;&lt;br&gt;
이 책 역시 많이 회자되는 책 중 하나일 것인데, 나는 이 책을 통해 블로깅을 다시 할 원동력을 얻은 책이다. 외국 개발자가 작성한 책이라 중간중간 한국과 정서가 맞지 않지 부분이 몇 개 있지만 그럼에도 불구하고 읽어볼 만한 책이다. 나는 이 책을 순서대로 읽지 않고 내가 궁금했던 챕터들을 먼저 읽어 나가 궁금한 점부터 빠르게 채웠다.&lt;/p&gt;
&lt;ExternalLink href=&quot;http://www.yes24.com/Product/Goods/69406695?Acode=101&quot; target=&quot;_blank&quot; alt=&quot;아웃풋 트레이닝&quot; src=&quot;http://image.yes24.com/Goods/69406695/200x0&quot; /&gt;
&lt;p&gt;&lt;strong&gt;아웃풋 트레이닝&lt;/strong&gt;&lt;br&gt;
지금 블로그 제목이기도 한 아웃풋 트레이닝은 눈과 귀로 듣기만 하는 100번의 인풋보다, 소리 내어 친구에게 말하거나 블로그로 정리하거나 혹은 다른 사람 앞에서 발표하는 1번의 아웃풋이 더 내 것이 된다고 강조하는 책이다. 이 책 역시 블로깅을 하도록 결심하게 된 책 중 하나인데 그동안 나는 인풋이 많았지만 성장한다는 느낌이 적었다. 그것을 깨닫게 된 책이기도 한데 이 책은 가볍게 한 번 읽어봄직한 책이다.&lt;/p&gt;
&lt;h2&gt;올해의 앱&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://www.notion.so/front/product/use-case-screenshot-task.png&quot; alt=&quot;Notion&quot;&gt;&lt;/p&gt;
&lt;p&gt;바로 &lt;code&gt;노션&lt;/code&gt;이다! 노션을 1년 정도 써오면서 중간에 나랑 맞지 않는다고 생각해 결제를 후회한 적도 있었다. 처음 접했을 때는 신세계였고, 수많은 공개된 템플릿도 매력적이었다. 허나 많이 써보려 시도 했지만 보이지 않는 허들이 느껴졌다. 결제한 돈이 아까워서라도 남은 기간만이라도 써보자는 심정으로 꾸준히 써보면서 여러 시도를 했고, 그결과 요즘에는 내 최애 앱이 되었다. 1년간 써본 노션은 &lt;strong&gt;러닝 커브&lt;/strong&gt;가 있다고 말하고 싶다. 개인형 다이어리를 넘어선 위키 시스템이라고 볼 수 있는데 요즘은 모든 메모와 북마크, 데이터 정리를 노션으로 하고 있다. 역시 조만간 노션 1년 사용기를 포스팅할 예정이다.&lt;/p&gt;
&lt;h2&gt;올해의 디바이스&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_014_010.jpg&quot; alt=&quot;iPad Pro3&quot;&gt;&lt;/p&gt;
&lt;p&gt;아이패드 에어2부터 태블릿을 써왔는데 주로 영상을 보는 위주였다. 이후 아이패드 프로 3세대를 구입하면서 태블릿을 사용하는 패턴이 많이 바뀌었다.&lt;/p&gt;
&lt;p&gt;먼저 &lt;strong&gt;종이책 대신 전자책 비중이 많이 늘었다.&lt;/strong&gt; 그 전에는 종이책에 대한 확고한 취향이 있었으나 점점 보유하는 책 수가 많아지고 두꺼워지는 IT 서적은 물리적으로 많은 부담이 되었다. 전자책이 나오는 책들은 대부분 이북을 구입하지만 기술 서적은 또 아쉽게도 전자책 출판이 별로 없다. 그래서 이를 극복하고자 개인적으로 전자책을 만들고, 아이패드에 넣어 보고 있다. 사용하고 있는 어플이 아이폰용도 있어서 아이폰/아이패드 스위칭해서 전자책을 보고 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_014_011.jpg&quot; alt=&quot;iPad Pro3&quot;&gt;&lt;/p&gt;
&lt;p&gt;두번째로 펜슬이 지원되는 모델이다보니 손으로 메모하는 종이 노트 사용이 대체 되었다. 종이 노트에 사용하면 메모 수정이 쉽지 않고 중구난방이 되어 매번 다시 한 번 정리하는 수고로움이 따른다. 현재 메모앱으로 굿노트를 사용하고 있는데 목적별로 노트 생성할 수 있으니 별도 정리하는 수고로움은 덜었고, 웹에 저장하여 분실 위험도 적고 모든 디바이스에 동기화가 되니 접근성의 편리함도 있다. 또한 &lt;strong&gt;전자 장치를 사용 하지만 손으로 메모를 하는 장점&lt;/strong&gt;은 유지된다! 그래서 회의에서도 아이패드를 꾸준히 들고 다녀 메모한다.&lt;/p&gt;
&lt;p&gt;그리고 맥북을 15인치를 사용하고 있어서 외부에 들고다닐 때는 무게 부담이 꽤 된다. 그래서 세미나를 갈 때는 아이패드를 간단하게 들고가면 되니 너무 쾌적해졌다.&lt;/p&gt;
&lt;p&gt;마지막으로 사진이나 영상 시청의 퀄리티가 달라졌다. 베젤이 최소화된 유일한 애플 태플릿 모델로 디스플레이도 심도 있어지고 사운드도 더 공간감이 있어졌다. 때문에 같은 영상을 보더라도 아이패드로 보면 좀 더 몰입해서 볼 수 있어서 요즘엔 넷플릭스로 액션영화 보는 재미가 쏠쏠하다!&lt;/p&gt;
&lt;h2&gt;호캉스&lt;/h2&gt;
&lt;p&gt;호캉스란 호텔(hotel)과 바캉스(vacance)을 합친 말로, 호텔에서 휴가를 보내는 것을 말한다.&lt;br&gt;
다음은 김영하 작가님 책 &quot;여행의 이유&quot;에 나오는 호캉스 설명이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_014_008.png&quot; alt=&quot;알쓸신잡3 김영하 작가 ‘호캉스를 가는 이유’&quot;&gt;&lt;br&gt;
작가들 중에 좋든 나쁘든 호텔 가서 글 쓰는 사람들 많아요.&lt;br&gt;
미국 베스트셀러 작가의 경우 싸구려 모텔을 빌려 작품을 집필한다고 해요. 그래야 써진다는 거예요.&lt;/p&gt;
&lt;p&gt;왜 그럴까 생각해보면 호텔에는 우리 일상의 근심이 없어요.&lt;/p&gt;
&lt;p&gt;집에서는 가만있다가 세탁기만 봐도 저거 돌려야 하나 이런 생각도 들고&lt;br&gt;
설거지를 해야 하나? 렌지를 닦아야 하나? 집에선 여러 가지 근심들이 있어요.&lt;/p&gt;
&lt;p&gt;또 하나는 어떤 작가의 에세이에서 본 건데, &apos;우리가 오래 살아온 공간에는 상처가 있다.&apos;&lt;br&gt;
집에는 좋은 것만 있지 않아요. 오래 살아왔기 때문에.&lt;/p&gt;
&lt;p&gt;호텔에 들어가는 순간 잘 정돈되어 있고 깔끔하고, 거기서는 그거 자기에게만 집중하면 되는 공간이죠.&lt;/p&gt;
&lt;p&gt;그래서 &apos;훌쩍 떠나고 싶다.&apos; 그렇게만 생각한다면 굳이 먼 나라로 갈 필요가 없는 거예요.&lt;br&gt;
오직 일상의 상처와 기억을 피하기 위해서라면 시내 호텔도 괜찮아요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여행 목적이 아닌 오로지 휴식을 위한 호캉스를 처음 갔다. 특별한 목적 없이 단순히 쉬러 가는 호텔 여행이 무엇이 재밌을까 싶었는데, 돌이켜보면 그동안 여행에선 호텔 이외의 관광지를 여행하려다 보니 정작 좋은 호텔에서 잠만 자고 나오는 아쉬움이 많았다. &lt;strong&gt;쫓기는 마음 없이 적당히 휴식을 취하고 컨디션 리듬에 맞게 움직이고 싶다는 생각은 늘 여행마다 들었다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;서울 시내 호텔에 체크인한 뒤 &lt;strong&gt;무엇인가 해야 한다는 쫓김에 긴강되지 않고&lt;/strong&gt; 주변 맛집에서 편안하게 저녁을 먹고 커피를 마시며 룸에서는 세상 한량처럼 미드를 보고 잠을 잤다. 다음날 일어나 남이 차려준 조식을 먹고 유유자적 집으로 돌아왔다. 일과는 집에서 했던 것과 크게 다르지 않았지만 늘 항상 마주하고 있는 해야 할 일들로 부터 잠시 벗어나 한숨 돌리고 왔다. 다음 호캉스에는 일이나 프로젝트에 좀 더 집중하고 싶을 때 찾아가 보려 한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_014_007.jpg&quot; alt=&quot;호캉스&quot;&gt;&lt;/p&gt;
&lt;h2&gt;마무리&lt;/h2&gt;
&lt;p&gt;처음 써보는 회고라 무엇을 써야 할지도 어떻게 써야 할지도 막막했는데 막상 쓰다보니 쓰고 싶은 항목이 계속 늘어났다. 이쯤에서 마무리하고 회고를 바탕으로 내년 목표를 세워 좀 더 체계적이고 알찬 2020년을 보낼 것이다!&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;잠실 모각코 : 매주 토요일 잠실에 모여 모각코를 하는 모임. 하지만 팀원들의 거주지 거리상 거의 강남에서 이뤄짐.&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[마이크로서비스 아키텍처 구축(2) - 배포와 모니터링를 거쳐 대규모 마이크로서비스]]></title><description><![CDATA[<p>import ExternalLink from 'components/ExternalLink';</p>
<h2>6. 배포</h2>
<h3>지속적 통합(CI/Continuous Integration)</h3>
<ul>
<li>CI를 통한 핵심 목표는 모든 사람이 서로 동기를 맞추는 것</li>
<li>새롭게 체크인된 코드가 기존 코드와 적절히 통합됨을 보장함으로 달성할 수 있음</li>
<li>
<p>CI 서버는 아래에 대한 검증을 함</p>
<ul>
<li>코드의 커밋을 감지</li>
<li>체크아웃</li>
<li>코드의 컴파일과 테스트 통과를 확인</li>
</ul>
</li>
</ul>
<h4>CI 장점</h4>
<ul>
<li>코드 품질에 대해 어느 정도 바른 피드백을 얻을 수 있음</li>
<li>
<p>바이너리 산출물을 자동으로 생성</p>
<ul>
<li>산출물의 빌드를 위한 모든 코드는 버전 관리 되므로 필요할 때 언제든지 다시 만들 수 있음</li>
<li>배포된 산출물의 코드를 찾을 수 있는 정도로 추적할 수 있음</li>
<li>CI 도구 자체의 기능에 따라 코드와 산출물에 대해 어떤 테스트가 수행되었는지 확인 가능</li>
</ul>
</li>
</ul>
<h4>제즈 험블의 3가지 질문</h4>
<ul>
<li>
<p>Q. 하루에 한번 메인 브랜치에 체크인하는가?</p>
<ul>
<li>나의 코드는 물론 다른 사람들이 변경한 코드 또한 자주 확인하지 않는다면 향후의 통합이 더 어려워짐.</li>
<li>내 피처 개발을 위해 별도의 브랜치를 사용하고 있더라도 가능한 한 자주 메인 브랜치에 통합 해야 함</li>
</ul>
</li>
<li>
<p>Q. 변경을 확인할 테스트 집합이 있는가?</p>
<ul>
<li>테스트를 하지 않는다면 통합해서 작동하는지 구문상으로만 알 수 있으며, 시스템의 동작을 중단시키는 것까지는 알 수 없음</li>
<li>코드가 기대한 대로 동작하는지 검증하지 않는 CI는 CI가 아님</li>
</ul>
</li>
<li>
<p>Q. 빌드가 깨졌을 때 팀이 그것을 최우선으로 해결하는가?</p>
<ul>
<li>녹색 빌드는 변경한 것이 안전하게 통합되었고, 적색 빌드는 마지막 변경이 통합되지 않았음을 의미</li>
<li>우리는 빌드 문제의 해결과 관련 없는 추가적인 체크인을 중단해야 한다. 변경이 많이 적체되면 그 빌드를 해결할 시간이 급격히 늘어남</li>
<li>필자는 수일 동안 필드가 깨어진 채로 방치한 티과 함께 작업했었는데, 결국 빌드를 통화하는 데 엄청난 노력이 듬</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>CI는 빠르고 신속한 변경을 위한 핵심적인 실천 사항</code>  </p>
<ul>
<li>CI 없이는 마이크로서비스를 향한 여정이 고통스러울 것  </li>
<li>CI 도구의 사용과 CI의 실천을 혼동하지 말 것  </li>
<li>CI 도구는 단지 이러한 접근을 가능하게 할 뿐</li>
</ul>
</blockquote>
<h4>CI를 마이크로서비스와 매핑하기</h4>
<ul>
<li>
<p>마이크로서비스당 하나의 CI 빌드 구성</p>
<ul>
<li>실환경에 배포하기 전에 신속히 변경하고 확인하기 위함</li>
</ul>
</li>
<li>
<p>각 마이크로서비스는 각자의 CI 빌드에 매핑된 각각의 소스 코드 저장소를 가짐</p>
<ul>
<li>팀의 소유권도 훨씬 명확히 정리됨으로써 서비스의 소유는 저장소와 빌드도 책임지는 것을 의미</li>
</ul>
</li>
<li>
<p>테스트는 마이크로서비스 소스 코드가 있는 소스 컨트롤 시스템에 있어야 함</p>
<ul>
<li>특정 마이크로서비스에 대해 어떤 테스트가 수행되어야 하는지 언제든지 알 수 있어야 함</li>
</ul>
</li>
<li>
<ExternalLink href="/til#서비스와-호스트-매핑" target="_blank" text="호스트와 서비스 매핑 관계" />
</li>
</ul>
<h4>On-demand computing platform/주문형 컴퓨팅 플랫폼</h4>
<ul>
<li>컴퓨팅 자원의 비용을 대폭 낮춤</li>
<li>가상화 기술의 향상으로 조직 내 호스팅된 인프라스트럭처에 대해 더 많은 유연성 제공</li>
<li>
<p>시스템이 제로-다운타임을 허용하지 않는다면 실환경에 배포 시 다운타임이 늘어날 수 있음</p>
<ul>
<li>7장에서는 green/blue 배포와 같은 모델은 구버전의 서비스를 오프라인하지 않고도 신버전의 서비스를 배포할 수 있게 하면서 이러한 불편을 완화</li>
</ul>
</li>
<li>이 기동 시간(spin-up time)을 줄이기 위한 한 가지 방법은 <code>공통적으로 의존하는 것들을 주입한 가상 머신 이미지를 만드는 것</code></li>
</ul>
<blockquote>
<p>AWS EC2 Instance를 프로비전하고 그 안에서 LXCs<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> 실행<br>
매우 유연한 EC2의 형태로 대표되는 on-demand computing platform과<br>
그 위에서 빠르게 실행되는 컨테이너의 조합</p>
</blockquote>
<ul>
<li><a href="http://127.0.0.1:4000/til#virtual-platform">Virtual Platform - Docker, Kubernetes</a></li>
</ul>
<h2>7. 테스팅</h2>
<h3>Unit Test</h3>
<ul>
<li>일반적으로 단일 함수 또는 메서드 호출을 테스트하는 것</li>
<li><strong>기능의 정상 동작 유무에 대한 매우 빠른 피드백</strong></li>
<li>코드를 재구성하게 해주며, 작은 범위의 테스트들이 실수를 잡아주기 때문에 코드의 리팩토링을 지원하는 데 있어 중요</li>
<li>문제를 신속히 발견하고 해결하기 위해 테스트를 더욱 격리하기 위함</li>
<li>격리를 위해 모든 외부 협업자를 스텁으로 만들어 오직 서비스 자체의 범위만으로 제한</li>
</ul>
<h3>테스트 작성 전담 팀은 재앙</h3>
<ul>
<li>소프트웨어를 개발하는 팀은 그들의 코드에 대한 테스트와 점차 멀어짐</li>
<li>서비스 소유자들은 방금 개발한 기능의 E2E 테스트를 테스트 팀이 작성할 때까지 기다려야 하므로 사이클이 길어짐</li>
<li>다른 팀에 이 테스트를 작성하기 때문에 서비스를 개발했던 팀은 덜 참여하게 되고 이들은 테스트를 어떻게 고치는지 모르기 쉬움</li>
</ul>
<h3>Green/Blue Deployment</h3>
<p><img src="https://baek.dev/assets/images/post/2019/2019_013_004.jpg" alt="배포를 릴리스와 분리하기 위해 청색/녹색 배포 사용하기"></p>
<ul>
<li>동시에 배포된 신/구 버전의 소프트웨어중에서 한 버전만 실제 요청을 처리</li>
<li>
<p>실환경 트래픽을 다른 호스트(또는 호스트의 집합)로 향하게 할 수 있어야 함</p>
<ul>
<li>부하 분산 설정(load-balancing configuration)을 변경하는 식으로 가능</li>
</ul>
</li>
<li>
<p>한 번에 두 버전의 마이크로서비스를 프로비저닝할 수 있어야 함</p>
<ul>
<li>탄력적인 클라우드 제공자(elastic cloud provider)를 사용하면 간단한 일</li>
</ul>
</li>
<li>배포의 위험을 낮출 뿐만 아니라 문제가 발생했을 때 롤백이 빠르게 가능함</li>
<li>전체 프로세스가 사람의 개입이 전혀 없이도 모든 전개와 복귀가 자동화될 수 있음</li>
<li>
<p>무중단 배포(zero downtime deployment)</p>
<ul>
<li>릴리즈 작업을 수행하는 동안 과거 버전을 유지함으로써 시스템의 정지 시간을 크게 낮출 수 있음</li>
</ul>
</li>
</ul>
<h3>Canary Release</h3>
<ul>
<li>카나리 릴리스를 했을 때 시스템이 예상대로 수행하는지 보기 위해 실환경 트래픽을 유입시켜 새롭게 배포된 소프트웨어를 검증</li>
<li>새 릴리스가 잘못되었다면 신속히 되돌려야 함</li>
<li>새 릴리스가 정상이라면 늘어나는 트래픽이 새 버전에 유입되도록 해야함</li>
<li><em>카나리 릴리스는 버전들이 더 오래 공존시킬 수 있고 트래픽의 양을 자주 변경할 수 있다는 점에서 green/blue release와 차이가 있음</em></li>
<li>
<p><strong>장점</strong></p>
<ul>
<li>나쁜 릴리스의 출시 위험을 관리할 도구를 제공하며</li>
<li>실제 트래픽으로 새 버전의 소프트웨어를 검증할 수 있게 함</li>
</ul>
</li>
<li>
<p><strong>단점</strong></p>
<ul>
<li>하지만 green/blue release 배포보다 복잡한 설정과 약간의 사고를 더 필요로 함</li>
<li>서로 다른 버전의 서비스가 green/blue release보다 더 오랜 기간 공존할 것이 예상되므로 이전보다 더 많은 하드웨어를 점유할 수 있음</li>
<li>새로운 릴리스의 동작을 확신하기 위해 트래픽 비율을 조정해야 하기 때문에 더 정교한 트래픽 라우팅도 필요</li>
<li>하지만 이미 green/blue release를 다루고 있다면 필요한 구성 요소 일부는 이미 갖춘 셈</li>
</ul>
</li>
<li>
<p>넷플릭스 사례</p>
<ul>
<li>릴리스에 앞서 실환경과 동일한 버전을 표현하는 기반 클러스터에 새로운 서비스 버전이 함 께 배포</li>
<li>그 다음에 수 시간 동안 새 버전과 기반버전 양쪽에 실환경의 부하 일부를 주면서 측정</li>
<li>카나리 릴리즈가 테스트를 통과하고 나면 넷플릭스는 실환경에 전체 전개를 진행</li>
</ul>
</li>
</ul>
<h3>MTBF &#x26; MTTR</h3>
<ul>
<li>MTBF/Mean Time Between Failure : 평균 무고장 시간</li>
<li>MTTR/Mean Time To Repair : 평균 수리 시간</li>
<li>복구 시간을 줄이는 기술은 청색/녹색 배포와 같은 훌륭한 모니터링과 결합되어 아주 빠른 롤백만큼 단순할 수 있음</li>
<li>실환경의 문제를 일찍 발견하고 롤백할 수 있다면 고객에게 적은 영향을 줄 수 있음</li>
<li>물론 사용자가 새 버전의 소프트웨어를 접하기 전에 그것을 배포하고 바로 테스트할 수 있는 청색/녹색 배포와 같은 기술도 사용할 수 있음</li>
<li>기능 테스트 집합을 생성하는 데 시간을 보내는 대부분의 조직은 대게 더 나은 모니터링이나 장애 복구에 전혀 공을 들이지 않음</li>
<li>그들은 처음에 발생하는 많은 결함을 줄일 수 있지만, 전부 제거하지는 못하고 실환경에서 장애가 발생할 때 처리할 충분한 준비도 하지 못함</li>
</ul>
<h2>8. 모니터링</h2>
<ul>
<li>
<p><strong>모니터링이란?</strong></p>
<ul>
<li>모놀리식 애플리케이션의 세계에서는</li>
<li>적어도 분석을 시작할 아주 명확한 지점</li>
<li>단일 장애 지점(single point of failure)이 있다는</li>
<li>장애 분석을 다소 쉽게 만들 수 있어야 함</li>
<li>단일 서버/서비스, 다수 서버/서비스 등이 만드는 모든 것을 취합하고 세부 분석</li>
<li>로그부터 애플리케이션 측정 지표까지 가능한 한 많은 수집과 집중식 취합</li>
</ul>
</li>
<li>
<p><strong>logstash</strong></p>
<ul>
<li>많은 로그 파일 포맷을 파싱하고 추가 분석을 위해 하부 시스템에 전송할 수 있음</li>
</ul>
</li>
<li>
<p><strong>Kibana</strong></p>
<ul>
<li>로그를 보기 위한 일레스틱서치 기반 시스템(Elastic Search-backed system)</li>
<li>로그 검색을 위한 질의 구문(query syntax)과 특정 날짜와 시간 범위 또는 일치하는 문자열으르 찾기 위한 정규식도 사용할 수 있음</li>
<li>전송된 로그에서 그래포도 생성 가능, 시간에 따라 얼마나 많은 에러가 발생했는지 한번에 보는 것이 가능</li>
</ul>
</li>
<li>
<p><strong>Metrics</strong></p>
<ul>
<li>복잡한 환경에서는 서비스들의 인스턴스가 매우 빈번히 프로비저닝되기 때문에</li>
<li>우리가 선택한 시스템이 새로운 호스트로부터 측정지표를 매우 쉽게 수집하기 원함</li>
</ul>
</li>
<li>
<p><strong>Graphite/그래파이트</strong></p>
<ul>
<li>평균 CPU 부하와 같이 전체 시스켐에 대해 집계된 특정 측정지표를 볼 수 있기를 기대하지만</li>
<li>특정 서비스에 대한 모든 인스턴스나 개별 인스턴스에 대한 측정지표까지도 집계되기 원함</li>
<li>이러한 구조를 추론할 수 있도록 <code>메타데이터와 측정지표를 연결할 수 있도록 매우 쉽게 만들어주는 시스템</code></li>
<li>단순한 API를 제공해서 실시간으로 측정지표를 전송할 수 있고</li>
<li>현재 상황을 보여주는 차트나 다른 형태의 디스플레이를 생성하기 위해 그 측정지표에 대한 질의도 할 수 있음</li>
<li><code>여러 표본을 취합하고 한 표본을 따라 자세히 검색함으로써 전체 시스템, 서비스 그룹 또는 단일 인스턴스에 대한 응답시간을 알 수 있음</code></li>
</ul>
</li>
</ul>
<h3>상관관계 ID</h3>
<ul>
<li><code>stack strace로 한 것처럼 상향 호출 체인을 추적할 수 있음</code></li>
<li>첫 호출이 이뤄질 때 호출에 대한 전역 호출 식별자(GUID, globally unique identifier)를 생성</li>
<li>후속하는 모든 호출에 전달 -> 로그 레벨이나 날짜와 같은 구성 요소와 함께 구조화된 방식으로 로그에 넣을 수 있음<br>
<img src="https://baek.dev/assets/images/post/2019/2019_013_005.jpg" alt="상관관계ID가 심어진 로그"><br>
<img src="https://baek.dev/assets/images/post/2019/2019_013_006.jpg" alt="상관관계ID 사용하기"></li>
</ul>
<blockquote>
<p>하지만 처음부터 상관관계 ID가 있어야만 분석할 수 있는 문제를 접하기 전까지 상관관계 ID의 필요성을 모른다는 것!</p>
</blockquote>
<h3>통합 모니터링</h3>
<ul>
<li>시스템간의 통합 지점 모니터링 중요</li>
<li>각 서비스 인스턴스는 다른 서비스에 이르기까지 하위 의존성 상태를 추적하고 노출</li>
<li>모니터링은 표준화가 매우 중요한 분야</li>
<li>
<p>많은 인터페이스를 이용하는 사용자에게 기능을 제공하기 위해 다양한 방식으로 협업하는 서비스들이 있다면</p>
<ul>
<li>총제적인 방식으로 시스템을 바라볼 수 있어야 함</li>
</ul>
</li>
<li>표준 포맷으로 로그를 출력</li>
</ul>
<h2>9. 보안</h2>
<blockquote>
<p>인증(authentication)과 권한부여(authorization)는 시스템과 상호작용하는 인간과 사물에 있어 핵심적인 개념</p>
</blockquote>
<ul>
<li>보안의 맥락에서 인증은 자신이라고 말하는 당사자를 확인하는 과정</li>
<li>인증되는 사람 또는 사물에 대해 추상적으로 말할 때 그 대상을 principal로 언급</li>
<li><code>목표는 한 번의 인증으로 모든 시스템을 이용할 수 있는 single identity를 보유하는 것</code></li>
</ul>
<h3>SSO/Single Sign-On</h3>
<blockquote>
<p>예를 들어 어느 컴퓨터에 로그인한 후 그룹웨어 등의 응용 프로그램을 사용할 때에 로그인,<br>
다른 서버상의 응용 프로그램을 사용할 때에도 다시 로그인이 필요한 상황이라면,<br>
사용자는 여러 개의 아이디와 비밀번호를 관리해야 한다.<br>
<strong>통합인증을 도입한 환경에서는 사용자는 하나의 아이디와 비밀번호로 모든 기능을 사용할 수 있다.</strong></p>
</blockquote>
<ul>
<li>
<p><strong>SSO 장단점</strong></p>
<ul>
<li>보안이 필요한 환경에서 통합인증을 도입하는 경우</li>
<li>여러 응용 프로그램의 로그인 처리가 간소화되어 편리성을 도모할 수 있음</li>
<li>하지만 최초의 로그인 대상이 되는 응용 프로그램 혹은 운영체제에 대한 접근 보안이 중요함</li>
<li>보안위험이 적은 환경에서는 편리성만을 추구하면 되지만</li>
<li>보안이 요구되는 환경에서는 1회용 비밀번호를 이용하는 등 이중 인증 등으로 보안을 강화할 필요가 있음</li>
</ul>
</li>
<li>
<p><strong>SAML/Security Assertion Markup Language, 샘엘</strong></p>
<ul>
<li>인증 정보 제공자(identity provider)와 서비스 제공자(service provider) 간의 인증 및 인가 데이터를 교환하기 위한 XML 기반의 개방형 표준 데이터 포맷</li>
<li>SOAP 기반의 표준이며 지원 가능한 라이브러리와 도구가 있음에도 불구하고 작업이 꽤 복잡</li>
<li><a href="https://ko.wikipedia.org/wiki/SAML">출처 - 위키백과</a></li>
<li><a href="http://www.itworld.co.kr/tags/70505/OAuth/108736">SAML에 대해 알아야 할 것들</a></li>
</ul>
</li>
<li>
<p><strong>openID Connect</strong></p>
<ul>
<li>openID Connect 는 openid라는 scope 값을 포함해서 Authorization Request를 보내며 Authentication에 대한 정보는 ID Token 이라고 불리는 JSON Web Token(JWT)을 리턴</li>
<li>OAuth 2.0의 특정 구현에서 출발한 표준</li>
<li>구글 및 다른 업체에서 SSO를 처리하는데 사용</li>
<li>더 단순한 REST 호출을 사용하고, 사용 편의성이 향상되어 기업 시장으로 진출</li>
</ul>
</li>
<li>
<p><strong>LDAP/Lightweight Directory Access Protocol</strong></p>
<ul>
<li>기업의 경우에는 흔히 회사의 디렉터리 서비스와 연결될 수 있는 자체 신원 제공자를 보유</li>
<li>디렉터리 서비스 LDAP, 경량 디렉터리 액세스 프로토콜</li>
</ul>
</li>
<li>
<p><strong>Okta</strong></p>
<ul>
<li>이중 요소 인증과 같은 작업을 처리하는 SAML 신원 제공자 호스팅 서비스지만,</li>
<li>여러분 회사의 진위 출처 디렉터리 서비스도 연결 가능</li>
</ul>
</li>
</ul>
<h3>세분화된 권한 부여</h3>
<ul>
<li>게이트웨이는 상당히 효과적인 큰 단위의 인증 기능을 제공하는 것이 가능</li>
<li>로그인이 안 된 사용자의 헬프데스크 애플리케이션에 대한 접근을 차단할 수 있음</li>
<li>
<p>특정 자원 또는 엔드포인트에 대한 접근의 허용 여부는 마이크로서비스 자체에 맡겨야 함</p>
<ul>
<li>어떤 행동의 허용 여부는 마이크로서비스가 더 많이 결정해야 할 필요가 있음</li>
</ul>
</li>
<li>
<p><strong>HTTP(S) 기본 인증</strong></p>
<ul>
<li>HTTP Basic Authentication은 클라이언트가 사용자 이름과 패스워드를 표준 HTTP헤더에 넣어서 전송</li>
<li>서버는 상세 내용을 확인하고 클라이언트의 서비스 접근 허용 여부를 승인</li>
<li>하지만, <strong>안전한 방식으로 사용자 이름과 패스워드를 전송할 수 없으므로 문제가 많음</strong></li>
<li>네트워크상의 어떠한 중간자도 헤더 정보와 데이터를 볼 수 있으므로 HTTP 기본 인증은 대개 HTTPS 상에서 수행되어야 함</li>
<li>HTTPS를 사용하면 클라이언트는 통신하고 서버가 자신이 생각하는 그 서버라는 확실한 보장을 받고</li>
<li>클라이언트와 서버 간의 트래픽을 도청하거나 페이로 조작을 막는 추가적인 보호도 받음</li>
</ul>
</li>
<li>
<p><strong>SAML 또는 OpenID Connect 사용하기</strong></p>
<ul>
<li>게이트웨이를 사용하고 있다면 네트워크 내부의 트래픽을 게이트웨이로 라우팅해야겠지만</li>
<li>만약 개별 서비스가 직접 서비스 간 통합을 처리한다면 이 라우팅을 기본적으로 지원해야 함</li>
<li>기존의 인프라스트럭처를 사용할 수 있고 모든 서비스의 접근 통제를 중앙의 디렉터리 서버에 모아서 처리할 수 있음</li>
<li>중간자 공격을 피하고자 한다면 여전히 HTTPS 상에서 라우팅해야 함</li>
</ul>
</li>
<li>
<p><strong>클라이언트 인증서</strong></p>
<ul>
<li>클라이언트의 신원 확인을 위한 또 다른 방법은 (SSL의 계승자인) 클라이언트 인증서 형태의 전송 계층 보안(TLS/Transport Layer Security) 기능을 이용하는 것</li>
<li>클라이언트와 서버의 연결을 체결할 때 사용되는 X.509 인증서가 각 클라이언트에 설치되어 있으며,</li>
<li>서버는 클라이언트 인증서의 진위를 검증하여 유효한 클라이언트인지 확실히 보장할 수 있음</li>
</ul>
</li>
<li>
<p><strong>HTTP 기반의 HMAC</strong></p>
<ul>
<li>HTTPS 트래픽이 서버에 부담을 줄 수 있고, HTTPS 트래픽은 캐시하기도 쉽지 않음</li>
<li><strong>다른 대안은 OAuth 명세서 일부와 AWS S3 API에 의해 폭넓게 사용되는 해시 기반 메시징 코드(HMAC/hash-based messaging code)를 HTTP 요청의 서명에 사용하는 것</strong></li>
<li><strong>HMAC 장점</strong></li>
<li>HMAC에서 요청 메시지 바디는 비밀 키를 사용해서 해시되고 해시 결과는 요청과 함께 전송</li>
<li>서버는 자신이 가진 비밀 키의 복제본을 사용해서 해시를 재생성</li>
<li>1과 2가 일치한다면 서버는 그 요청을 수락</li>
<li>누군가 중간에 요청을 변조한다면 해시는 일치하지 않을 것이고, 서버는 그 요청이 변조되었다는 것을 알 수 있음</li>
<li>비밀 키는 절대 그 요청에 넣어 전송하지 않으므로 통신상에서 누출 될 수도 없음</li>
<li>트래픽이 더 쉽게 캐쉬되고, 경우에 따라 다르겠지만 아마도 해시를 생성하는 부하가 HTTPS 트래픽을 처리하는 것보다 더 낮다는 추가 이점</li>
<li><strong>HMAC 단점</strong></li>
<li>
<p>클라이언트와 서버 모두 어떤 방식으로든 통신해서 기밀을 공유해야 함</p>
<ul>
<li>양단간에 하드코딩할 수 있지만 기밀이 누출된다면 접근을 차단하는 데 문제가 있음</li>
<li>다른 대체 프로토콜을 통해 통신한다면 여러분은 그 프로토콜이 매우 안전하다는 것도 보장</li>
</ul>
</li>
<li>
<p>하나의 패턴이지 표준은 아니므로 다양한 구현 방법이 있음</p>
<ul>
<li>그 결과 이 방법에 대한 공객적이며 가용한 양질의 구현체가 부족</li>
</ul>
</li>
<li>
<p>제3자가 요청 내용을 조작하지 않았다는 것과 비밀 키 자체의 기밀성(전송하지 않으므로)만 보장하는 것</p>
<ul>
<li>요청한 데이터는 네트워크상에서 스누핑하는 사람들에게 여전히 노출</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>API Key</strong></p>
<ul>
<li>모든 공개 API는 API Key를 사용함</li>
<li>API Key를 통해 서비스는 API 호출자를 인식할 수 있고 호출자의 능력에 제한을 둘 수 있음</li>
<li>모두를 위한 서비스 품질을 유지하기 위해 특정 호출자에 대한 속도 제한을 할 수 있음</li>
<li>일부 시스템은 하나의 공유 API Key를 이용해서 앞에서 설명한 HMAC과 유사한 방식을 사용</li>
<li>더 일반적 방법은 공개 키와 개인키를 짝으로 사용하는 것</li>
<li>전형적으로 사람들의 신원을 한 곳에서 관리하듯이 키도 한 곳에서 관리하는데 이 분야에서는 흔히 <strong>게이트웨이</strong> 모델을 사용</li>
<li>API key 기반의 인증은 SAML 핸드셰이킹 처리와 비교하면 훨씬 더 단순하고 직관적</li>
</ul>
</li>
</ul>
<h3>네트워크 분리(망분리)</h3>
<ul>
<li>마이크로서비스에서는 서비스들의 상호 통신 방법의 통제를 세분화하도록 서비스들을 다른 네트워크 세그먼트에 배치할 수 있음</li>
<li>AWS는 가상 사설 클라우드(Virtual Private Cloud/VPC)를 자동적으로 프로비저닝하는 기능을 제공</li>
</ul>
<p><img src="https://baek.dev/assets/images/post/2019/2019_013_008.jpg" alt="불행히도 안전하지 못한 뮤직코퍼레이션 아키텍처의 서브넷">
<img src="https://baek.dev/assets/images/post/2019/2019_013_009.jpg" alt="더 안전한 뮤직코페이션 시스템"></p>
<h2>10. 콘웨이의 법칙과 시스템 설계</h2>
<h3>two-pizza team 법칙</h3>
<ul>
<li>팀의 규모가 피자 두판으로 식사를 마칠 수 없는 규모가 돼서는 안 된다</li>
<li>넷플릭스는 아마존의 사례를 교훈삼아 처음부터 작고 독립적인 팀을 조직했고</li>
<li>그 결과 독립적인 팀을 조직, 독립적인 서비스를 만들 수 있었음</li>
<li>변경 속도에 최적화된 시스템 아키텍처를 확보할 수 있었음</li>
</ul>
<h3>공유 서비스의 추진</h3>
<ul>
<li>소유권은 요구사항의 발굴에서부터 애플리케이션이 빌드, 배포, 유지보수에 이르는 모든 측면까지 확장</li>
<li>마이크로서비스에서 더 만연한 모델로, 작은 팀이 작은 서비스를 소유하기 더 용이</li>
<li>소유권 확대는 자율성 향상과 빠른 출시로 이어짐</li>
<li>애플리케이션의 배포와 유지보수까지 한 팀이 책임지게 하면 그 보상으로 배포하기 쉬운 서비스가 만들어짐</li>
</ul>
<h3>방치된 서비스</h3>
<ul>
<li>내부 오픈 소스 모델을 훌륭히 지원하기 위해 여러분은 몇 가지 도구가 필요</li>
<li>pull 요청 또는 이와 유사한 기능을 가진 분산 버전 관리 도구는 필수</li>
<li>탑재한 코드 리뷰 시스템이거나 아닐 수도 있지만 패치에 대한 인라인 코멘트는 매우 유용한 기능</li>
<li>우리는 경계가 있는 콘텍스트 주위로 서비스의 경계선을 긋는다</li>
</ul>
<blockquote>
<p>다양한 기술 스택을 사용하는 폴리글랏 방식(polyglot approach)을 적용한 경우<br>
여러분 팀이 더 이상 그 기술 스택을 모른다면 방치된 서비스를(orphaned service) 변경하는 것은<br>
심각한 문제가 될 수 있음</p>
</blockquote>
<h2>11. 대규모 마이크로서비스</h2>
<blockquote>
<p><strong>분산 컴퓨팅의 오류</strong><br>
분산 컴퓨팅에서 아키텍트나 설계자가 범하기 쉬운 7가지 가정을 소개했고,<br>
그 후 제임스 고슬링이 다른 오류를 추가해서 분산 컴퓨팅의 8가지 오류로 알려짐</p>
</blockquote>
<blockquote>
<p>어떤 것이든 고장날 수 있다는 가정을 명심하는 것은 문제의 해결 방법을 다르게 생각하도록 만든다</p>
</blockquote>
<h3>AntiFragile</h3>
<ul>
<li>넷플릭스는 안티프래질 조직의 개념을 형성</li>
<li>넷플릭스가 전적으로 AWS 인프라스트럭처에 기반한다는 사실</li>
<li>이 두 요소는 장애를 잘 수용해야 한다는 것을 의미, 장애를 일부러 유발</li>
<li>구글은 매년 장애 복구 테스트(Disaster Recovery Test, DiRT) 훈련</li>
<li>
<p><strong>Chaos Monkey</strong></p>
<ul>
<li>하루 중 특정 시간 동안 임의로 머신의 전원을 꺼버림</li>
<li>실운영 환경에서 이런 사고의 발생 가능성을 인지하는 것은 시스템을 만드는 개발자들이 실제로 그 사고에 준비하게 만듬</li>
<li>넷플릭스의 장애를 만드는 봇인 유인원 부대의 일부</li>
</ul>
</li>
<li>
<p><strong>Chaos Gorilla</strong></p>
<ul>
<li>전체 가용성 센터(AWS의 데이터 센터에 해당되는)를 검토하는 데 사용</li>
</ul>
</li>
<li>
<p><strong>Latency Monkey</strong></p>
<ul>
<li>머신 간의 느린 네트워크 접속 상황을 시뮬레이션 함</li>
</ul>
</li>
<li>
<p><strong>Timeout</strong></p>
<ul>
<li>모든 프로세스 경계 외부의 호출에 타임아웃을 넣고 항상 기본 타임아웃 시간을 설정할 것</li>
<li>타임아웃 발생 시간을 로깅하고 어떤 일이 발생했는지 살펴보며 타임아웃을 적절히 변경할 것</li>
</ul>
</li>
</ul>
<h3>하위 시스템이 실제로 다운될 때까지 얼마나 오래 기다릴 수 있을까?</h3>
<ul>
<li>호출이 실패했다고 판단하는데 너무 오래 걸리면 전체 시스템이 느려질 수 있음</li>
<li>혹은 너무 빨리 타임아웃하면 동작했을지도 모르는 호출을 실패로 고려할 것</li>
</ul>
<h3>Circuit Breaker</h3>
<p><img src="https://baek.dev/assets/images/post/2019/2019_013_010.jpg" alt="Circuit Breaker"></p>
<ul>
<li>가정마다 전련 급등으로부터 가전 기기를 보호하기 위한 회로 차단기(Circuit Breaker)</li>
<li>회로 차단기의 구현 방법은 실패한 요청의 의미에 따라 다름</li>
<li>HTTP 커넥션을 위한 차단기를 구현할 때는 타임아웃이나 5XX HTTP 응답 코드에 해당되는 호출 실패를 설정</li>
<li><code>하위 자원이 다운되거나 타임아웃되거나 에러를 리턴할 때 특정 임계값에 도달 한 후 자동적으로 전송 트래픽을 중지시키고 신속히 실패하도록 만듬</code></li>
<li>정상으로 복구되었을 때 자동으로 재시작할 수 있음</li>
<li>
<p><strong>회로 차단기가 끊어진 동안 할 수 있는 옵션</strong></p>
<ul>
<li>요청을 큐에 넣어두고 나중에 처리하는 것</li>
<li>비동기 작업의 일부로 작업을 수행한다면 효과적</li>
<li>호출이 동기 체인의 일부분으로 수행되는 경우에는 빨리 실패하는 것이 더 나음</li>
</ul>
</li>
</ul>
<h3>격벽</h3>
<ul>
<li>소프트웨어 아키텍처 측면에서 고려할 수 있는 다양한 격벽이 있음</li>
<li>각각의 하위 커넥션마다 다른 커넥션 풀을 사용해야 한다</li>
<li>이것은 특정 하위 서비스가 느려지게 되더라도 그 서비스의 커넥션 풀에서만 영향을 받고 다른 호출은 정상 처리되는 것을 보장</li>
<li><strong>우려되는 것을 분리하는 것도 격벽의 한 방법</strong></li>
<li>얽혀 있는 기능을 분리된 마이크로서비스로 분해함으로써 한 지역의 장애가 다른 지역에 영향을 줄 가능성을 줄임<br>
<img src="https://baek.dev/assets/images/post/2019/2019_013_011.jpg" alt="상관관계ID가 심어진 로그"></li>
</ul>
<h3>SSL termination</h3>
<ul>
<li>분산기로 유입되는 HTTPS 커넥션을 HTTP 커넥션으로 변환해서 인스턴스에 전달</li>
<li>과거에는 SSL을 관리하는 부하가 상당히 높아 이 변환 과정을 처리하는 부하 분산기<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup>를 두는 것이 매우 유용했으나,</li>
<li>요즘 이런 일은 인스턴스가 동작하는 개별 호스트를 셋업하는 것만큼 단순함</li>
<li>HTTPS를 사용하는 것은 요청이 중간자 공격에 취약하지 않게 만들기 위한 것이므로,</li>
<li>SSL 종단 기능을 사용하면 우리 자신을 잠재적으로 어느 정도 노출하는 것</li>
<li>Virtual Local Area Network 안에 모든 마이크로서비스 인스턴스를 두는 것</li>
</ul>
<h3>ELB / Elastic Load Balancer</h3>
<ul>
<li>AWS는 HTTPS 종단 기능이 있는 부하 분산기를 ELB형태로 제공</li>
<li>VLAN<sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup>을 구현하기 위해 AWS 보안 그룹이나 가상 사설 클라우드 (VPC/Virtual Private Cloud)를 사용</li>
</ul>
<h3>데이터 확장</h3>
<ul>
<li>
<p><strong>Standby Replica Database</strong></p>
<ul>
<li>마스터 데이터베이스에 저장된 모든 데이터가 대기 복제 데이터베이스에 복사됨</li>
<li>마스터 DB가 다운될 경우 데이터는 안전하지만,</li>
<li>그렇더라도 마스터 DB를 백업으로 바꾸거나 레플리카를 마스터DB로 승격시키는 매커니즘 없이는 DB가용성을 얻을 수 없음</li>
<li><img src="https://baek.dev/assets/images/post/2019/2019_013_012.jpg" alt="Replica"></li>
</ul>
</li>
<li>
<p><strong>쓰기용 확장 - Sharding</strong></p>
<ul>
<li>샤딩을 통해 많은 DB Node를 가질 수 있음</li>
<li>저장할 데이터의 일부를 가지고 해싱 함수를 통해 데이터의 키를 생성하며 해싱 함수의 결과인 그 키를 사용해서 저장할 장소를 얻음</li>
</ul>
</li>
<li>
<p><strong>MongoDB - Map/Reduce</strong></p>
<ul>
<li>모든 샤드에 질의하고 싶다면 각각의 샤드에 질의하고 메모리에서 조인하거나 여러 데이터셋이 있는 다른 읽기 전용 저장소가 필요</li>
<li>여러 샤드에 대한 잦은 질의는 캐시 결과를 사용해서 비동기적 매커니즘으로 처리</li>
</ul>
</li>
<li>
<p><strong>Casandra</strong></p>
<ul>
<li>백그라운드에서 데이터의 재조정을 수행하면서 라이브 시스템에 샤드 추가를 지원</li>
<li>기존 클러스트에 샤드를 추가하는 것은 심약한 사람에게 맞지 않으므로 철저한 테스트를 잊지 말라</li>
</ul>
</li>
</ul>
<h3>Caching</h3>
<ul>
<li>연산의 이전 결과를 저장해서 연속된 요청은 재연산을 위한 시간과 자원의 소비 없이 저장되어 있는 값 사용 가능</li>
<li>대개 캐싱은 결과를 더 빠르게 제공하기 위해 DB나 다른 서비스까지의 불필요한 왕복을 제거</li>
<li>
<p><strong>Client side Caching</strong></p>
<ul>
<li>클라이언트가 새로운 복사본을 가져올 시점과 여부를 결정</li>
<li>하위 서비스가 힌트를 제공하며 클라이언트는 그 응답을 통해 해야 할 것을 이해하고 새로운 요청의 시점과 여부를 알 수 있음</li>
<li>네트워크 호출을 대폭 줄임</li>
<li>서버의 하위 서비스에 대한 부하를 줄일 수 있는 가장 빠른 방법</li>
</ul>
</li>
<li>
<p><strong>Proxy Caching</strong></p>
<ul>
<li>클라이언트와 서버 사이에 프로식스를 배치하는 것</li>
<li>
<p>Reversed Proxy</p>
<ul>
<li>스퀴드, 바니시처럼 모든 HTTP Traffic을 캐시</li>
</ul>
</li>
<li>CDN / Content Delivery Network</li>
<li>클라이언트와 서버에 독립적</li>
<li>기존 시스템에 캐싱을 추가하는 가장 간단한 방법</li>
</ul>
</li>
<li>
<p><strong>Server side Caching</strong></p>
<ul>
<li>Redis</li>
<li>Memcached</li>
<li>In-memory Cache</li>
</ul>
</li>
</ul>
<h2>+ Words</h2>
<ul>
<li>
<p><strong>snooping</strong></p>
<ul>
<li>네트워크상의 정보를 획득하는 일련의 행위를 의미</li>
<li>sniffing도 유사한 의미를 가지지만 주로 염탐하는 행위를 뜻함</li>
</ul>
</li>
<li>
<p><strong>PaaS/Platform as a Service</strong></p>
<ul>
<li>서비스로서의 플랫폼, 대표적으로 Heroku</li>
<li>Heroku는 서비스의 실행을 처리할 뿐만 아니라 아주 단순한 방식으로 데이터베이스와 같은 서비스도 지원</li>
<li>애플리케이션의 용도를 기반으로 autoscale을 시도하려는 PasS를 많이 사용했었지만 그 결과는 좋지 않았음</li>
</ul>
</li>
<li>
<p><strong>cascading failure/장애 전파</strong></p>
<ul>
<li>처음에 한 파트에서 발생한 장애가 연속하는 다른 파트에 장애를 촉발시키는 것</li>
<li>상호 연결된 파트의 시스템에서 발생 할 수 있음</li>
<li>이와 같은 장애는 전력 송출, 컴퓨터 네트워킹, 금융, 인체 시스템과 같은 다양한 종류의 시스템에서 발생 가능</li>
</ul>
</li>
<li>
<p><strong>Netflix's Hystrix</strong></p>
<ul>
<li>지연시간 및 장애 내성 로직을 추가하여 분산 환경 서비스들 간의 상호작용을 통제하는 라이브러리</li>
<li>서비스 사이의 포인트를 격리하고 전파 장애를 막아 시스템의 회복력을 향상시킴</li>
</ul>
</li>
<li>
<p><strong>Netflix's Suro</strong></p>
<ul>
<li>넷플릭스의 데이터 파이프라인 플랫폼</li>
<li>사용자 행위의 데이터와 애플리케이션 로그처럼 보다 시스템 운영적인 데이터와 연관된 두 지표 모두를 처리하는 분명한 용도</li>
<li>Apache Chukwa를 기반으로 자사의 분산된 애플리케이션 서버에서 쏟아지는 엄청난 데이터를 수집해서</li>
<li>S3나 하둡 파일 시스템 같은 저장소에 저장하여 실시간 분석을 도와주는 오픈 소스 플랫폼</li>
</ul>
</li>
<li>
<p><strong>멱등성</strong></p>
<ul>
<li>연산이 연속적으로 여러 번 적용되더라도 첫 적용 후의 결과가 달라지지 않는 성질의 연산</li>
</ul>
</li>
<li>
<p><strong>Swagger</strong></p>
<ul>
<li>스웨거를 사용할 경우 API를 잘 기술하면 웹 브라우저를 통해 API 문서를 볼 수 있고 API와 상호 작용할 수 있는 웹 UI를 생성할 수 있음</li>
</ul>
</li>
</ul>
<div class="footnotes">
<hr>
<ol>
<li id="fn-1">
<p>LXC/Linux Container : 분리된 가상의 호스트를 구분하고 통제하기 위해 프로세스들을 위한 분리된 프로세스 공간을 생성 <a href="/til#linux" taget="_blank">>자세히 보기</a></p>
<a href="#fnref-1" class="footnote-backref">↩</a>
</li>
<li id="fn-2">
<p>부하 분산. 부하 분산기 뒤에 마이크로서비스 인스턴스가 실행되는 여러 호스트를 배치하는 것으로 고용량 고비용의 하드웨어 장비에서 모드 프로식와 같은 소프트웨어 기반의 것까지 그 형태와 크기가 다양</p>
<a href="#fnref-2" class="footnote-backref">↩</a>
</li>
<li id="fn-3">
<p>VLAN. 가상 지역 네트워크로 외부와 격리되어 있어 외부의 요청은 라우터를 통해서만 유입된다. 이 경우에는 라우터가 SSL을 종단하는 부하 분산기가 되며 VLAN 외부의 커뮤니케이션은 HTTPS로 하지만 내부에서는 모두 HTTP를 사용.</p>
<a href="#fnref-3" class="footnote-backref">↩</a>
</li>
</ol>
</div>]]></description><link>https://baek.dev/post/13/</link><guid isPermaLink="false">https://baek.dev/post/13/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sat, 28 Dec 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;import ExternalLink from &apos;components/ExternalLink&apos;;&lt;/p&gt;
&lt;h2&gt;6. 배포&lt;/h2&gt;
&lt;h3&gt;지속적 통합(CI/Continuous Integration)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CI를 통한 핵심 목표는 모든 사람이 서로 동기를 맞추는 것&lt;/li&gt;
&lt;li&gt;새롭게 체크인된 코드가 기존 코드와 적절히 통합됨을 보장함으로 달성할 수 있음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CI 서버는 아래에 대한 검증을 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;코드의 커밋을 감지&lt;/li&gt;
&lt;li&gt;체크아웃&lt;/li&gt;
&lt;li&gt;코드의 컴파일과 테스트 통과를 확인&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;CI 장점&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;코드 품질에 대해 어느 정도 바른 피드백을 얻을 수 있음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;바이너리 산출물을 자동으로 생성&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;산출물의 빌드를 위한 모든 코드는 버전 관리 되므로 필요할 때 언제든지 다시 만들 수 있음&lt;/li&gt;
&lt;li&gt;배포된 산출물의 코드를 찾을 수 있는 정도로 추적할 수 있음&lt;/li&gt;
&lt;li&gt;CI 도구 자체의 기능에 따라 코드와 산출물에 대해 어떤 테스트가 수행되었는지 확인 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;제즈 험블의 3가지 질문&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Q. 하루에 한번 메인 브랜치에 체크인하는가?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;나의 코드는 물론 다른 사람들이 변경한 코드 또한 자주 확인하지 않는다면 향후의 통합이 더 어려워짐.&lt;/li&gt;
&lt;li&gt;내 피처 개발을 위해 별도의 브랜치를 사용하고 있더라도 가능한 한 자주 메인 브랜치에 통합 해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Q. 변경을 확인할 테스트 집합이 있는가?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테스트를 하지 않는다면 통합해서 작동하는지 구문상으로만 알 수 있으며, 시스템의 동작을 중단시키는 것까지는 알 수 없음&lt;/li&gt;
&lt;li&gt;코드가 기대한 대로 동작하는지 검증하지 않는 CI는 CI가 아님&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Q. 빌드가 깨졌을 때 팀이 그것을 최우선으로 해결하는가?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;녹색 빌드는 변경한 것이 안전하게 통합되었고, 적색 빌드는 마지막 변경이 통합되지 않았음을 의미&lt;/li&gt;
&lt;li&gt;우리는 빌드 문제의 해결과 관련 없는 추가적인 체크인을 중단해야 한다. 변경이 많이 적체되면 그 빌드를 해결할 시간이 급격히 늘어남&lt;/li&gt;
&lt;li&gt;필자는 수일 동안 필드가 깨어진 채로 방치한 티과 함께 작업했었는데, 결국 빌드를 통화하는 데 엄청난 노력이 듬&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;CI는 빠르고 신속한 변경을 위한 핵심적인 실천 사항&lt;/code&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CI 없이는 마이크로서비스를 향한 여정이 고통스러울 것  &lt;/li&gt;
&lt;li&gt;CI 도구의 사용과 CI의 실천을 혼동하지 말 것  &lt;/li&gt;
&lt;li&gt;CI 도구는 단지 이러한 접근을 가능하게 할 뿐&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4&gt;CI를 마이크로서비스와 매핑하기&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;마이크로서비스당 하나의 CI 빌드 구성&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실환경에 배포하기 전에 신속히 변경하고 확인하기 위함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;각 마이크로서비스는 각자의 CI 빌드에 매핑된 각각의 소스 코드 저장소를 가짐&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀의 소유권도 훨씬 명확히 정리됨으로써 서비스의 소유는 저장소와 빌드도 책임지는 것을 의미&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;테스트는 마이크로서비스 소스 코드가 있는 소스 컨트롤 시스템에 있어야 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;특정 마이크로서비스에 대해 어떤 테스트가 수행되어야 하는지 언제든지 알 수 있어야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ExternalLink href=&quot;/til#서비스와-호스트-매핑&quot; target=&quot;_blank&quot; text=&quot;호스트와 서비스 매핑 관계&quot; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;On-demand computing platform/주문형 컴퓨팅 플랫폼&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;컴퓨팅 자원의 비용을 대폭 낮춤&lt;/li&gt;
&lt;li&gt;가상화 기술의 향상으로 조직 내 호스팅된 인프라스트럭처에 대해 더 많은 유연성 제공&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시스템이 제로-다운타임을 허용하지 않는다면 실환경에 배포 시 다운타임이 늘어날 수 있음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;7장에서는 green/blue 배포와 같은 모델은 구버전의 서비스를 오프라인하지 않고도 신버전의 서비스를 배포할 수 있게 하면서 이러한 불편을 완화&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이 기동 시간(spin-up time)을 줄이기 위한 한 가지 방법은 &lt;code&gt;공통적으로 의존하는 것들을 주입한 가상 머신 이미지를 만드는 것&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;AWS EC2 Instance를 프로비전하고 그 안에서 LXCs&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 실행&lt;br&gt;
매우 유연한 EC2의 형태로 대표되는 on-demand computing platform과&lt;br&gt;
그 위에서 빠르게 실행되는 컨테이너의 조합&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://127.0.0.1:4000/til#virtual-platform&quot;&gt;Virtual Platform - Docker, Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;7. 테스팅&lt;/h2&gt;
&lt;h3&gt;Unit Test&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;일반적으로 단일 함수 또는 메서드 호출을 테스트하는 것&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;기능의 정상 동작 유무에 대한 매우 빠른 피드백&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;코드를 재구성하게 해주며, 작은 범위의 테스트들이 실수를 잡아주기 때문에 코드의 리팩토링을 지원하는 데 있어 중요&lt;/li&gt;
&lt;li&gt;문제를 신속히 발견하고 해결하기 위해 테스트를 더욱 격리하기 위함&lt;/li&gt;
&lt;li&gt;격리를 위해 모든 외부 협업자를 스텁으로 만들어 오직 서비스 자체의 범위만으로 제한&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;테스트 작성 전담 팀은 재앙&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;소프트웨어를 개발하는 팀은 그들의 코드에 대한 테스트와 점차 멀어짐&lt;/li&gt;
&lt;li&gt;서비스 소유자들은 방금 개발한 기능의 E2E 테스트를 테스트 팀이 작성할 때까지 기다려야 하므로 사이클이 길어짐&lt;/li&gt;
&lt;li&gt;다른 팀에 이 테스트를 작성하기 때문에 서비스를 개발했던 팀은 덜 참여하게 되고 이들은 테스트를 어떻게 고치는지 모르기 쉬움&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Green/Blue Deployment&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_013_004.jpg&quot; alt=&quot;배포를 릴리스와 분리하기 위해 청색/녹색 배포 사용하기&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;동시에 배포된 신/구 버전의 소프트웨어중에서 한 버전만 실제 요청을 처리&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;실환경 트래픽을 다른 호스트(또는 호스트의 집합)로 향하게 할 수 있어야 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;부하 분산 설정(load-balancing configuration)을 변경하는 식으로 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;한 번에 두 버전의 마이크로서비스를 프로비저닝할 수 있어야 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;탄력적인 클라우드 제공자(elastic cloud provider)를 사용하면 간단한 일&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;배포의 위험을 낮출 뿐만 아니라 문제가 발생했을 때 롤백이 빠르게 가능함&lt;/li&gt;
&lt;li&gt;전체 프로세스가 사람의 개입이 전혀 없이도 모든 전개와 복귀가 자동화될 수 있음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;무중단 배포(zero downtime deployment)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;릴리즈 작업을 수행하는 동안 과거 버전을 유지함으로써 시스템의 정지 시간을 크게 낮출 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Canary Release&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;카나리 릴리스를 했을 때 시스템이 예상대로 수행하는지 보기 위해 실환경 트래픽을 유입시켜 새롭게 배포된 소프트웨어를 검증&lt;/li&gt;
&lt;li&gt;새 릴리스가 잘못되었다면 신속히 되돌려야 함&lt;/li&gt;
&lt;li&gt;새 릴리스가 정상이라면 늘어나는 트래픽이 새 버전에 유입되도록 해야함&lt;/li&gt;
&lt;li&gt;&lt;em&gt;카나리 릴리스는 버전들이 더 오래 공존시킬 수 있고 트래픽의 양을 자주 변경할 수 있다는 점에서 green/blue release와 차이가 있음&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;나쁜 릴리스의 출시 위험을 관리할 도구를 제공하며&lt;/li&gt;
&lt;li&gt;실제 트래픽으로 새 버전의 소프트웨어를 검증할 수 있게 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하지만 green/blue release 배포보다 복잡한 설정과 약간의 사고를 더 필요로 함&lt;/li&gt;
&lt;li&gt;서로 다른 버전의 서비스가 green/blue release보다 더 오랜 기간 공존할 것이 예상되므로 이전보다 더 많은 하드웨어를 점유할 수 있음&lt;/li&gt;
&lt;li&gt;새로운 릴리스의 동작을 확신하기 위해 트래픽 비율을 조정해야 하기 때문에 더 정교한 트래픽 라우팅도 필요&lt;/li&gt;
&lt;li&gt;하지만 이미 green/blue release를 다루고 있다면 필요한 구성 요소 일부는 이미 갖춘 셈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;넷플릭스 사례&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;릴리스에 앞서 실환경과 동일한 버전을 표현하는 기반 클러스터에 새로운 서비스 버전이 함 께 배포&lt;/li&gt;
&lt;li&gt;그 다음에 수 시간 동안 새 버전과 기반버전 양쪽에 실환경의 부하 일부를 주면서 측정&lt;/li&gt;
&lt;li&gt;카나리 릴리즈가 테스트를 통과하고 나면 넷플릭스는 실환경에 전체 전개를 진행&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;MTBF &amp;#x26; MTTR&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MTBF/Mean Time Between Failure : 평균 무고장 시간&lt;/li&gt;
&lt;li&gt;MTTR/Mean Time To Repair : 평균 수리 시간&lt;/li&gt;
&lt;li&gt;복구 시간을 줄이는 기술은 청색/녹색 배포와 같은 훌륭한 모니터링과 결합되어 아주 빠른 롤백만큼 단순할 수 있음&lt;/li&gt;
&lt;li&gt;실환경의 문제를 일찍 발견하고 롤백할 수 있다면 고객에게 적은 영향을 줄 수 있음&lt;/li&gt;
&lt;li&gt;물론 사용자가 새 버전의 소프트웨어를 접하기 전에 그것을 배포하고 바로 테스트할 수 있는 청색/녹색 배포와 같은 기술도 사용할 수 있음&lt;/li&gt;
&lt;li&gt;기능 테스트 집합을 생성하는 데 시간을 보내는 대부분의 조직은 대게 더 나은 모니터링이나 장애 복구에 전혀 공을 들이지 않음&lt;/li&gt;
&lt;li&gt;그들은 처음에 발생하는 많은 결함을 줄일 수 있지만, 전부 제거하지는 못하고 실환경에서 장애가 발생할 때 처리할 충분한 준비도 하지 못함&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;8. 모니터링&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;모니터링이란?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모놀리식 애플리케이션의 세계에서는&lt;/li&gt;
&lt;li&gt;적어도 분석을 시작할 아주 명확한 지점&lt;/li&gt;
&lt;li&gt;단일 장애 지점(single point of failure)이 있다는&lt;/li&gt;
&lt;li&gt;장애 분석을 다소 쉽게 만들 수 있어야 함&lt;/li&gt;
&lt;li&gt;단일 서버/서비스, 다수 서버/서비스 등이 만드는 모든 것을 취합하고 세부 분석&lt;/li&gt;
&lt;li&gt;로그부터 애플리케이션 측정 지표까지 가능한 한 많은 수집과 집중식 취합&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;logstash&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;많은 로그 파일 포맷을 파싱하고 추가 분석을 위해 하부 시스템에 전송할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Kibana&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;로그를 보기 위한 일레스틱서치 기반 시스템(Elastic Search-backed system)&lt;/li&gt;
&lt;li&gt;로그 검색을 위한 질의 구문(query syntax)과 특정 날짜와 시간 범위 또는 일치하는 문자열으르 찾기 위한 정규식도 사용할 수 있음&lt;/li&gt;
&lt;li&gt;전송된 로그에서 그래포도 생성 가능, 시간에 따라 얼마나 많은 에러가 발생했는지 한번에 보는 것이 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Metrics&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;복잡한 환경에서는 서비스들의 인스턴스가 매우 빈번히 프로비저닝되기 때문에&lt;/li&gt;
&lt;li&gt;우리가 선택한 시스템이 새로운 호스트로부터 측정지표를 매우 쉽게 수집하기 원함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Graphite/그래파이트&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;평균 CPU 부하와 같이 전체 시스켐에 대해 집계된 특정 측정지표를 볼 수 있기를 기대하지만&lt;/li&gt;
&lt;li&gt;특정 서비스에 대한 모든 인스턴스나 개별 인스턴스에 대한 측정지표까지도 집계되기 원함&lt;/li&gt;
&lt;li&gt;이러한 구조를 추론할 수 있도록 &lt;code&gt;메타데이터와 측정지표를 연결할 수 있도록 매우 쉽게 만들어주는 시스템&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;단순한 API를 제공해서 실시간으로 측정지표를 전송할 수 있고&lt;/li&gt;
&lt;li&gt;현재 상황을 보여주는 차트나 다른 형태의 디스플레이를 생성하기 위해 그 측정지표에 대한 질의도 할 수 있음&lt;/li&gt;
&lt;li&gt;&lt;code&gt;여러 표본을 취합하고 한 표본을 따라 자세히 검색함으로써 전체 시스템, 서비스 그룹 또는 단일 인스턴스에 대한 응답시간을 알 수 있음&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;상관관계 ID&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack strace로 한 것처럼 상향 호출 체인을 추적할 수 있음&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;첫 호출이 이뤄질 때 호출에 대한 전역 호출 식별자(GUID, globally unique identifier)를 생성&lt;/li&gt;
&lt;li&gt;후속하는 모든 호출에 전달 -&gt; 로그 레벨이나 날짜와 같은 구성 요소와 함께 구조화된 방식으로 로그에 넣을 수 있음&lt;br&gt;
&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_013_005.jpg&quot; alt=&quot;상관관계ID가 심어진 로그&quot;&gt;&lt;br&gt;
&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_013_006.jpg&quot; alt=&quot;상관관계ID 사용하기&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;하지만 처음부터 상관관계 ID가 있어야만 분석할 수 있는 문제를 접하기 전까지 상관관계 ID의 필요성을 모른다는 것!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;통합 모니터링&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시스템간의 통합 지점 모니터링 중요&lt;/li&gt;
&lt;li&gt;각 서비스 인스턴스는 다른 서비스에 이르기까지 하위 의존성 상태를 추적하고 노출&lt;/li&gt;
&lt;li&gt;모니터링은 표준화가 매우 중요한 분야&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;많은 인터페이스를 이용하는 사용자에게 기능을 제공하기 위해 다양한 방식으로 협업하는 서비스들이 있다면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;총제적인 방식으로 시스템을 바라볼 수 있어야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;표준 포맷으로 로그를 출력&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;9. 보안&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;인증(authentication)과 권한부여(authorization)는 시스템과 상호작용하는 인간과 사물에 있어 핵심적인 개념&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;보안의 맥락에서 인증은 자신이라고 말하는 당사자를 확인하는 과정&lt;/li&gt;
&lt;li&gt;인증되는 사람 또는 사물에 대해 추상적으로 말할 때 그 대상을 principal로 언급&lt;/li&gt;
&lt;li&gt;&lt;code&gt;목표는 한 번의 인증으로 모든 시스템을 이용할 수 있는 single identity를 보유하는 것&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;SSO/Single Sign-On&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;예를 들어 어느 컴퓨터에 로그인한 후 그룹웨어 등의 응용 프로그램을 사용할 때에 로그인,&lt;br&gt;
다른 서버상의 응용 프로그램을 사용할 때에도 다시 로그인이 필요한 상황이라면,&lt;br&gt;
사용자는 여러 개의 아이디와 비밀번호를 관리해야 한다.&lt;br&gt;
&lt;strong&gt;통합인증을 도입한 환경에서는 사용자는 하나의 아이디와 비밀번호로 모든 기능을 사용할 수 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SSO 장단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;보안이 필요한 환경에서 통합인증을 도입하는 경우&lt;/li&gt;
&lt;li&gt;여러 응용 프로그램의 로그인 처리가 간소화되어 편리성을 도모할 수 있음&lt;/li&gt;
&lt;li&gt;하지만 최초의 로그인 대상이 되는 응용 프로그램 혹은 운영체제에 대한 접근 보안이 중요함&lt;/li&gt;
&lt;li&gt;보안위험이 적은 환경에서는 편리성만을 추구하면 되지만&lt;/li&gt;
&lt;li&gt;보안이 요구되는 환경에서는 1회용 비밀번호를 이용하는 등 이중 인증 등으로 보안을 강화할 필요가 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SAML/Security Assertion Markup Language, 샘엘&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인증 정보 제공자(identity provider)와 서비스 제공자(service provider) 간의 인증 및 인가 데이터를 교환하기 위한 XML 기반의 개방형 표준 데이터 포맷&lt;/li&gt;
&lt;li&gt;SOAP 기반의 표준이며 지원 가능한 라이브러리와 도구가 있음에도 불구하고 작업이 꽤 복잡&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/SAML&quot;&gt;출처 - 위키백과&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.itworld.co.kr/tags/70505/OAuth/108736&quot;&gt;SAML에 대해 알아야 할 것들&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;openID Connect&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;openID Connect 는 openid라는 scope 값을 포함해서 Authorization Request를 보내며 Authentication에 대한 정보는 ID Token 이라고 불리는 JSON Web Token(JWT)을 리턴&lt;/li&gt;
&lt;li&gt;OAuth 2.0의 특정 구현에서 출발한 표준&lt;/li&gt;
&lt;li&gt;구글 및 다른 업체에서 SSO를 처리하는데 사용&lt;/li&gt;
&lt;li&gt;더 단순한 REST 호출을 사용하고, 사용 편의성이 향상되어 기업 시장으로 진출&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LDAP/Lightweight Directory Access Protocol&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기업의 경우에는 흔히 회사의 디렉터리 서비스와 연결될 수 있는 자체 신원 제공자를 보유&lt;/li&gt;
&lt;li&gt;디렉터리 서비스 LDAP, 경량 디렉터리 액세스 프로토콜&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Okta&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이중 요소 인증과 같은 작업을 처리하는 SAML 신원 제공자 호스팅 서비스지만,&lt;/li&gt;
&lt;li&gt;여러분 회사의 진위 출처 디렉터리 서비스도 연결 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;세분화된 권한 부여&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;게이트웨이는 상당히 효과적인 큰 단위의 인증 기능을 제공하는 것이 가능&lt;/li&gt;
&lt;li&gt;로그인이 안 된 사용자의 헬프데스크 애플리케이션에 대한 접근을 차단할 수 있음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특정 자원 또는 엔드포인트에 대한 접근의 허용 여부는 마이크로서비스 자체에 맡겨야 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 행동의 허용 여부는 마이크로서비스가 더 많이 결정해야 할 필요가 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HTTP(S) 기본 인증&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP Basic Authentication은 클라이언트가 사용자 이름과 패스워드를 표준 HTTP헤더에 넣어서 전송&lt;/li&gt;
&lt;li&gt;서버는 상세 내용을 확인하고 클라이언트의 서비스 접근 허용 여부를 승인&lt;/li&gt;
&lt;li&gt;하지만, &lt;strong&gt;안전한 방식으로 사용자 이름과 패스워드를 전송할 수 없으므로 문제가 많음&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;네트워크상의 어떠한 중간자도 헤더 정보와 데이터를 볼 수 있으므로 HTTP 기본 인증은 대개 HTTPS 상에서 수행되어야 함&lt;/li&gt;
&lt;li&gt;HTTPS를 사용하면 클라이언트는 통신하고 서버가 자신이 생각하는 그 서버라는 확실한 보장을 받고&lt;/li&gt;
&lt;li&gt;클라이언트와 서버 간의 트래픽을 도청하거나 페이로 조작을 막는 추가적인 보호도 받음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SAML 또는 OpenID Connect 사용하기&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;게이트웨이를 사용하고 있다면 네트워크 내부의 트래픽을 게이트웨이로 라우팅해야겠지만&lt;/li&gt;
&lt;li&gt;만약 개별 서비스가 직접 서비스 간 통합을 처리한다면 이 라우팅을 기본적으로 지원해야 함&lt;/li&gt;
&lt;li&gt;기존의 인프라스트럭처를 사용할 수 있고 모든 서비스의 접근 통제를 중앙의 디렉터리 서버에 모아서 처리할 수 있음&lt;/li&gt;
&lt;li&gt;중간자 공격을 피하고자 한다면 여전히 HTTPS 상에서 라우팅해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;클라이언트 인증서&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트의 신원 확인을 위한 또 다른 방법은 (SSL의 계승자인) 클라이언트 인증서 형태의 전송 계층 보안(TLS/Transport Layer Security) 기능을 이용하는 것&lt;/li&gt;
&lt;li&gt;클라이언트와 서버의 연결을 체결할 때 사용되는 X.509 인증서가 각 클라이언트에 설치되어 있으며,&lt;/li&gt;
&lt;li&gt;서버는 클라이언트 인증서의 진위를 검증하여 유효한 클라이언트인지 확실히 보장할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HTTP 기반의 HMAC&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS 트래픽이 서버에 부담을 줄 수 있고, HTTPS 트래픽은 캐시하기도 쉽지 않음&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;다른 대안은 OAuth 명세서 일부와 AWS S3 API에 의해 폭넓게 사용되는 해시 기반 메시징 코드(HMAC/hash-based messaging code)를 HTTP 요청의 서명에 사용하는 것&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HMAC 장점&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;HMAC에서 요청 메시지 바디는 비밀 키를 사용해서 해시되고 해시 결과는 요청과 함께 전송&lt;/li&gt;
&lt;li&gt;서버는 자신이 가진 비밀 키의 복제본을 사용해서 해시를 재생성&lt;/li&gt;
&lt;li&gt;1과 2가 일치한다면 서버는 그 요청을 수락&lt;/li&gt;
&lt;li&gt;누군가 중간에 요청을 변조한다면 해시는 일치하지 않을 것이고, 서버는 그 요청이 변조되었다는 것을 알 수 있음&lt;/li&gt;
&lt;li&gt;비밀 키는 절대 그 요청에 넣어 전송하지 않으므로 통신상에서 누출 될 수도 없음&lt;/li&gt;
&lt;li&gt;트래픽이 더 쉽게 캐쉬되고, 경우에 따라 다르겠지만 아마도 해시를 생성하는 부하가 HTTPS 트래픽을 처리하는 것보다 더 낮다는 추가 이점&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HMAC 단점&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;클라이언트와 서버 모두 어떤 방식으로든 통신해서 기밀을 공유해야 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;양단간에 하드코딩할 수 있지만 기밀이 누출된다면 접근을 차단하는 데 문제가 있음&lt;/li&gt;
&lt;li&gt;다른 대체 프로토콜을 통해 통신한다면 여러분은 그 프로토콜이 매우 안전하다는 것도 보장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;하나의 패턴이지 표준은 아니므로 다양한 구현 방법이 있음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그 결과 이 방법에 대한 공객적이며 가용한 양질의 구현체가 부족&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;제3자가 요청 내용을 조작하지 않았다는 것과 비밀 키 자체의 기밀성(전송하지 않으므로)만 보장하는 것&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;요청한 데이터는 네트워크상에서 스누핑하는 사람들에게 여전히 노출&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;API Key&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모든 공개 API는 API Key를 사용함&lt;/li&gt;
&lt;li&gt;API Key를 통해 서비스는 API 호출자를 인식할 수 있고 호출자의 능력에 제한을 둘 수 있음&lt;/li&gt;
&lt;li&gt;모두를 위한 서비스 품질을 유지하기 위해 특정 호출자에 대한 속도 제한을 할 수 있음&lt;/li&gt;
&lt;li&gt;일부 시스템은 하나의 공유 API Key를 이용해서 앞에서 설명한 HMAC과 유사한 방식을 사용&lt;/li&gt;
&lt;li&gt;더 일반적 방법은 공개 키와 개인키를 짝으로 사용하는 것&lt;/li&gt;
&lt;li&gt;전형적으로 사람들의 신원을 한 곳에서 관리하듯이 키도 한 곳에서 관리하는데 이 분야에서는 흔히 &lt;strong&gt;게이트웨이&lt;/strong&gt; 모델을 사용&lt;/li&gt;
&lt;li&gt;API key 기반의 인증은 SAML 핸드셰이킹 처리와 비교하면 훨씬 더 단순하고 직관적&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;네트워크 분리(망분리)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;마이크로서비스에서는 서비스들의 상호 통신 방법의 통제를 세분화하도록 서비스들을 다른 네트워크 세그먼트에 배치할 수 있음&lt;/li&gt;
&lt;li&gt;AWS는 가상 사설 클라우드(Virtual Private Cloud/VPC)를 자동적으로 프로비저닝하는 기능을 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_013_008.jpg&quot; alt=&quot;불행히도 안전하지 못한 뮤직코퍼레이션 아키텍처의 서브넷&quot;&gt;
&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_013_009.jpg&quot; alt=&quot;더 안전한 뮤직코페이션 시스템&quot;&gt;&lt;/p&gt;
&lt;h2&gt;10. 콘웨이의 법칙과 시스템 설계&lt;/h2&gt;
&lt;h3&gt;two-pizza team 법칙&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;팀의 규모가 피자 두판으로 식사를 마칠 수 없는 규모가 돼서는 안 된다&lt;/li&gt;
&lt;li&gt;넷플릭스는 아마존의 사례를 교훈삼아 처음부터 작고 독립적인 팀을 조직했고&lt;/li&gt;
&lt;li&gt;그 결과 독립적인 팀을 조직, 독립적인 서비스를 만들 수 있었음&lt;/li&gt;
&lt;li&gt;변경 속도에 최적화된 시스템 아키텍처를 확보할 수 있었음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;공유 서비스의 추진&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;소유권은 요구사항의 발굴에서부터 애플리케이션이 빌드, 배포, 유지보수에 이르는 모든 측면까지 확장&lt;/li&gt;
&lt;li&gt;마이크로서비스에서 더 만연한 모델로, 작은 팀이 작은 서비스를 소유하기 더 용이&lt;/li&gt;
&lt;li&gt;소유권 확대는 자율성 향상과 빠른 출시로 이어짐&lt;/li&gt;
&lt;li&gt;애플리케이션의 배포와 유지보수까지 한 팀이 책임지게 하면 그 보상으로 배포하기 쉬운 서비스가 만들어짐&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;방치된 서비스&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내부 오픈 소스 모델을 훌륭히 지원하기 위해 여러분은 몇 가지 도구가 필요&lt;/li&gt;
&lt;li&gt;pull 요청 또는 이와 유사한 기능을 가진 분산 버전 관리 도구는 필수&lt;/li&gt;
&lt;li&gt;탑재한 코드 리뷰 시스템이거나 아닐 수도 있지만 패치에 대한 인라인 코멘트는 매우 유용한 기능&lt;/li&gt;
&lt;li&gt;우리는 경계가 있는 콘텍스트 주위로 서비스의 경계선을 긋는다&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;다양한 기술 스택을 사용하는 폴리글랏 방식(polyglot approach)을 적용한 경우&lt;br&gt;
여러분 팀이 더 이상 그 기술 스택을 모른다면 방치된 서비스를(orphaned service) 변경하는 것은&lt;br&gt;
심각한 문제가 될 수 있음&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;11. 대규모 마이크로서비스&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;분산 컴퓨팅의 오류&lt;/strong&gt;&lt;br&gt;
분산 컴퓨팅에서 아키텍트나 설계자가 범하기 쉬운 7가지 가정을 소개했고,&lt;br&gt;
그 후 제임스 고슬링이 다른 오류를 추가해서 분산 컴퓨팅의 8가지 오류로 알려짐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;어떤 것이든 고장날 수 있다는 가정을 명심하는 것은 문제의 해결 방법을 다르게 생각하도록 만든다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;AntiFragile&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;넷플릭스는 안티프래질 조직의 개념을 형성&lt;/li&gt;
&lt;li&gt;넷플릭스가 전적으로 AWS 인프라스트럭처에 기반한다는 사실&lt;/li&gt;
&lt;li&gt;이 두 요소는 장애를 잘 수용해야 한다는 것을 의미, 장애를 일부러 유발&lt;/li&gt;
&lt;li&gt;구글은 매년 장애 복구 테스트(Disaster Recovery Test, DiRT) 훈련&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Chaos Monkey&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하루 중 특정 시간 동안 임의로 머신의 전원을 꺼버림&lt;/li&gt;
&lt;li&gt;실운영 환경에서 이런 사고의 발생 가능성을 인지하는 것은 시스템을 만드는 개발자들이 실제로 그 사고에 준비하게 만듬&lt;/li&gt;
&lt;li&gt;넷플릭스의 장애를 만드는 봇인 유인원 부대의 일부&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Chaos Gorilla&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전체 가용성 센터(AWS의 데이터 센터에 해당되는)를 검토하는 데 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Latency Monkey&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;머신 간의 느린 네트워크 접속 상황을 시뮬레이션 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Timeout&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모든 프로세스 경계 외부의 호출에 타임아웃을 넣고 항상 기본 타임아웃 시간을 설정할 것&lt;/li&gt;
&lt;li&gt;타임아웃 발생 시간을 로깅하고 어떤 일이 발생했는지 살펴보며 타임아웃을 적절히 변경할 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;하위 시스템이 실제로 다운될 때까지 얼마나 오래 기다릴 수 있을까?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;호출이 실패했다고 판단하는데 너무 오래 걸리면 전체 시스템이 느려질 수 있음&lt;/li&gt;
&lt;li&gt;혹은 너무 빨리 타임아웃하면 동작했을지도 모르는 호출을 실패로 고려할 것&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Circuit Breaker&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_013_010.jpg&quot; alt=&quot;Circuit Breaker&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가정마다 전련 급등으로부터 가전 기기를 보호하기 위한 회로 차단기(Circuit Breaker)&lt;/li&gt;
&lt;li&gt;회로 차단기의 구현 방법은 실패한 요청의 의미에 따라 다름&lt;/li&gt;
&lt;li&gt;HTTP 커넥션을 위한 차단기를 구현할 때는 타임아웃이나 5XX HTTP 응답 코드에 해당되는 호출 실패를 설정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;하위 자원이 다운되거나 타임아웃되거나 에러를 리턴할 때 특정 임계값에 도달 한 후 자동적으로 전송 트래픽을 중지시키고 신속히 실패하도록 만듬&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;정상으로 복구되었을 때 자동으로 재시작할 수 있음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;회로 차단기가 끊어진 동안 할 수 있는 옵션&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;요청을 큐에 넣어두고 나중에 처리하는 것&lt;/li&gt;
&lt;li&gt;비동기 작업의 일부로 작업을 수행한다면 효과적&lt;/li&gt;
&lt;li&gt;호출이 동기 체인의 일부분으로 수행되는 경우에는 빨리 실패하는 것이 더 나음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;격벽&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;소프트웨어 아키텍처 측면에서 고려할 수 있는 다양한 격벽이 있음&lt;/li&gt;
&lt;li&gt;각각의 하위 커넥션마다 다른 커넥션 풀을 사용해야 한다&lt;/li&gt;
&lt;li&gt;이것은 특정 하위 서비스가 느려지게 되더라도 그 서비스의 커넥션 풀에서만 영향을 받고 다른 호출은 정상 처리되는 것을 보장&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;우려되는 것을 분리하는 것도 격벽의 한 방법&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;얽혀 있는 기능을 분리된 마이크로서비스로 분해함으로써 한 지역의 장애가 다른 지역에 영향을 줄 가능성을 줄임&lt;br&gt;
&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_013_011.jpg&quot; alt=&quot;상관관계ID가 심어진 로그&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;SSL termination&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;분산기로 유입되는 HTTPS 커넥션을 HTTP 커넥션으로 변환해서 인스턴스에 전달&lt;/li&gt;
&lt;li&gt;과거에는 SSL을 관리하는 부하가 상당히 높아 이 변환 과정을 처리하는 부하 분산기&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;를 두는 것이 매우 유용했으나,&lt;/li&gt;
&lt;li&gt;요즘 이런 일은 인스턴스가 동작하는 개별 호스트를 셋업하는 것만큼 단순함&lt;/li&gt;
&lt;li&gt;HTTPS를 사용하는 것은 요청이 중간자 공격에 취약하지 않게 만들기 위한 것이므로,&lt;/li&gt;
&lt;li&gt;SSL 종단 기능을 사용하면 우리 자신을 잠재적으로 어느 정도 노출하는 것&lt;/li&gt;
&lt;li&gt;Virtual Local Area Network 안에 모든 마이크로서비스 인스턴스를 두는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ELB / Elastic Load Balancer&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;AWS는 HTTPS 종단 기능이 있는 부하 분산기를 ELB형태로 제공&lt;/li&gt;
&lt;li&gt;VLAN&lt;sup id=&quot;fnref-3&quot;&gt;&lt;a href=&quot;#fn-3&quot; class=&quot;footnote-ref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;을 구현하기 위해 AWS 보안 그룹이나 가상 사설 클라우드 (VPC/Virtual Private Cloud)를 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;데이터 확장&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Standby Replica Database&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;마스터 데이터베이스에 저장된 모든 데이터가 대기 복제 데이터베이스에 복사됨&lt;/li&gt;
&lt;li&gt;마스터 DB가 다운될 경우 데이터는 안전하지만,&lt;/li&gt;
&lt;li&gt;그렇더라도 마스터 DB를 백업으로 바꾸거나 레플리카를 마스터DB로 승격시키는 매커니즘 없이는 DB가용성을 얻을 수 없음&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_013_012.jpg&quot; alt=&quot;Replica&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;쓰기용 확장 - Sharding&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;샤딩을 통해 많은 DB Node를 가질 수 있음&lt;/li&gt;
&lt;li&gt;저장할 데이터의 일부를 가지고 해싱 함수를 통해 데이터의 키를 생성하며 해싱 함수의 결과인 그 키를 사용해서 저장할 장소를 얻음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MongoDB - Map/Reduce&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모든 샤드에 질의하고 싶다면 각각의 샤드에 질의하고 메모리에서 조인하거나 여러 데이터셋이 있는 다른 읽기 전용 저장소가 필요&lt;/li&gt;
&lt;li&gt;여러 샤드에 대한 잦은 질의는 캐시 결과를 사용해서 비동기적 매커니즘으로 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Casandra&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;백그라운드에서 데이터의 재조정을 수행하면서 라이브 시스템에 샤드 추가를 지원&lt;/li&gt;
&lt;li&gt;기존 클러스트에 샤드를 추가하는 것은 심약한 사람에게 맞지 않으므로 철저한 테스트를 잊지 말라&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Caching&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;연산의 이전 결과를 저장해서 연속된 요청은 재연산을 위한 시간과 자원의 소비 없이 저장되어 있는 값 사용 가능&lt;/li&gt;
&lt;li&gt;대개 캐싱은 결과를 더 빠르게 제공하기 위해 DB나 다른 서비스까지의 불필요한 왕복을 제거&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Client side Caching&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트가 새로운 복사본을 가져올 시점과 여부를 결정&lt;/li&gt;
&lt;li&gt;하위 서비스가 힌트를 제공하며 클라이언트는 그 응답을 통해 해야 할 것을 이해하고 새로운 요청의 시점과 여부를 알 수 있음&lt;/li&gt;
&lt;li&gt;네트워크 호출을 대폭 줄임&lt;/li&gt;
&lt;li&gt;서버의 하위 서비스에 대한 부하를 줄일 수 있는 가장 빠른 방법&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Proxy Caching&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트와 서버 사이에 프로식스를 배치하는 것&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reversed Proxy&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스퀴드, 바니시처럼 모든 HTTP Traffic을 캐시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CDN / Content Delivery Network&lt;/li&gt;
&lt;li&gt;클라이언트와 서버에 독립적&lt;/li&gt;
&lt;li&gt;기존 시스템에 캐싱을 추가하는 가장 간단한 방법&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Server side Caching&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;li&gt;Memcached&lt;/li&gt;
&lt;li&gt;In-memory Cache&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;+ Words&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;snooping&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;네트워크상의 정보를 획득하는 일련의 행위를 의미&lt;/li&gt;
&lt;li&gt;sniffing도 유사한 의미를 가지지만 주로 염탐하는 행위를 뜻함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PaaS/Platform as a Service&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서비스로서의 플랫폼, 대표적으로 Heroku&lt;/li&gt;
&lt;li&gt;Heroku는 서비스의 실행을 처리할 뿐만 아니라 아주 단순한 방식으로 데이터베이스와 같은 서비스도 지원&lt;/li&gt;
&lt;li&gt;애플리케이션의 용도를 기반으로 autoscale을 시도하려는 PasS를 많이 사용했었지만 그 결과는 좋지 않았음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;cascading failure/장애 전파&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;처음에 한 파트에서 발생한 장애가 연속하는 다른 파트에 장애를 촉발시키는 것&lt;/li&gt;
&lt;li&gt;상호 연결된 파트의 시스템에서 발생 할 수 있음&lt;/li&gt;
&lt;li&gt;이와 같은 장애는 전력 송출, 컴퓨터 네트워킹, 금융, 인체 시스템과 같은 다양한 종류의 시스템에서 발생 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Netflix&apos;s Hystrix&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;지연시간 및 장애 내성 로직을 추가하여 분산 환경 서비스들 간의 상호작용을 통제하는 라이브러리&lt;/li&gt;
&lt;li&gt;서비스 사이의 포인트를 격리하고 전파 장애를 막아 시스템의 회복력을 향상시킴&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Netflix&apos;s Suro&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;넷플릭스의 데이터 파이프라인 플랫폼&lt;/li&gt;
&lt;li&gt;사용자 행위의 데이터와 애플리케이션 로그처럼 보다 시스템 운영적인 데이터와 연관된 두 지표 모두를 처리하는 분명한 용도&lt;/li&gt;
&lt;li&gt;Apache Chukwa를 기반으로 자사의 분산된 애플리케이션 서버에서 쏟아지는 엄청난 데이터를 수집해서&lt;/li&gt;
&lt;li&gt;S3나 하둡 파일 시스템 같은 저장소에 저장하여 실시간 분석을 도와주는 오픈 소스 플랫폼&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;멱등성&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;연산이 연속적으로 여러 번 적용되더라도 첫 적용 후의 결과가 달라지지 않는 성질의 연산&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Swagger&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스웨거를 사용할 경우 API를 잘 기술하면 웹 브라우저를 통해 API 문서를 볼 수 있고 API와 상호 작용할 수 있는 웹 UI를 생성할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;LXC/Linux Container : 분리된 가상의 호스트를 구분하고 통제하기 위해 프로세스들을 위한 분리된 프로세스 공간을 생성 &lt;a href=&quot;/til#linux&quot; taget=&quot;_blank&quot;&gt;&gt;자세히 보기&lt;/a&gt;&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-2&quot;&gt;
&lt;p&gt;부하 분산. 부하 분산기 뒤에 마이크로서비스 인스턴스가 실행되는 여러 호스트를 배치하는 것으로 고용량 고비용의 하드웨어 장비에서 모드 프로식와 같은 소프트웨어 기반의 것까지 그 형태와 크기가 다양&lt;/p&gt;
&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-3&quot;&gt;
&lt;p&gt;VLAN. 가상 지역 네트워크로 외부와 격리되어 있어 외부의 요청은 라우터를 통해서만 유입된다. 이 경우에는 라우터가 SSL을 종단하는 부하 분산기가 되며 VLAN 외부의 커뮤니케이션은 HTTPS로 하지만 내부에서는 모두 HTTP를 사용.&lt;/p&gt;
&lt;a href=&quot;#fnref-3&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[마이크로서비스 아키텍처 구축(1) - MSA를 지탱하는 기본 개념]]></title><description><![CDATA[<blockquote>
<p>은총알은 없으니 경험이 많지 않거나 비즈니스 도메인에 대한 이해가 낮다면<br>
무리한 마이크로서비스의 도입보다는 모놀리스에서 시작해서 점진적으로 분해하는 것이 좋다.</p>
<ul>
<li>마이크로서비스 아키텍쳐 구축</li>
</ul>
</blockquote>
<h2>1. 마이크로서비스</h2>
<h3>Infrastructure automation</h3>
<ul>
<li>
<p>scale up/down</p>
<ul>
<li>수직 확장</li>
<li>머신 리소스(CPU, Memory, Storage)를 추가</li>
</ul>
</li>
<li>
<p>scale in/out</p>
<ul>
<li>수평 확장</li>
<li>시스템의 노드, 머신, 애플리케이션 등을 추가</li>
</ul>
</li>
</ul>
<blockquote>
<p>같은 이유로 변경되는 것들은 한데 모으고, 서로 다른 이유로 변경되는 것들은 분리하라.<br>
→ <em>Single Responsibility Principle / 단일 책임 원칙 ( 로버트 C, 마티 )</em></p>
</blockquote>
<h3>그렇다면 얼마나 작아야 작은 것일까?</h3>
<p><code>코드가 너무 크다고 느껴지지 않는 한 아마 아직까지는 충분히 작다</code></p>
<p>서로 독립적인 변경이 가능하고 소비자의 변경없이 배포할 수 있도록 서비스 사이의 모든 통신은 네트워크 호출을 통해 이루어진다.<br>
→ Application Programming Interface(API)</p>
<p>마이크로서비스 = 분산 시스템 + 서비스 지향 아키텍쳐(SOA, service-oriented architechture)<br>
마이크로서비스는 SOA에 대한 특정 접근법</p>
<ul>
<li>
<p><strong>서비스</strong></p>
<ul>
<li>완전히 분리된 운영시스템의 프로세스</li>
</ul>
</li>
<li>
<p><strong>모놀리식 시스템</strong></p>
<ul>
<li>장애 가능을 낮추기 위해 수많은 머신 상에서 실행되어야 하지만</li>
</ul>
</li>
<li>
<p><strong>마이크로서비스</strong></p>
<ul>
<li>서비스의 전체 장애를 차단하고 기능을 적절히 저하시키는 시스템을 구축할 수 있다</li>
</ul>
</li>
<li>
<p><strong>격벽/bulkhead</strong></p>
<ul>
<li>장애 전파를 막는 용도</li>
</ul>
</li>
</ul>
<h2>2. 진화적 아키텍트</h2>
<p>아키텍트는 구축하는 시스템의 품질 수준이나 동료들의 근무 조건, 변화에 대응하는 조직의 능력에 대해 그 어떤 다른 역할보다 직접적인 영향을 줄 수 있다.
그러나 우리는 이 역할에 대해 꽤 자주 오해하는 듯 하다, 어째서일까?</p>
<h3>넷플릭스</h3>
<ul>
<li>데이터 저장 기술을 대부분 카산드라로 통일</li>
<li>비록 모든 경우데 적합한 최선의 대응책은 아닐지라도,</li>
<li>
<p>넷플릭스는 카산드라와 관련된 도구 및 전문지식을 통해 얻는 가치야말로</p>
<ul>
<li>몇몇 특정 태스크에 더 적합할 수 있는 다수의 이종 플랫폼 확장을 지원하고 운영하는 것보다 더 중요하다고 생각</li>
</ul>
</li>
<li>넷플릭스는 확정성을 가장 중요한 요소로 생각하는 극단적인 사례일 수있지만, 그들의 생각을 이해할 수 있는 있을 것</li>
</ul>
<h3>코딩하는 아키텍트</h3>
<ul>
<li>아키텍트가 만들어내는 시스템을 개발자도 수용하기 원한다면 아키텍트는 그 같은 결정의 파급력을 이해할 수 있어야 한다.</li>
<li>이것은 적어도 아키텍트가 팀과 함께 시간을 보내고, 이상적으로는 팀과 함께 실제로 코딩하는 것을 의미한다. -> 짝 프로그래밍</li>
<li>아키텍트가 개발팀 옆에 있는 것이 얼마나 중요한지 아무리 강조해도 지나치지 않다.</li>
<li>이것은 진화를 하거나 단순히 코드를 리뷰하는 것보다 훨씬 효과적이다.</li>
</ul>
<h3>트레이드오프</h3>
<ul>
<li>시스템 설계상의 결정은 모두 트레이드오프</li>
<li>동시에 발생할 수 없어 한 목표를 택했다면 다른 것을 포기해야 하는 상층 관계에 있는 상황 또는 그 상황 사이의 균형을 의미</li>
</ul>
<h3>의사 결정을 프레이밍</h3>
<ul>
<li>성취해야 할 목표에 기반하여 일련의 원칙과 실천 사항을 정의하는 것으로 10개 미만이 좋음</li>
<li>헤로쿠의 12가지 요소 -> <a href="http://www.12factor.net" target="_blank">www.12factor.net</a></li>
</ul>
<h3>모니터링</h3>
<ul>
<li>서비스 간 경계를 넘어 시스템 상태를 일관되게 살펴볼 수 있어야 함</li>
<li>서비스 세부 상태가 아닌 시스템 전체 상태를 볼 수 있어야 함</li>
<li><strong>metric</strong> : 모든 서비스가 자기 상태와 일반적인 모니터링 관련지표를 동일한 방식으로 전송</li>
</ul>
<h3>핵심 요약</h3>
<ul>
<li>아키텍트는 많은 것에 대해 책임을 진다.</li>
<li>그들은 개발을 이끌 수 있는 일련의 원칙을 정하고,</li>
<li>원칙들이 조직의 전략과 일치하도록 보장할 뿐만 아니라</li>
<li>이 원칙들로 인해 개발자를 비참하게 만드는 실천 사항이 만들어지지 않도록 해야 한다.</li>
<li>최신 기술을 유지하고, 올바른 트레이드오프를 결정해야 한다. 이는 실로 엄청난 책임이다.</li>
<li>그뿐 아니라 아키텍트는 사람들과 함께 나아가야 한다.</li>
<li>즉, 함께 일하는 동료들이 의사 결정을 이해하고 수행할 수 있도록 참여시켜야 한다.</li>
<li>그리고 앞에서 언급한 것처럼 그들의 결정이 주는 파급력과 코드를 이해하기 위해 팀과 함께 시간을 보내야 한다.</li>
</ul>
<h2>3. 서비스 모델링하기</h2>
<h3>무엇이 좋은 서비스를 만드는가?</h3>
<blockquote>
<p>느슨한 결합(loose coupling)<br>
강한 응집력(high cohesion)</p>
</blockquote>
<p>과도한 커뮤니케이션은 잠재적인 성능 문제를 넘어 강한 결합을 초래 할 수 있음<br>
특정 행위를 변경하고자 할 때는 한 곳에서 변경하고 가능한 한 신속하게 릴리스할 수 있어야 함<br>
-> 서로 연관된 행위가 한 곳에 모이고, 다른 경계와는 가능한 한 느슨하게 소통할 수 있도록 우리 문제 영역내에서 경계를 찾자</p>
<h3>경계가 있는 콘텍스트(bounded context)</h3>
<ul>
<li>모든 도메인은 다수의 경계가 있는 콘텍스트로 구성</li>
<li>각 콘텍스트 내에는 외부와 통신할 필요가 없는 것뿐만 아니라</li>
<li>
<p>경계가 있는 다른 콘텍스트 외부와 공유되는 것</p>
<ul>
<li>경계가 있는 콘텍스트로 보이는 도메인 부분들을 생각해 볼 것</li>
</ul>
</li>
</ul>
<p>즉, <strong><em>콘텍스트는 우리가 이야기하는 도메인(domain)</em></strong> 이 되는 것 같다.</p>
<blockquote>
<ol>
<li>세포가 존재할 수 있는 이유는<br>
세포막이 새포 내부와 외부에 있는 것을 구분하고, 어떤 것을 통과시킬지 결정하기 때문<br>
(크으.. 명언이다)</li>
<li>재무부서는 창고 내부의 세부 업무에 대해 세세하게 알 필요는 없지만<br>
재고 수준에 따라 장부 업데이트를 해야하므로 창고가 갖는 재고 품목 정보가 필요<br>
재고 품목은 두 콘텍스트 간의 공유 모델이 됨</li>
</ol>
</blockquote>
<h3>같은 모델이지만 서로 다른 의미를 갖는 것</h3>
<ul>
<li>고객 콘텍스트에서의 반품은 창고 콘텍스트에서의 도착할 패키지와 재입고될 재고 품목을 의미함</li>
<li>하지만 재입고 요청은 창고 콘텍스트 내에서의 아주 내부적인 관심사일 뿐</li>
<li>
<p>이에 우리는 어떤 모델을 공유하고, 어떤 내부 표현을 공유하면 안 되는지 명확히 고려해야 함</p>
<ul>
<li>다른 콘텍스트와 강한 결합을 필할 수 있음</li>
</ul>
</li>
<li>
<p>조직 내에 존재하는 경계가 있는 콘텍스트에 관해 고민할 때는</p>
<ul>
<li>공유 데이터 관점이 아닌 나머지 도메인을 제공하는 콘텍스트의 능력 관점에서 봐야 함</li>
<li>이 콘텍스트는 무엇을 하는가?</li>
<li>그 일을 하기 위해 어떤 데이터가 필요한가?</li>
</ul>
</li>
</ul>
<h3>동일한 용어와 개념</h3>
<ul>
<li>비즈니스 도메인에 기반을 둔 소프트웨어 모델링은 경계가 있는 콘텍스트 개념에 멈춰서는 안 됨</li>
<li>조직 내에서 공유되는 동일한 용어와 개념은 인터페이스에 반영되어야 함</li>
<li><em>마이크로서비스 간에 전송되는 형태를 조직 간에 전송되는 형태와 동일시하는 것은 아주 유용</em></li>
</ul>
<h2>4. 통합</h2>
<p>우리 문제 영역에서 <em>느슨한 결합</em>과 <em>높은 응집력</em>의 이중 혜택을 가져다주는 접합부를 어떻게 찾는지 배웠다.<br>
개발자에 의한 변경은 때로 서비스 소비자측의 변경까지 초래하는 결과를 가져올 수 있지만, 가능하면 이러한 변경을 일으키지 않는 기술을 선택하고 싶을 것이다.<br>
서비스 통합에 필요한 좋은 기술을 선택하는 데 도움이 되는 몇 가지 지침이 있다.</p>
<blockquote>
<p>고객 생성은 단순한 CRUD 명령의 집합으로 간주될 수 있다.<br>
하지만 대부분의 시스템에서 그렇게 단순한 작업은 아니다.<br>
새로운 고객이 등록되면 금융 결제 또는 환영 이메일과 같은 부가적인 프로세스를 시작해야 하고,<br>
고객 정보를 변경하거나 삭제할 때는 또 다른 비즈니스 프로세스가 작동할 수 있다.</p>
</blockquote>
<ul>
<li>DB는 사실상 공유된 매우 큰 API로서 상당히 깨지기 쉬워, 대개 대규모의 회귀 테스트가 필요</li>
<li>시간이 지나도 서비스 내부 변경 방식에 관한 자율성을 서비스에 줄 수 있도록</li>
<li>소비자에게 서비스의 세부 구현이 은폐되기를 진심으로 원함</li>
<li>그렇지 않으면 느슨한 결합과는 영영 이별</li>
<li><strong>좋은 마이크로서비스의 핵심 원칙은 강한 응집력과 느슨한 결합</strong></li>
</ul>
<h3>동기 통신</h3>
<p>원격 서버에 대한 호출이 완료될 때까지 연산 작업이 중단</p>
<ul>
<li>언제 작업이 성공적으로 완료되었는지 알 수 있어서 추론하기 용이</li>
<li>요청/응답 스타일</li>
</ul>
<h3>요청/응답 스타일(request/response)</h3>
<p>동기 통신 방식과 명확히 일치하지만, 비동기 통신에서는 콜백을 활용하여 작동할 수 있음</p>
<h3>비동기 통신</h3>
<p>호출자는 작업이 완료되었다는 회신을 기다리지 않으며, 심지어는 작업의 완료 여부에 관심이 없을 때도 있음</p>
<ul>
<li>클라이언트와 서버 간에 오랫동안 접속을 유지하기 어려운 장기 작업에 유용</li>
<li>결과를 기다리는 동안 중단된 호출이 성능 저하를 일으키는 곳에서 짧은 지연시간이 필요할 때 적합</li>
<li>이벤트 기반 협업</li>
</ul>
<h3>이벤트 기반 협업</h3>
<ul>
<li>클라이언트는 완료되어야 할 작업을 요청하는 대신 이벤트가 발생했음을 알리고 다른 당사자들이 무엇을 해야 할지 알기 기대함</li>
<li>우리는 결코 다른 누구에게도 해야할 일을 말하지 않는 것</li>
<li>결합도가 매우 낮은 방식</li>
</ul>
<h3>오케스트레이션(orchestration) 방식</h3>
<p>오케스트라 지휘자처럼 프로세를 안내하고 구동하는 하나의 중앙 두뇌에 의존</p>
<ul>
<li>고객 서비스에 지나치게 많은 중앙 관리 권한이 부여되는 단점</li>
<li>웹 중간에서 허브가 되어 로직이 살아나는 중심점이 될 수 있음</li>
<li>이 방식은 빈약한 CRUD 기반의 서비스에 할 일을 지시하는 소수의 똑똑한 신과 같은 서비스를 낳음</li>
</ul>
<h3>REST - REpresentational State Transfer</h3>
<p>웹에서 영감을 얻은 아키텍쳐 방식으로 resource의 개념 이 가장 중요</p>
<ul>
<li>자원이 외부에 보여지는 방식과 내부에 저장되는 방식은 완전히 분리<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup></li>
<li>HTTP가 동사(verb)처럼 스펙의 일부로 우리에게 제공하는 몇몇 기능은 HTTP상의 REST를 쉽게 구현할 수 있게 함</li>
</ul>
<h3>HTTP</h3>
<p>자체적으로 REST 방식과 궁합이 맞는 유용한 기능들을 정의</p>
<ul>
<li>REST 아키텍처 방식은 실제로 메서드가 메서드가 모든 자원에 대해 같은 방식으로 동작</li>
<li>HTTP 사양서에는 우리가 사용할 수 있는 다수의 메서드가 정의 (GET/POST/PUT/DELETE 등)</li>
<li>GET : 멱등 방식등<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup>으로 자원을 추출</li>
<li>POST : 새로운 자원을 생성</li>
<li>JSON은 HTTP상에서 작동하는 대중적인 콘텐츠 타입</li>
</ul>
<h3>HATEOAS</h3>
<p><strong>H</strong>ypermedia <strong>A</strong>s <strong>T</strong>he <strong>E</strong>ngine <strong>O</strong>f <strong>A</strong>pplication <strong>S</strong>tatus<br>
클라이언트와 서버가 결합하지 않게 도와주는 또 다른 원칙인 애플리케이션 상태 엔진</p>
<ul>
<li>클라이언트가 다른 자원에 대한 링크를 통해 서버와 (잠재적으로 상태 변이를 초래하는) 상호작용을 한다는 것</li>
<li>어떤 URI를 요청했는지 알고 있으므로 서버 내 고객의 정확한 위치를 알 필요는 없음</li>
<li>대신 클라이언트는 필요한 것을 발견하기 위해 링크를 찾고 탐색</li>
</ul>
<pre><code>HTTP는 대규모 트래픽에는 적합할 수 있지만 TCP 또는 다른 네트워킹 기술 기반의 대체 프로토콜과 비교하면
낮은 지연시간이 필요한 통신에는 그다지 좋은 선택은 아님
</code></pre>
<h3>correlation ID/상관관계 ID</h3>
<p>적재적소에서 모니터링하고 프로세스 경계 요청을 추적할 수 있도록 상관관계 ID의 사용을 적극 검토</p>
<blockquote>
<p>고객 정보 변경에 관한 결정이 고객 서비스 외부에서 이뤄진다면 응집력을 잃은 것</p>
</blockquote>
<h3>Rx(Reactive Extension)</h3>
<p>반응형 확장 라이브러리</p>
<ul>
<li>Observer pattern에 기반을 두고 설계됨</li>
<li>관찰 대상 순서를 이용하여 비동기 이벤트 기반의 반응형 프로그래밍을 지원하는 라이브러리</li>
<li>다수의 호출 결과를 조회하고 그 결과에 따라 연산을 실행하는 메커니즘</li>
<li>이들 호추른 그 자체로 blocking or nonblocking 호출이 될 수 있음</li>
<li>하위 서비스에 대해 동시에 발생하는 호출들을 훨씬 쉽게 처리하면서 다수의 호출을 함께 조립할 수 있다는 것</li>
</ul>
<p>내부적으로 Rx는 전통적인 흐름을 뒤집음</p>
<ul>
<li>데이터를 요청하는 대신 데이터에 대한 연산을 수행, 그 연산(또는 연산의 집합)의 결과를 관찰, 변경에 따라 반응</li>
<li>일부 Rx 구현제를 통해 관찰 대상의 함수를 수행 할 수 있음</li>
<li>RxJava에서는 map과 filter같은 전통적인 함수가 수행 될 수 있음</li>
</ul>
<blockquote>
<p>여러분 시스템의 도처에 있는 중복된 행위를 변경하려 할 때 모든 것을 제대로 변경하기 어렵고 이는 버그로 이어질 수 있다.<br>
따라서 일반적으로 DRY를 기도문으로 사용하는 것도 일리가 있다.</p>
</blockquote>
<h3>DRY(Don't Repeat Yourself)</h3>
<p>중복된 코드를 회피하는 시도로 단순하게 정의되지만, 더 명확하게 정의하자면 시스템의 행동양식과 지식의 중복을 회피하는 모든 시도</p>
<ul>
<li>반드시 피해야 할 위험 중 하나는 마이크로서비스와 소비자 간의 지나친 결합</li>
<li>마이크로서비스 자체의 작은 변경 사항 하나가 많은 소비자에게 불필요한 변경을 초래 할 수 있음</li>
<li>공유 코드의 사용이 이러한 결합을 만듬</li>
</ul>
<p>공유 코드를 서비스 경계를 넘어서 사용한다면 잠재적인 결합의 문제를 안고 있는 셈</p>
<ul>
<li>하지만 로깅 라이브러리와 같은 공통 코드는 외부에서는 보이지 않는 내부의 개념이므로 사용해도 문제 없음</li>
<li>코드를 공유하기보다는 결합이 생기지 않도록 그 템플릿을 새로운 서비스마다 복사</li>
</ul>
<h3>Semantic versioning</h3>
<p>유의적 버전 관리. 클라이언트가 서비스의 버전 번호만 보고도 해당 서비스와 통합 가능한지 알 수 있는 명세<br>
<strong>MAJOR.MINOR.PATCH</strong> 형태</p>
<ul>
<li>MAJOR : 하위 호환성이 깨진 변경이 발생 했음</li>
<li>MINOR : 하위 호환성을 유지하면서 새로운 기능들이 추가되었음</li>
<li>PATCH : 기존 기능의 버그를 수정했다는 것을 의미</li>
</ul>
<h3>다수의 병행 서비스 버전 사용하기</h3>
<p>다양한 버전의 서비스를 동시에 실행하고, 구 소비자의 트래픽을 구버전에, 신규 소비자의 신버전에 라우팅하는 것<br>
<strong>단점</strong></p>
<ul>
<li>한 서비스의 내부 버그를 고치려면 두 벌의 서로 다른 서비스를 수정하고 배포해야 함</li>
<li>소비자가 찾는 서비스로 유도하기 위한 부가적인 로직이 필요</li>
<li>서비스가 처리해야할 영속적 상태가 있는지 고려</li>
</ul>
<h3>API Gateway</h3>
<ul>
<li>클라이언트에 개별 서비스를 액세스할 수 있는 단일 접근 지점</li>
<li>클라이언트의 요청을 적절히 해당 서비스로 라우팅하거나 다양한 서비스로 분배</li>
<li>클라이언트에 최적화된 API를 제공하고, 클라이언트의 인증 및 접근 제어를 가능하게 함</li>
</ul>
<h3>UI 부분 구성</h3>
<ul>
<li>큰 단위의 UI 부분은 서버 측 애플리케이션으로부터 제공, 적절한 API 호출을 수행</li>
<li>UI 부분이 팀의 소유권과 완전히 일치할 때 가장 잘 작동</li>
<li>예로, 뮤직 쇼핑몰에서 주문 관리를 담다하는 팀은 주문 관리와 연관된 모든 페이지를 구성해서 제공하는 것</li>
<li>그러나 <em>사용자 경험의 일관성 유지는 풀어야할 숙제</em></li>
</ul>
<h3>퍼사드 패턴(facade pattern)</h3>
<ul>
<li>외부에 대한 내부 콘텐트 서비스를 추상황하는 용도로 쓰임</li>
<li>SOA 또는 Design Pattern에서는 이를 Service Facade 또는 Facade Pattern이라고 부름</li>
<li><a href="https://ko.wikipedia.org/wiki/%ED%8D%BC%EC%82%AC%EB%93%9C_%ED%8C%A8%ED%84%B4">위키백과 - 퍼사드 패턴</a></li>
</ul>
<h3>통합과 관련된 여러 방안 정리</h3>
<ul>
<li>데이터베이스 통합은 최대한 피할 것</li>
<li>REST와 RPC의 장단점을 이해하고 요청/응답을 통합하는 좋은 출발점으로 REST를 고려</li>
<li>오케스트레이션보다는 코레오그래피를 우선</li>
<li>포스텔의 법칙을 이해하고 관대한 독자 패턴을 사용해서 호환성을 깨트리는 변경과 불필요한 버전을 피할 것</li>
<li>구성 꼐층으로서의 사용자 인터페이스를 고려</li>
</ul>
<h2>5. 모놀리스 분해하기</h2>
<blockquote>
<p>모놀리스는 시간이 흐르면서 자라나고,<br>
빠른 속도로 새로운 기능과 코드 라인을 요구하며,<br>
머지않아 조직 내 사람들이 건드리거나 바꾸기를 두려워하는 거대하고 무서운 존재가 된다.</p>
</blockquote>
<h3>좋은 접합부란?</h3>
<ul>
<li>경계가 있는 콘텍스트(bounded context)</li>
<li>조직 내의 응집력 있고, 느슨히 결합된 경계를 잘 표현</li>
</ul>
<h3>리팩토링</h3>
<ul>
<li>현대적 IDE에서 코드 이동은 리팩토링 기능을 통해 다른 작업 중에 자동적이고 점진적으로 이뤄질 수 있음</li>
<li>하지만 코드 이동에 따른 오류를 잡아내기 위해 여전히 테스트가 필요</li>
<li>시간이 지나면서 우리는 잘 어울려 남아 있는 코드와 그렇지 못한 코드를 알아가기 시작</li>
<li>
<p>대게 끝까지 생존한 코드가 우리가 간과했을지 모를 경계가 있는 콘텍스트로 인식될 수 있음</p>
<ul>
<li>서비스를 분리하기 전에 모든 코드를 도메인에 따라 나눠진 패키지들에 따라 정렬할 필요는 없다</li>
<li>한번에 모든 것을 바꾸려는 빅뱅(Big-bang) 접근법을 취할 필요는 없고, 이 과정을 천천히 조금씩 진행되는 것으로 인식</li>
<li>뒤엉킨 모든 의존성의 출처가 대게 데이터베이스라는 것</li>
</ul>
</li>
</ul>
<h3>외부 키 관계 깨뜨리기</h3>
<ul>
<li>특정 콘텍스트의 코드 내에 데이터베이스 맵핑 코드를 함께 배치하면 어떤 코드가 데이터베이스의 어느 부분을 사용하는지 이해할 수 있음</li>
<li>
<p>예를 들어 경계가 잇는 콘텍스트 단위의 맵핑 파일과 같은 것을 사용한다면 하이버네이트에서는 매우 명확</p>
<ul>
<li>스키마스파이(SchemaSpy) : 테이블 관계를 그래픽으로 표현하는 도구</li>
</ul>
</li>
<li>이 모든 것은 궁극적으로 서비스 경계로 확장될 수 있는 테이블 간의 결합을 이해하도록 해줌</li>
<li>보고서를 생성하기 위해 서로 다른 두 개의 데이터베이스에 호출해야 하는 것은 분명하며 옳은 것</li>
</ul>
<h3>공유 데이터 분리</h3>
<ul>
<li>각 패키지에 복제, 장기적으로 보면 그 테이블은 각 서비스 내부에서도 복제 될 수 있음</li>
<li>공유 정적 데이터를 코드로 다루는 것</li>
<li>서비스의 부분으로 배포되는 속성 파일에 저장되거나,</li>
<li>열거형 개체(enumeration)가 될 수 있음</li>
<li>동작 중인 데이터베이스 테이블을 변경하는 것보다 설정 파일을 변경하는 것이 용이하나 데이터 일관성에 대한 문제는 여전히 존재</li>
</ul>
<h3>트랜잭션의 경계</h3>
<ul>
<li>애플리케이션 코드를 완전히 불리하여 각각의 마이크로서비스로 만들기 전에,</li>
<li>서비스는 이전과 같이 하나로 유지한 채 우선 스키마 분리를 추천</li>
<li>서비스를 단계적으로 분리</li>
<li>연산의 일부를 큐나 로그 파일에 큐잉하여 나중에 재시도 할 수 있음</li>
</ul>
<p><strong>보상 트랜잭션(compensating transaction)</strong></p>
<ul>
<li>직전의 트랜잭션을 되돌릴 새로운 트랜잭션을 발생시키는 것</li>
</ul>
<p><strong>분산 트랜잭션(distributed transaction)</strong></p>
<ul>
<li>보상 트랜잭션을 수동으로 통제하는 방식의 대안</li>
<li>2단계 커밋(two-phase commit)</li>
</ul>
<h3>리포팅 데이터베이스</h3>
<ul>
<li>일반적인 모놀리식 서비스 아키텍처에서 모든 데이터는 거대한 단일 데이터베이스에 저장됨</li>
<li>모든 데이터가 한 곳에 모여 있어서 모든 정보의 경계를 넘어서 리포팅하는 것이 실제로 매우 쉽다</li>
<li>SQL 질의와 그와 유사한 것들을 통해 데이터를 쉽게 조인할 수 있기 때문</li>
<li>리포팅 질의가 메인 시스템의 성능에 영향을 주는 것을 우려하여</li>
<li>리포트를 메인 데이터베이스에서 실행하지 않을 것</li>
<li>이에 리포팅 시스템은 대게 읽기용 복제 데이터베이스(read replica)에 연결됨</li>
</ul>
<h4>서비스 호출을 통한 데이터 추출</h4>
<ul>
<li>데이터베이스 스키마는 실행 중인 모놀리식 서비스와 리포팅 시스템 사이에서 사실상 공유 API임</li>
<li>스키마의 변경은 조심스럽게 관리되어야 하며, 실제로 이것은 스키마를 변경하고 조율할 기회를 줄이는 방해물</li>
<li>실제 시스템 또는 리포팅 시스템을 지원하는 사용 사례를 위해 데이터베이스를 최적하는 방법은 제한적</li>
<li>데이터 구조 변경이 실행 중인 시스템에 악영향을 주더라도 리포팅을 빠르게 하기 위해 데이터를 다르게 구성할 수 없음</li>
<li>스키마가 한 사용 사례에는 훌륭하게 들어맞지만 다른 사례에는 그렇지 못하거나 두 사례의 목적과 부합하지 않아 최소한의 공통분모만 가지게 되는 것</li>
<li>일반적인 관계형 데이터베이스가 많은 리포팅 도구와 호환되는 SQL 질의 인터페이스를 제공하더라도 동작 중인 서비스에 데이터를 저장하기 위한 최선의 방법은 아님</li>
</ul>
<h4>데이터 덤프</h4>
<ul>
<li>리포팅 시스템이 데이터를 끌어오는 방식 대신 리포팅 시스템에 데이터를 밀어 넣는 방식을 시도할 수 있다.</li>
<li>일반적인 HTTP 호출로 데이터를 추출하는 데 있어 단점 중 하나는 다수의 호출을 할 때 발생하는 HTTP의 부하고</li>
<li>리포팅 목적으로만 사용될지도 모르는 API를 만들어야 하는 부담이다.</li>
<li>같은 데이터의 소스인 서비스의 데이터베이스에 직접 접근하여 리포팅 데이터베이스로 밀어 넣는 독립 프로그램을 가지는 것</li>
</ul>
<br/>
<h5>데이터마트</h5>
<ul>
<li>AWS S3를 실제로 거대한 데이터 마트로 위장하며, JSON 파일을 S3에 저장하기 위해 데이터 펌프를 사용함</li>
<li>솔루션이 확장이 필요할 때까지 아주 효과가 있었고, 엑셀과 태블로 같은 표준 리포팅 도구와 통합할 수 있는 큐브를 채우도록 이 펌프들을 변경하는 것을 검토</li>
</ul>
<br/>
<h4>이벤트 데이터 펌프</h4>
<ul>
<li>고객 서비스가 상태가 바뀌면 상태 변이 이벤트가 발행되고 고객 리포팅 맵퍼를 통해 중앙의 리포팅 데이터베이스로 펌프 됨</li>
</ul>
<br/>
<h4>백업 데이터 펌프</h4>
<p><strong>넷플릭스</strong></p>
<ul>
<li>카산드라 데이터를 백업하기 위해 데이터 파일을 복사해서 안전한 곳에 저장</li>
<li>SStable로 알려져있는 이런 파일들을 S3 객체 저장소에 저장</li>
<li>이 백업된 데이터를 원본으로 사용하는 하둡을 통해 방대한 양의 데이터를 처리할 수 있는 파이프라인을 구현, 아이기스토스 프로젝트로 오픈소스화 됨</li>
<li>하지만 데이터 펌프처럼 이 백업 데이터 펌프 패턴 역시 리포팅 스키마와 결합</li>
</ul>
<h3>변경 비용</h3>
<ul>
<li>데이터베이스를 분리하는 것은 더 많은 작업이 필요</li>
<li>데이터베이스 변경을 되돌리는 것은 복잡한 일</li>
<li>서비스들이 지나치게 결합된 통합을 분리하는 것 또는 다수의 소비자가 사용하는 API를 완전히 재작성하는 것은 상당히 큰 작업</li>
<li>높은 비용이 드는 변경은 이들 작업이 점점 더 위험해진다는 것</li>
</ul>
<p><strong>화이트 보드</strong>를 활용하여 디자인을 스케치, 서비스 경계를 넘어 실행할 때 어떤 일이 발생하는지 확인</p>
<ul>
<li>어떤 출이 발생하는가?</li>
<li>이상한 순환 참조를 볼 수 있는가?</li>
<li>지나치게 호출이 많은 두 서비스를 발견했는가?</li>
</ul>
<h2>+ Words</h2>
<ul>
<li>
<p><strong>코드베이스/codebase</strong></p>
<ul>
<li>소프트웨어 시스템, 애플리케이션, 컴포넌트를 빌드하는 데 사용되는 코드의 전체 집합</li>
<li>일반적으로 작성한 코드 파일</li>
</ul>
</li>
<li>
<p><strong>결함 감내 시스템/fault tolerant system</strong></p>
<ul>
<li>일부 장치나 서브시스템에 고장이나 오작동이 나타나면 시스템의 성능과 기능을 축소 구성하여 정지하지 않고도 동작을 유지하는 방식을 사용하고 있는데 이 방식을 단계별 성능 저하(graceful degradation)</li>
</ul>
</li>
<li>
<p><strong>팩토링/factoring - 분해/decomposition</strong></p>
<ul>
<li>이해하고, 작성하고, 유지하기 쉽도록 복잡한 문제와 시스템을 외부 동작의 변경 없이 부분으로 나누는 것</li>
</ul>
</li>
<li>
<p><strong>브르어(Brewer)의 정리</strong></p>
<ul>
<li>일관성/consistency</li>
<li>가용성/availability</li>
<li>분할 내성/partition tolerance</li>
<li>모두를 만족하는 분산 시스템이 존재하지 않음을 증명하는 정리</li>
</ul>
</li>
<li>
<p><strong>callback</strong></p>
<ul>
<li>다른 코드의 인수로 넘겨주는 실행 가능한 코드</li>
<li>콜백을 넘겨받는 코드는 이 콜백을 필요에 따라 즉시 실행할 수도 있고 나중에 실행할 수도 있음</li>
</ul>
</li>
<li>
<p><strong>원격 프로시저 호출(remote procedure call/RPC)</strong></p>
<ul>
<li>local call을 통해 원격 서비스를 실행하는 기술</li>
</ul>
</li>
<li>
<p><strong>load balancer</strong></p>
<ul>
<li>부하 분산기</li>
</ul>
</li>
<li>
<p><strong>payload</strong></p>
<ul>
<li>전송의 근본적인 목적이 되는 데이터의 일부분으로, 해당 데이터와 함께 전송되는 헤더와 메타데이터 등의 데이터는 제외</li>
</ul>
</li>
<li>
<p><strong>handshake</strong></p>
<ul>
<li>두 개체간의 정상 통신 전에 통신 채널의 파라미터를 설정하는 자동화된 협상 과정</li>
</ul>
</li>
<li>
<p><strong>tolerant reader pattern/관대한 독자 패턴</strong></p>
<ul>
<li>서비스 디자인 패턴 중의 하나</li>
<li>서비스 공급자가 제공한 메시지 포맷은 변경될 수 있음을 염두에 두고 메시지의 필요한 데이터만 추출하며 관련 없는 데이터는 무시해서 변경 결함을 피하게 함</li>
</ul>
</li>
<li>
<p><strong>RabbitMQ</strong></p>
<ul>
<li>AMQP 프로토콜을 구현한 오픈 소스 메시지 중개자 소프트웨어</li>
<li>얼랭 언어 기반으로 구현하여 클러스터링 등의 고급 기술과 다양한 언어의 클라이언트 라이브러리를 지원</li>
</ul>
</li>
<li>
<p><strong>Competing Consumer pattern</strong></p>
<ul>
<li>메시지를 위해 경쟁하는 다수의 작업자 인스턴스를 다루는 방법을 기술</li>
</ul>
</li>
<li>
<p><strong>bootstrapping</strong></p>
<ul>
<li>일반적으로 컴퓨터의 전원이 켜지거나 리셋된 후 외부 입력 없이 기본 소프트웨어를 메모리에 로드하여 독립 수행하는 과정</li>
</ul>
</li>
<li>
<p><strong>접합부</strong></p>
<ul>
<li>seam</li>
</ul>
</li>
<li>
<p><strong>structure101</strong></p>
<ul>
<li>애자일 아키텍처 개발 환경으로, 코드베이스의 구조화를 돕기 위해 다양한 IDE를 위한 플러그인을 제공</li>
</ul>
</li>
<li>
<p><strong>SKU(Stock Keeping Unit)</strong></p>
<ul>
<li>개별 상별 상품에 대해 재고 관리 목적으로 추적이 쉽도록 하기 위해 사용하는 식별 관리 코드</li>
</ul>
</li>
<li>
<p><strong>Cassandra</strong></p>
<ul>
<li>컬럼 지향 데이터베이스(column-oriented database)로 대용량 확장이 매우 용이한 리포팅 시스템에 적합</li>
<li>컬럼 지향 데이터베이스는 데이터를 열 단위로 저장</li>
</ul>
</li>
</ul>
<div class="footnotes">
<hr>
<ol>
<li id="fn-1">
<p>다양한 REST 방식을 비교한 Richardson Maturity Model을 참고</p>
<a href="#fnref-1" class="footnote-backref">↩</a>
</li>
<li id="fn-2">
<p>동일하게 반복되는 요청에 결과가 달라지지 않는 성질</p>
<a href="#fnref-2" class="footnote-backref">↩</a>
</li>
</ol>
</div>]]></description><link>https://baek.dev/post/12/</link><guid isPermaLink="false">https://baek.dev/post/12/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Tue, 24 Dec 2019 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;은총알은 없으니 경험이 많지 않거나 비즈니스 도메인에 대한 이해가 낮다면&lt;br&gt;
무리한 마이크로서비스의 도입보다는 모놀리스에서 시작해서 점진적으로 분해하는 것이 좋다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;마이크로서비스 아키텍쳐 구축&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;1. 마이크로서비스&lt;/h2&gt;
&lt;h3&gt;Infrastructure automation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;scale up/down&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;수직 확장&lt;/li&gt;
&lt;li&gt;머신 리소스(CPU, Memory, Storage)를 추가&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;scale in/out&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;수평 확장&lt;/li&gt;
&lt;li&gt;시스템의 노드, 머신, 애플리케이션 등을 추가&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;같은 이유로 변경되는 것들은 한데 모으고, 서로 다른 이유로 변경되는 것들은 분리하라.&lt;br&gt;
→ &lt;em&gt;Single Responsibility Principle / 단일 책임 원칙 ( 로버트 C, 마티 )&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;그렇다면 얼마나 작아야 작은 것일까?&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;코드가 너무 크다고 느껴지지 않는 한 아마 아직까지는 충분히 작다&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;서로 독립적인 변경이 가능하고 소비자의 변경없이 배포할 수 있도록 서비스 사이의 모든 통신은 네트워크 호출을 통해 이루어진다.&lt;br&gt;
→ Application Programming Interface(API)&lt;/p&gt;
&lt;p&gt;마이크로서비스 = 분산 시스템 + 서비스 지향 아키텍쳐(SOA, service-oriented architechture)&lt;br&gt;
마이크로서비스는 SOA에 대한 특정 접근법&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;서비스&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;완전히 분리된 운영시스템의 프로세스&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;모놀리식 시스템&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장애 가능을 낮추기 위해 수많은 머신 상에서 실행되어야 하지만&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;마이크로서비스&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서비스의 전체 장애를 차단하고 기능을 적절히 저하시키는 시스템을 구축할 수 있다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;격벽/bulkhead&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장애 전파를 막는 용도&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2. 진화적 아키텍트&lt;/h2&gt;
&lt;p&gt;아키텍트는 구축하는 시스템의 품질 수준이나 동료들의 근무 조건, 변화에 대응하는 조직의 능력에 대해 그 어떤 다른 역할보다 직접적인 영향을 줄 수 있다.
그러나 우리는 이 역할에 대해 꽤 자주 오해하는 듯 하다, 어째서일까?&lt;/p&gt;
&lt;h3&gt;넷플릭스&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터 저장 기술을 대부분 카산드라로 통일&lt;/li&gt;
&lt;li&gt;비록 모든 경우데 적합한 최선의 대응책은 아닐지라도,&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;넷플릭스는 카산드라와 관련된 도구 및 전문지식을 통해 얻는 가치야말로&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;몇몇 특정 태스크에 더 적합할 수 있는 다수의 이종 플랫폼 확장을 지원하고 운영하는 것보다 더 중요하다고 생각&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;넷플릭스는 확정성을 가장 중요한 요소로 생각하는 극단적인 사례일 수있지만, 그들의 생각을 이해할 수 있는 있을 것&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;코딩하는 아키텍트&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;아키텍트가 만들어내는 시스템을 개발자도 수용하기 원한다면 아키텍트는 그 같은 결정의 파급력을 이해할 수 있어야 한다.&lt;/li&gt;
&lt;li&gt;이것은 적어도 아키텍트가 팀과 함께 시간을 보내고, 이상적으로는 팀과 함께 실제로 코딩하는 것을 의미한다. -&gt; 짝 프로그래밍&lt;/li&gt;
&lt;li&gt;아키텍트가 개발팀 옆에 있는 것이 얼마나 중요한지 아무리 강조해도 지나치지 않다.&lt;/li&gt;
&lt;li&gt;이것은 진화를 하거나 단순히 코드를 리뷰하는 것보다 훨씬 효과적이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;트레이드오프&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시스템 설계상의 결정은 모두 트레이드오프&lt;/li&gt;
&lt;li&gt;동시에 발생할 수 없어 한 목표를 택했다면 다른 것을 포기해야 하는 상층 관계에 있는 상황 또는 그 상황 사이의 균형을 의미&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;의사 결정을 프레이밍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;성취해야 할 목표에 기반하여 일련의 원칙과 실천 사항을 정의하는 것으로 10개 미만이 좋음&lt;/li&gt;
&lt;li&gt;헤로쿠의 12가지 요소 -&gt; &lt;a href=&quot;http://www.12factor.net&quot; target=&quot;_blank&quot;&gt;www.12factor.net&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;모니터링&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;서비스 간 경계를 넘어 시스템 상태를 일관되게 살펴볼 수 있어야 함&lt;/li&gt;
&lt;li&gt;서비스 세부 상태가 아닌 시스템 전체 상태를 볼 수 있어야 함&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;metric&lt;/strong&gt; : 모든 서비스가 자기 상태와 일반적인 모니터링 관련지표를 동일한 방식으로 전송&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;핵심 요약&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;아키텍트는 많은 것에 대해 책임을 진다.&lt;/li&gt;
&lt;li&gt;그들은 개발을 이끌 수 있는 일련의 원칙을 정하고,&lt;/li&gt;
&lt;li&gt;원칙들이 조직의 전략과 일치하도록 보장할 뿐만 아니라&lt;/li&gt;
&lt;li&gt;이 원칙들로 인해 개발자를 비참하게 만드는 실천 사항이 만들어지지 않도록 해야 한다.&lt;/li&gt;
&lt;li&gt;최신 기술을 유지하고, 올바른 트레이드오프를 결정해야 한다. 이는 실로 엄청난 책임이다.&lt;/li&gt;
&lt;li&gt;그뿐 아니라 아키텍트는 사람들과 함께 나아가야 한다.&lt;/li&gt;
&lt;li&gt;즉, 함께 일하는 동료들이 의사 결정을 이해하고 수행할 수 있도록 참여시켜야 한다.&lt;/li&gt;
&lt;li&gt;그리고 앞에서 언급한 것처럼 그들의 결정이 주는 파급력과 코드를 이해하기 위해 팀과 함께 시간을 보내야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3. 서비스 모델링하기&lt;/h2&gt;
&lt;h3&gt;무엇이 좋은 서비스를 만드는가?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;느슨한 결합(loose coupling)&lt;br&gt;
강한 응집력(high cohesion)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;과도한 커뮤니케이션은 잠재적인 성능 문제를 넘어 강한 결합을 초래 할 수 있음&lt;br&gt;
특정 행위를 변경하고자 할 때는 한 곳에서 변경하고 가능한 한 신속하게 릴리스할 수 있어야 함&lt;br&gt;
-&gt; 서로 연관된 행위가 한 곳에 모이고, 다른 경계와는 가능한 한 느슨하게 소통할 수 있도록 우리 문제 영역내에서 경계를 찾자&lt;/p&gt;
&lt;h3&gt;경계가 있는 콘텍스트(bounded context)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;모든 도메인은 다수의 경계가 있는 콘텍스트로 구성&lt;/li&gt;
&lt;li&gt;각 콘텍스트 내에는 외부와 통신할 필요가 없는 것뿐만 아니라&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;경계가 있는 다른 콘텍스트 외부와 공유되는 것&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;경계가 있는 콘텍스트로 보이는 도메인 부분들을 생각해 볼 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;즉, &lt;strong&gt;&lt;em&gt;콘텍스트는 우리가 이야기하는 도메인(domain)&lt;/em&gt;&lt;/strong&gt; 이 되는 것 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;세포가 존재할 수 있는 이유는&lt;br&gt;
세포막이 새포 내부와 외부에 있는 것을 구분하고, 어떤 것을 통과시킬지 결정하기 때문&lt;br&gt;
(크으.. 명언이다)&lt;/li&gt;
&lt;li&gt;재무부서는 창고 내부의 세부 업무에 대해 세세하게 알 필요는 없지만&lt;br&gt;
재고 수준에 따라 장부 업데이트를 해야하므로 창고가 갖는 재고 품목 정보가 필요&lt;br&gt;
재고 품목은 두 콘텍스트 간의 공유 모델이 됨&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3&gt;같은 모델이지만 서로 다른 의미를 갖는 것&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;고객 콘텍스트에서의 반품은 창고 콘텍스트에서의 도착할 패키지와 재입고될 재고 품목을 의미함&lt;/li&gt;
&lt;li&gt;하지만 재입고 요청은 창고 콘텍스트 내에서의 아주 내부적인 관심사일 뿐&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이에 우리는 어떤 모델을 공유하고, 어떤 내부 표현을 공유하면 안 되는지 명확히 고려해야 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다른 콘텍스트와 강한 결합을 필할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;조직 내에 존재하는 경계가 있는 콘텍스트에 관해 고민할 때는&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;공유 데이터 관점이 아닌 나머지 도메인을 제공하는 콘텍스트의 능력 관점에서 봐야 함&lt;/li&gt;
&lt;li&gt;이 콘텍스트는 무엇을 하는가?&lt;/li&gt;
&lt;li&gt;그 일을 하기 위해 어떤 데이터가 필요한가?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;동일한 용어와 개념&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;비즈니스 도메인에 기반을 둔 소프트웨어 모델링은 경계가 있는 콘텍스트 개념에 멈춰서는 안 됨&lt;/li&gt;
&lt;li&gt;조직 내에서 공유되는 동일한 용어와 개념은 인터페이스에 반영되어야 함&lt;/li&gt;
&lt;li&gt;&lt;em&gt;마이크로서비스 간에 전송되는 형태를 조직 간에 전송되는 형태와 동일시하는 것은 아주 유용&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;4. 통합&lt;/h2&gt;
&lt;p&gt;우리 문제 영역에서 &lt;em&gt;느슨한 결합&lt;/em&gt;과 &lt;em&gt;높은 응집력&lt;/em&gt;의 이중 혜택을 가져다주는 접합부를 어떻게 찾는지 배웠다.&lt;br&gt;
개발자에 의한 변경은 때로 서비스 소비자측의 변경까지 초래하는 결과를 가져올 수 있지만, 가능하면 이러한 변경을 일으키지 않는 기술을 선택하고 싶을 것이다.&lt;br&gt;
서비스 통합에 필요한 좋은 기술을 선택하는 데 도움이 되는 몇 가지 지침이 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;고객 생성은 단순한 CRUD 명령의 집합으로 간주될 수 있다.&lt;br&gt;
하지만 대부분의 시스템에서 그렇게 단순한 작업은 아니다.&lt;br&gt;
새로운 고객이 등록되면 금융 결제 또는 환영 이메일과 같은 부가적인 프로세스를 시작해야 하고,&lt;br&gt;
고객 정보를 변경하거나 삭제할 때는 또 다른 비즈니스 프로세스가 작동할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;DB는 사실상 공유된 매우 큰 API로서 상당히 깨지기 쉬워, 대개 대규모의 회귀 테스트가 필요&lt;/li&gt;
&lt;li&gt;시간이 지나도 서비스 내부 변경 방식에 관한 자율성을 서비스에 줄 수 있도록&lt;/li&gt;
&lt;li&gt;소비자에게 서비스의 세부 구현이 은폐되기를 진심으로 원함&lt;/li&gt;
&lt;li&gt;그렇지 않으면 느슨한 결합과는 영영 이별&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;좋은 마이크로서비스의 핵심 원칙은 강한 응집력과 느슨한 결합&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;동기 통신&lt;/h3&gt;
&lt;p&gt;원격 서버에 대한 호출이 완료될 때까지 연산 작업이 중단&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;언제 작업이 성공적으로 완료되었는지 알 수 있어서 추론하기 용이&lt;/li&gt;
&lt;li&gt;요청/응답 스타일&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;요청/응답 스타일(request/response)&lt;/h3&gt;
&lt;p&gt;동기 통신 방식과 명확히 일치하지만, 비동기 통신에서는 콜백을 활용하여 작동할 수 있음&lt;/p&gt;
&lt;h3&gt;비동기 통신&lt;/h3&gt;
&lt;p&gt;호출자는 작업이 완료되었다는 회신을 기다리지 않으며, 심지어는 작업의 완료 여부에 관심이 없을 때도 있음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트와 서버 간에 오랫동안 접속을 유지하기 어려운 장기 작업에 유용&lt;/li&gt;
&lt;li&gt;결과를 기다리는 동안 중단된 호출이 성능 저하를 일으키는 곳에서 짧은 지연시간이 필요할 때 적합&lt;/li&gt;
&lt;li&gt;이벤트 기반 협업&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;이벤트 기반 협업&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트는 완료되어야 할 작업을 요청하는 대신 이벤트가 발생했음을 알리고 다른 당사자들이 무엇을 해야 할지 알기 기대함&lt;/li&gt;
&lt;li&gt;우리는 결코 다른 누구에게도 해야할 일을 말하지 않는 것&lt;/li&gt;
&lt;li&gt;결합도가 매우 낮은 방식&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;오케스트레이션(orchestration) 방식&lt;/h3&gt;
&lt;p&gt;오케스트라 지휘자처럼 프로세를 안내하고 구동하는 하나의 중앙 두뇌에 의존&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;고객 서비스에 지나치게 많은 중앙 관리 권한이 부여되는 단점&lt;/li&gt;
&lt;li&gt;웹 중간에서 허브가 되어 로직이 살아나는 중심점이 될 수 있음&lt;/li&gt;
&lt;li&gt;이 방식은 빈약한 CRUD 기반의 서비스에 할 일을 지시하는 소수의 똑똑한 신과 같은 서비스를 낳음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;REST - REpresentational State Transfer&lt;/h3&gt;
&lt;p&gt;웹에서 영감을 얻은 아키텍쳐 방식으로 resource의 개념 이 가장 중요&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자원이 외부에 보여지는 방식과 내부에 저장되는 방식은 완전히 분리&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;HTTP가 동사(verb)처럼 스펙의 일부로 우리에게 제공하는 몇몇 기능은 HTTP상의 REST를 쉽게 구현할 수 있게 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;HTTP&lt;/h3&gt;
&lt;p&gt;자체적으로 REST 방식과 궁합이 맞는 유용한 기능들을 정의&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;REST 아키텍처 방식은 실제로 메서드가 메서드가 모든 자원에 대해 같은 방식으로 동작&lt;/li&gt;
&lt;li&gt;HTTP 사양서에는 우리가 사용할 수 있는 다수의 메서드가 정의 (GET/POST/PUT/DELETE 등)&lt;/li&gt;
&lt;li&gt;GET : 멱등 방식등&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;으로 자원을 추출&lt;/li&gt;
&lt;li&gt;POST : 새로운 자원을 생성&lt;/li&gt;
&lt;li&gt;JSON은 HTTP상에서 작동하는 대중적인 콘텐츠 타입&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;HATEOAS&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;H&lt;/strong&gt;ypermedia &lt;strong&gt;A&lt;/strong&gt;s &lt;strong&gt;T&lt;/strong&gt;he &lt;strong&gt;E&lt;/strong&gt;ngine &lt;strong&gt;O&lt;/strong&gt;f &lt;strong&gt;A&lt;/strong&gt;pplication &lt;strong&gt;S&lt;/strong&gt;tatus&lt;br&gt;
클라이언트와 서버가 결합하지 않게 도와주는 또 다른 원칙인 애플리케이션 상태 엔진&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트가 다른 자원에 대한 링크를 통해 서버와 (잠재적으로 상태 변이를 초래하는) 상호작용을 한다는 것&lt;/li&gt;
&lt;li&gt;어떤 URI를 요청했는지 알고 있으므로 서버 내 고객의 정확한 위치를 알 필요는 없음&lt;/li&gt;
&lt;li&gt;대신 클라이언트는 필요한 것을 발견하기 위해 링크를 찾고 탐색&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;HTTP는 대규모 트래픽에는 적합할 수 있지만 TCP 또는 다른 네트워킹 기술 기반의 대체 프로토콜과 비교하면
낮은 지연시간이 필요한 통신에는 그다지 좋은 선택은 아님
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;correlation ID/상관관계 ID&lt;/h3&gt;
&lt;p&gt;적재적소에서 모니터링하고 프로세스 경계 요청을 추적할 수 있도록 상관관계 ID의 사용을 적극 검토&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;고객 정보 변경에 관한 결정이 고객 서비스 외부에서 이뤄진다면 응집력을 잃은 것&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Rx(Reactive Extension)&lt;/h3&gt;
&lt;p&gt;반응형 확장 라이브러리&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Observer pattern에 기반을 두고 설계됨&lt;/li&gt;
&lt;li&gt;관찰 대상 순서를 이용하여 비동기 이벤트 기반의 반응형 프로그래밍을 지원하는 라이브러리&lt;/li&gt;
&lt;li&gt;다수의 호출 결과를 조회하고 그 결과에 따라 연산을 실행하는 메커니즘&lt;/li&gt;
&lt;li&gt;이들 호추른 그 자체로 blocking or nonblocking 호출이 될 수 있음&lt;/li&gt;
&lt;li&gt;하위 서비스에 대해 동시에 발생하는 호출들을 훨씬 쉽게 처리하면서 다수의 호출을 함께 조립할 수 있다는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;내부적으로 Rx는 전통적인 흐름을 뒤집음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터를 요청하는 대신 데이터에 대한 연산을 수행, 그 연산(또는 연산의 집합)의 결과를 관찰, 변경에 따라 반응&lt;/li&gt;
&lt;li&gt;일부 Rx 구현제를 통해 관찰 대상의 함수를 수행 할 수 있음&lt;/li&gt;
&lt;li&gt;RxJava에서는 map과 filter같은 전통적인 함수가 수행 될 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;여러분 시스템의 도처에 있는 중복된 행위를 변경하려 할 때 모든 것을 제대로 변경하기 어렵고 이는 버그로 이어질 수 있다.&lt;br&gt;
따라서 일반적으로 DRY를 기도문으로 사용하는 것도 일리가 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;DRY(Don&apos;t Repeat Yourself)&lt;/h3&gt;
&lt;p&gt;중복된 코드를 회피하는 시도로 단순하게 정의되지만, 더 명확하게 정의하자면 시스템의 행동양식과 지식의 중복을 회피하는 모든 시도&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;반드시 피해야 할 위험 중 하나는 마이크로서비스와 소비자 간의 지나친 결합&lt;/li&gt;
&lt;li&gt;마이크로서비스 자체의 작은 변경 사항 하나가 많은 소비자에게 불필요한 변경을 초래 할 수 있음&lt;/li&gt;
&lt;li&gt;공유 코드의 사용이 이러한 결합을 만듬&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;공유 코드를 서비스 경계를 넘어서 사용한다면 잠재적인 결합의 문제를 안고 있는 셈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하지만 로깅 라이브러리와 같은 공통 코드는 외부에서는 보이지 않는 내부의 개념이므로 사용해도 문제 없음&lt;/li&gt;
&lt;li&gt;코드를 공유하기보다는 결합이 생기지 않도록 그 템플릿을 새로운 서비스마다 복사&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Semantic versioning&lt;/h3&gt;
&lt;p&gt;유의적 버전 관리. 클라이언트가 서비스의 버전 번호만 보고도 해당 서비스와 통합 가능한지 알 수 있는 명세&lt;br&gt;
&lt;strong&gt;MAJOR.MINOR.PATCH&lt;/strong&gt; 형태&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MAJOR : 하위 호환성이 깨진 변경이 발생 했음&lt;/li&gt;
&lt;li&gt;MINOR : 하위 호환성을 유지하면서 새로운 기능들이 추가되었음&lt;/li&gt;
&lt;li&gt;PATCH : 기존 기능의 버그를 수정했다는 것을 의미&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;다수의 병행 서비스 버전 사용하기&lt;/h3&gt;
&lt;p&gt;다양한 버전의 서비스를 동시에 실행하고, 구 소비자의 트래픽을 구버전에, 신규 소비자의 신버전에 라우팅하는 것&lt;br&gt;
&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;한 서비스의 내부 버그를 고치려면 두 벌의 서로 다른 서비스를 수정하고 배포해야 함&lt;/li&gt;
&lt;li&gt;소비자가 찾는 서비스로 유도하기 위한 부가적인 로직이 필요&lt;/li&gt;
&lt;li&gt;서비스가 처리해야할 영속적 상태가 있는지 고려&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;API Gateway&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트에 개별 서비스를 액세스할 수 있는 단일 접근 지점&lt;/li&gt;
&lt;li&gt;클라이언트의 요청을 적절히 해당 서비스로 라우팅하거나 다양한 서비스로 분배&lt;/li&gt;
&lt;li&gt;클라이언트에 최적화된 API를 제공하고, 클라이언트의 인증 및 접근 제어를 가능하게 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;UI 부분 구성&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;큰 단위의 UI 부분은 서버 측 애플리케이션으로부터 제공, 적절한 API 호출을 수행&lt;/li&gt;
&lt;li&gt;UI 부분이 팀의 소유권과 완전히 일치할 때 가장 잘 작동&lt;/li&gt;
&lt;li&gt;예로, 뮤직 쇼핑몰에서 주문 관리를 담다하는 팀은 주문 관리와 연관된 모든 페이지를 구성해서 제공하는 것&lt;/li&gt;
&lt;li&gt;그러나 &lt;em&gt;사용자 경험의 일관성 유지는 풀어야할 숙제&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;퍼사드 패턴(facade pattern)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;외부에 대한 내부 콘텐트 서비스를 추상황하는 용도로 쓰임&lt;/li&gt;
&lt;li&gt;SOA 또는 Design Pattern에서는 이를 Service Facade 또는 Facade Pattern이라고 부름&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%8D%BC%EC%82%AC%EB%93%9C_%ED%8C%A8%ED%84%B4&quot;&gt;위키백과 - 퍼사드 패턴&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;통합과 관련된 여러 방안 정리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스 통합은 최대한 피할 것&lt;/li&gt;
&lt;li&gt;REST와 RPC의 장단점을 이해하고 요청/응답을 통합하는 좋은 출발점으로 REST를 고려&lt;/li&gt;
&lt;li&gt;오케스트레이션보다는 코레오그래피를 우선&lt;/li&gt;
&lt;li&gt;포스텔의 법칙을 이해하고 관대한 독자 패턴을 사용해서 호환성을 깨트리는 변경과 불필요한 버전을 피할 것&lt;/li&gt;
&lt;li&gt;구성 꼐층으로서의 사용자 인터페이스를 고려&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;5. 모놀리스 분해하기&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;모놀리스는 시간이 흐르면서 자라나고,&lt;br&gt;
빠른 속도로 새로운 기능과 코드 라인을 요구하며,&lt;br&gt;
머지않아 조직 내 사람들이 건드리거나 바꾸기를 두려워하는 거대하고 무서운 존재가 된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;좋은 접합부란?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;경계가 있는 콘텍스트(bounded context)&lt;/li&gt;
&lt;li&gt;조직 내의 응집력 있고, 느슨히 결합된 경계를 잘 표현&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;리팩토링&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;현대적 IDE에서 코드 이동은 리팩토링 기능을 통해 다른 작업 중에 자동적이고 점진적으로 이뤄질 수 있음&lt;/li&gt;
&lt;li&gt;하지만 코드 이동에 따른 오류를 잡아내기 위해 여전히 테스트가 필요&lt;/li&gt;
&lt;li&gt;시간이 지나면서 우리는 잘 어울려 남아 있는 코드와 그렇지 못한 코드를 알아가기 시작&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;대게 끝까지 생존한 코드가 우리가 간과했을지 모를 경계가 있는 콘텍스트로 인식될 수 있음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서비스를 분리하기 전에 모든 코드를 도메인에 따라 나눠진 패키지들에 따라 정렬할 필요는 없다&lt;/li&gt;
&lt;li&gt;한번에 모든 것을 바꾸려는 빅뱅(Big-bang) 접근법을 취할 필요는 없고, 이 과정을 천천히 조금씩 진행되는 것으로 인식&lt;/li&gt;
&lt;li&gt;뒤엉킨 모든 의존성의 출처가 대게 데이터베이스라는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;외부 키 관계 깨뜨리기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;특정 콘텍스트의 코드 내에 데이터베이스 맵핑 코드를 함께 배치하면 어떤 코드가 데이터베이스의 어느 부분을 사용하는지 이해할 수 있음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;예를 들어 경계가 잇는 콘텍스트 단위의 맵핑 파일과 같은 것을 사용한다면 하이버네이트에서는 매우 명확&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스키마스파이(SchemaSpy) : 테이블 관계를 그래픽으로 표현하는 도구&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이 모든 것은 궁극적으로 서비스 경계로 확장될 수 있는 테이블 간의 결합을 이해하도록 해줌&lt;/li&gt;
&lt;li&gt;보고서를 생성하기 위해 서로 다른 두 개의 데이터베이스에 호출해야 하는 것은 분명하며 옳은 것&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;공유 데이터 분리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;각 패키지에 복제, 장기적으로 보면 그 테이블은 각 서비스 내부에서도 복제 될 수 있음&lt;/li&gt;
&lt;li&gt;공유 정적 데이터를 코드로 다루는 것&lt;/li&gt;
&lt;li&gt;서비스의 부분으로 배포되는 속성 파일에 저장되거나,&lt;/li&gt;
&lt;li&gt;열거형 개체(enumeration)가 될 수 있음&lt;/li&gt;
&lt;li&gt;동작 중인 데이터베이스 테이블을 변경하는 것보다 설정 파일을 변경하는 것이 용이하나 데이터 일관성에 대한 문제는 여전히 존재&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;트랜잭션의 경계&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;애플리케이션 코드를 완전히 불리하여 각각의 마이크로서비스로 만들기 전에,&lt;/li&gt;
&lt;li&gt;서비스는 이전과 같이 하나로 유지한 채 우선 스키마 분리를 추천&lt;/li&gt;
&lt;li&gt;서비스를 단계적으로 분리&lt;/li&gt;
&lt;li&gt;연산의 일부를 큐나 로그 파일에 큐잉하여 나중에 재시도 할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;보상 트랜잭션(compensating transaction)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;직전의 트랜잭션을 되돌릴 새로운 트랜잭션을 발생시키는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;분산 트랜잭션(distributed transaction)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;보상 트랜잭션을 수동으로 통제하는 방식의 대안&lt;/li&gt;
&lt;li&gt;2단계 커밋(two-phase commit)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;리포팅 데이터베이스&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;일반적인 모놀리식 서비스 아키텍처에서 모든 데이터는 거대한 단일 데이터베이스에 저장됨&lt;/li&gt;
&lt;li&gt;모든 데이터가 한 곳에 모여 있어서 모든 정보의 경계를 넘어서 리포팅하는 것이 실제로 매우 쉽다&lt;/li&gt;
&lt;li&gt;SQL 질의와 그와 유사한 것들을 통해 데이터를 쉽게 조인할 수 있기 때문&lt;/li&gt;
&lt;li&gt;리포팅 질의가 메인 시스템의 성능에 영향을 주는 것을 우려하여&lt;/li&gt;
&lt;li&gt;리포트를 메인 데이터베이스에서 실행하지 않을 것&lt;/li&gt;
&lt;li&gt;이에 리포팅 시스템은 대게 읽기용 복제 데이터베이스(read replica)에 연결됨&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;서비스 호출을 통한 데이터 추출&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스 스키마는 실행 중인 모놀리식 서비스와 리포팅 시스템 사이에서 사실상 공유 API임&lt;/li&gt;
&lt;li&gt;스키마의 변경은 조심스럽게 관리되어야 하며, 실제로 이것은 스키마를 변경하고 조율할 기회를 줄이는 방해물&lt;/li&gt;
&lt;li&gt;실제 시스템 또는 리포팅 시스템을 지원하는 사용 사례를 위해 데이터베이스를 최적하는 방법은 제한적&lt;/li&gt;
&lt;li&gt;데이터 구조 변경이 실행 중인 시스템에 악영향을 주더라도 리포팅을 빠르게 하기 위해 데이터를 다르게 구성할 수 없음&lt;/li&gt;
&lt;li&gt;스키마가 한 사용 사례에는 훌륭하게 들어맞지만 다른 사례에는 그렇지 못하거나 두 사례의 목적과 부합하지 않아 최소한의 공통분모만 가지게 되는 것&lt;/li&gt;
&lt;li&gt;일반적인 관계형 데이터베이스가 많은 리포팅 도구와 호환되는 SQL 질의 인터페이스를 제공하더라도 동작 중인 서비스에 데이터를 저장하기 위한 최선의 방법은 아님&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;데이터 덤프&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;리포팅 시스템이 데이터를 끌어오는 방식 대신 리포팅 시스템에 데이터를 밀어 넣는 방식을 시도할 수 있다.&lt;/li&gt;
&lt;li&gt;일반적인 HTTP 호출로 데이터를 추출하는 데 있어 단점 중 하나는 다수의 호출을 할 때 발생하는 HTTP의 부하고&lt;/li&gt;
&lt;li&gt;리포팅 목적으로만 사용될지도 모르는 API를 만들어야 하는 부담이다.&lt;/li&gt;
&lt;li&gt;같은 데이터의 소스인 서비스의 데이터베이스에 직접 접근하여 리포팅 데이터베이스로 밀어 넣는 독립 프로그램을 가지는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;h5&gt;데이터마트&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;AWS S3를 실제로 거대한 데이터 마트로 위장하며, JSON 파일을 S3에 저장하기 위해 데이터 펌프를 사용함&lt;/li&gt;
&lt;li&gt;솔루션이 확장이 필요할 때까지 아주 효과가 있었고, 엑셀과 태블로 같은 표준 리포팅 도구와 통합할 수 있는 큐브를 채우도록 이 펌프들을 변경하는 것을 검토&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;h4&gt;이벤트 데이터 펌프&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;고객 서비스가 상태가 바뀌면 상태 변이 이벤트가 발행되고 고객 리포팅 맵퍼를 통해 중앙의 리포팅 데이터베이스로 펌프 됨&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;h4&gt;백업 데이터 펌프&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;넷플릭스&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;카산드라 데이터를 백업하기 위해 데이터 파일을 복사해서 안전한 곳에 저장&lt;/li&gt;
&lt;li&gt;SStable로 알려져있는 이런 파일들을 S3 객체 저장소에 저장&lt;/li&gt;
&lt;li&gt;이 백업된 데이터를 원본으로 사용하는 하둡을 통해 방대한 양의 데이터를 처리할 수 있는 파이프라인을 구현, 아이기스토스 프로젝트로 오픈소스화 됨&lt;/li&gt;
&lt;li&gt;하지만 데이터 펌프처럼 이 백업 데이터 펌프 패턴 역시 리포팅 스키마와 결합&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;변경 비용&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스를 분리하는 것은 더 많은 작업이 필요&lt;/li&gt;
&lt;li&gt;데이터베이스 변경을 되돌리는 것은 복잡한 일&lt;/li&gt;
&lt;li&gt;서비스들이 지나치게 결합된 통합을 분리하는 것 또는 다수의 소비자가 사용하는 API를 완전히 재작성하는 것은 상당히 큰 작업&lt;/li&gt;
&lt;li&gt;높은 비용이 드는 변경은 이들 작업이 점점 더 위험해진다는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;화이트 보드&lt;/strong&gt;를 활용하여 디자인을 스케치, 서비스 경계를 넘어 실행할 때 어떤 일이 발생하는지 확인&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 출이 발생하는가?&lt;/li&gt;
&lt;li&gt;이상한 순환 참조를 볼 수 있는가?&lt;/li&gt;
&lt;li&gt;지나치게 호출이 많은 두 서비스를 발견했는가?&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;+ Words&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;코드베이스/codebase&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;소프트웨어 시스템, 애플리케이션, 컴포넌트를 빌드하는 데 사용되는 코드의 전체 집합&lt;/li&gt;
&lt;li&gt;일반적으로 작성한 코드 파일&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;결함 감내 시스템/fault tolerant system&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일부 장치나 서브시스템에 고장이나 오작동이 나타나면 시스템의 성능과 기능을 축소 구성하여 정지하지 않고도 동작을 유지하는 방식을 사용하고 있는데 이 방식을 단계별 성능 저하(graceful degradation)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;팩토링/factoring - 분해/decomposition&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이해하고, 작성하고, 유지하기 쉽도록 복잡한 문제와 시스템을 외부 동작의 변경 없이 부분으로 나누는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;브르어(Brewer)의 정리&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일관성/consistency&lt;/li&gt;
&lt;li&gt;가용성/availability&lt;/li&gt;
&lt;li&gt;분할 내성/partition tolerance&lt;/li&gt;
&lt;li&gt;모두를 만족하는 분산 시스템이 존재하지 않음을 증명하는 정리&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;callback&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다른 코드의 인수로 넘겨주는 실행 가능한 코드&lt;/li&gt;
&lt;li&gt;콜백을 넘겨받는 코드는 이 콜백을 필요에 따라 즉시 실행할 수도 있고 나중에 실행할 수도 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;원격 프로시저 호출(remote procedure call/RPC)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;local call을 통해 원격 서비스를 실행하는 기술&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;load balancer&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;부하 분산기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;payload&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전송의 근본적인 목적이 되는 데이터의 일부분으로, 해당 데이터와 함께 전송되는 헤더와 메타데이터 등의 데이터는 제외&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;handshake&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;두 개체간의 정상 통신 전에 통신 채널의 파라미터를 설정하는 자동화된 협상 과정&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;tolerant reader pattern/관대한 독자 패턴&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서비스 디자인 패턴 중의 하나&lt;/li&gt;
&lt;li&gt;서비스 공급자가 제공한 메시지 포맷은 변경될 수 있음을 염두에 두고 메시지의 필요한 데이터만 추출하며 관련 없는 데이터는 무시해서 변경 결함을 피하게 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AMQP 프로토콜을 구현한 오픈 소스 메시지 중개자 소프트웨어&lt;/li&gt;
&lt;li&gt;얼랭 언어 기반으로 구현하여 클러스터링 등의 고급 기술과 다양한 언어의 클라이언트 라이브러리를 지원&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Competing Consumer pattern&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메시지를 위해 경쟁하는 다수의 작업자 인스턴스를 다루는 방법을 기술&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;bootstrapping&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일반적으로 컴퓨터의 전원이 켜지거나 리셋된 후 외부 입력 없이 기본 소프트웨어를 메모리에 로드하여 독립 수행하는 과정&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;접합부&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;seam&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;structure101&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;애자일 아키텍처 개발 환경으로, 코드베이스의 구조화를 돕기 위해 다양한 IDE를 위한 플러그인을 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SKU(Stock Keeping Unit)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개별 상별 상품에 대해 재고 관리 목적으로 추적이 쉽도록 하기 위해 사용하는 식별 관리 코드&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Cassandra&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;컬럼 지향 데이터베이스(column-oriented database)로 대용량 확장이 매우 용이한 리포팅 시스템에 적합&lt;/li&gt;
&lt;li&gt;컬럼 지향 데이터베이스는 데이터를 열 단위로 저장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;다양한 REST 방식을 비교한 Richardson Maturity Model을 참고&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-2&quot;&gt;
&lt;p&gt;동일하게 반복되는 요청에 결과가 달라지지 않는 성질&lt;/p&gt;
&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[99콘 연봉협상 후기 - 개발자 연봉협상을 똑똑하게 하는 방법]]></title><description><![CDATA[<p>import ExternalLink from 'components/ExternalLink';</p>
<p>지난 12월 14일, <ExternalLink href="https://www.weirdx.io/" target="_blank" text="이상한 모임" />에서 주최한 99콘 제4회 연봉협상에 참석해 후기를 작성한다.</p>
<p>먼저 99콘에 대해 잠깐 설명하자면, <strong>수습생활 - 성과평가 - 이력서 - 연봉협상의 주제를 가지고 올 한해 기획된 행사</strong>다. 나는 성과평가 회차를 제외한 모든 회차에 참여했는데 정말 너무 만족스러운 행사였다. 세션마다 내용이 모두 알찼고 같은 분야에 종사하는 연사들의 발표 내용은 매우 공감되었으며 꿀팁들이 참 많았다. 일정상 참여가 여러워 제2회 성과평과를 참여하지 못했는데 참 아쉬웠다.<br>
이번 제4회는 연봉협상에 관한 내용이 메인이지만 메인 세션 전에 연말정산 하는 취지에서 1회부터 ~ 3회까지의 세션을 하나씩 더 가졌다. 지난 회차와 동일한 내용이 반복되는 것은 아닐까 걱정했지만, 지난 세션 내용에 그 이후 내용까지 더 해져서 보강된 발표라 더 좋았다.</p>
<p>그럼 <u>사전에 발표 자료가 비공개로 공지</u> 된 만큼 많은 내용을 이 포스팅에서 담기는 어렵겠지만 개괄적으로 정리해보려고 한다.</p>
<ul>
<li><a href="/post/2/">99콘 제2회 이력서편 후기 - 개발자 이력서 작성 방법</a></li>
<li><a href="/post/11/">99콘 제4회 연봉협상편 후기 - 이직자, 재직자 모두에게 필요한 연봉협상 스킬</a></li>
</ul>
<h2>메인세션1. 연봉협상 어디까지 튕겨봤니?</h2>
<blockquote>
<p>손현태</p>
<ul>
<li>11년차 모래알 같은 자바 개발자</li>
<li>우아한형제들 → 카카오</li>
</ul>
</blockquote>
<p>손현태님은 이직하면서 진행한 연봉협상 과정을 카카오톡 대화 형태로 구성하여 발표를 하셔서 몰입이 매우 잘 되었고, 일목요연했다.<br>
특히 연봉협상 과정에서 변하는 상황마다 대처해야 할 방법, 감정과 위기에 대해 자세히 공유해주셔서 같은 을(乙)의 입장에서 매우 공감되었다.</p>
<p><img src="https://baek.dev/assets/images/post/2019/2019_011_SON_005.jpg" alt="손현태님 발표"></p>
<ul>
<li>회사측에서 처음에 제안한 금액을 바로 받아들이는 개발자가 너무 많다.</li>
<li>알 수 있는 방법을 총동원해 연봉의 범위를 알도록 하고, 연봉협상에서 유리한 고지를 점령하는 것이 중요하다.</li>
<li>
<p>비슷한 회사의 면접과 연봉협상을 동시에 진행하라.</p>
<ul>
<li>이곳이 아니어도 갈 곳이 있음에 좀 더 여유 있는 마음과 태도를 가질 수 있다.</li>
<li>현재 나의 객관적인 연봉 수준을 알 수 있어서 다른 회사와 비교를 할 수 있다.</li>
</ul>
</li>
<li>희망 연봉의 근거를 반드시 설정해야 한다.</li>
<li>사이닝 보너스(signing bonus)는 명시한 기간을 채워야 하는 1회 성이므로 잘 따져봐야 한다.</li>
<li>그리고 꼭! 고민하는 시간을 충분히 가지자.</li>
</ul>
<p><img src="https://baek.dev/assets/images/post/2019/2019_011_SON_001.jpg" alt="손현태님 발표"></p>
<h2>메인세션2. 연봉협상도 통역이 되나요?</h2>
<blockquote>
<p>천성권</p>
<ul>
<li>HR</li>
<li>삼성 멀티캠퍼스</li>
</ul>
</blockquote>
<p>천성권님은 연봉협상을 잘하기 위해서는 일단 <strong>연봉이 어떻게 구성되는지</strong> 자세히 따져볼 필요가 있다고 하셨다.<br>
연봉은 회사마다 구성하는 요소, 언급하는 범위가 모두 다르기 때문에 단순히 연봉이라는 워딩으로 퉁쳐서 말하지 말고, 구성 성분으로 이야기해야 함을 강조했다.</p>
<blockquote>
<p>싸인하신 연봉의 구성항목이 어떻게 되나요?</p>
</blockquote>
<p><img src="https://baek.dev/assets/images/post/2019/2019_011_CHEON_001.jpg" alt="천성권님 발표"></p>
<ul>
<li>
<p>하지만 우리는 돈을 직접적으로 입에 담는 것을 예전부터 두려워했다.</p>
<ul>
<li>(너무 속물처럼 보일까 봐 아닐까? - 글쓴이 생각)</li>
</ul>
</li>
<li>
<p>천성권님은 추하지 않게 숫자(=돈)를 말할 수 있는 방법에 대해 살펴봤다.</p>
<ul>
<li><strong>급여 명세서 ≠ 연봉 계약서 ≠ 원천징수 영수증</strong> 임을 알아야 하고</li>
</ul>
</li>
<li>
<p>단순히 '저는 얼마 받고 싶어요' 보다는</p>
<ul>
<li><code>소득</code> = 연봉 + ( 부가 소득 + 생계형 복리후생 + 인센티브 ) 이기 때문에</li>
<li>계약 연봉에 포함/불포함 되는 여부를 잘 챙겨야 한다.</li>
</ul>
</li>
</ul>
<p>Q. 면접이나 연봉협상 등을 급하게 진행하는 경우에는 어떤 이유가 있을까요?<br>
A. 그건 회사 측에 여쭤봐도 된다. 정말 다양한 사유가 존재할 수 있는데 이 사유를 숨기는 곳이라면 입사가 꺼려질 수밖에 없다.</p>
<p>이 세션을 통해 막연하게만 생각했던 연봉이란 단어에 대해 좀 더 깊이 생각하는 계기가 되었다. 단순히 숫자의 크기만을 중요시 생각하기보다는 연봉 이외의 복지나 재직하면서 개인적으로 발생할 수 있는 추가 비용 등을 고려해 불필요한 기회비용이 생기지는 않는지 살펴보는 것이 중요하다.</p>
<h2>스페셜세션. 당신은 더 높은 연봉을 받을 자격이 있다.</h2>
<blockquote>
<p>김나이</p>
<ul>
<li>J.P 모건 -> 커리어 엑셀러레이터(창직)</li>
<li>중앙일보 foll-in 에디터</li>
</ul>
</blockquote>
<ul>
<li>증권사에 재직 당시 본인이 해온 일에 대해 숫자로 시장 대비 성과를 구체적으로 이야기해서 연봉 협상에 성공했다.</li>
<li>회사에서 중요하게 보는 KPI를 챙겨야 한다.</li>
<li>
<p>PLC(Product Life Cycle)에 이직하고 싶은 회사를 대입해 본다.</p>
<ul>
<li>아무리 대기업이라고 하더라고 하향기에 입사는 리스크가 크다.</li>
</ul>
</li>
</ul>
<p><img src="https://baek.dev/assets/images/post/2019/2019_011_SP_KIM_001.jpg" alt="김나이님 발표"></p>
<ul>
<li>가능하면 연봉협상에서 숫자를 언급하는 것을 최대한 미루도록 하라.</li>
<li>과거의 숫자 그 자체에 머물지 말고 미래 가치에 집중하도록 하자.</li>
<li>
<p>연봉 = 기본 연봉 + 스톡옵션 + RSU(= 주식) + 인센티브</p>
<ul>
<li>내가 이 연봉으로 이렇게 이렇게 살아야 하는데 당신이라면 어떻게 하겠어요?</li>
</ul>
</li>
</ul>
<p>위에 작성한 내용 외에도 좋은 내용이 정말 많아 피가 되고 살이되는 실직적인 조언이 담긴 세션이었다.<br>
단순히 돈으로, 숫자로 말하는 것이 아니라 <strong>내 가치를 끌어내고 나의 밸류에 집중시킬 수 있도록</strong> 하는 방법에 대해 생각하는 것이 중요함으로 발표를 요약할 수 있다.</p>
<h2>연말정산 세션1. 경력에도 수습은 필요하다</h2>
<blockquote>
<p>안성현</p>
<ul>
<li>뱅크샐러드</li>
</ul>
</blockquote>
<h3>이직시 참고</h3>
<ul>
<li>비슷한 지역의 면접은 하루에 몰아서 같은 날 3군데 본적도 있음</li>
<li>면접 결과는 노션에 칸반 형태로 정리함</li>
<li><strong>이직 결정표를 통해 가중치를 주고 이를 수치화</strong></li>
<li>
<p>비슷한 도메인의 회사가 실리콘밸리 혹은 유니콘 회사를 비교</p>
<ul>
<li>해당 도메인의 회사가 어떤 가치를 지니는가?</li>
</ul>
</li>
</ul>
<p><code>경력자 ≠ 시니어</code></p>
<ul>
<li>시니어시니까! 시니어에 대한 기대감을 받음</li>
<li>하지만 정작 본인은 시니어라고 생각해 본 적이 없었는데 강제로 시니어로 편입되는 느낌이었음</li>
</ul>
<h3>시니어리티(Seniority)</h3>
<ul>
<li>기술적/경험적으로 알려주기</li>
<li>모르는 것은 모른다고 말하기</li>
<li><strong>먼저 실천하기</strong></li>
</ul>
<h3>발표 후 1년이 지난 뒤</h3>
<ul>
<li>1년 동안 도를 닦았다</li>
<li>
<p>스타트업에서의 1년</p>
<ul>
<li>다사다난, 웃픈 현실</li>
<li>건강관리</li>
<li>사업/조직 개편</li>
</ul>
</li>
<li>기술 스택 변화</li>
</ul>
<h3>역할에 대한 고민</h3>
<ul>
<li>지금 우리 조직에 필요한 것이 무엇인가</li>
<li>내가 해야할 일의 방향은 무엇인가</li>
<li>
<p>내가 지금 해야할 일이 무엇인가</p>
<ul>
<li>자연스레 성장</li>
</ul>
</li>
</ul>
<!-- <script async class="speakerdeck-embed" data-id="accbf16875504bb29f3aae4d1796b374" data-ratio="1.77777777777778" src="//speakerdeck.comhttps://baek.dev/assets/embed.js"></script>   -->
<p>안성현님의 <a href="https://speakerdeck.com/ahnseonghyun/ributeu-gyeongryeogjaegedo-suseubi-pilyohan-sungan" target="_blank">지난 제1회 구구콘 &#x3C;수습생활> 발표 자료</a></p>
<h2>연말정산 세션2. 영혼까지 끌어쓰는 자기평가</h2>
<blockquote>
<p>김미경</p>
</blockquote>
<ul>
<li>우아한형제들</li>
<li>기획자</li>
</ul>
<h3>평가를 작성하기 전에</h3>
<ul>
<li>업무 이력에서 지난날 업무들을 추출</li>
<li>추출한 업무들을 분류하고, 가중치 등을 부여하여 정량화</li>
</ul>
<p><img src="https://baek.dev/assets/images/post/2019/2019_011_KIM_001.jpg" alt="김미경님 발표"></p>
<h3>평가자가 바라는 인재상</h3>
<ul>
<li>
<p>내가 무엇을 해야할지 모를 땐 차라리 물어보면 된다</p>
<ul>
<li>제가 뭘 하면 좋을까요?</li>
</ul>
</li>
<li>그럼 내 보스는 대답하려고 노력하고 -> 생각이 정리되면 -> 평가 기준이 생긴다</li>
<li>바뀌는 인재상 -> 조직장이 원하는 역할을 인지함</li>
<li>
<p>상태체크 -> 평가기준 리마인드 &#x26; 현상 &#x26; 방향성 체크</p>
<ul>
<li>회사는 항상 바뀜</li>
</ul>
</li>
</ul>
<h3>셀프 평가 작성시</h3>
<ul>
<li>어필할 항목을 추린다</li>
<li>초안을 작성한다</li>
<li>팩트는 숫자로 말하자</li>
<li>
<p>달성 기준은 목표를 명시하자</p>
<ul>
<li>그래서 잘 된거야?</li>
<li>목표를 명시하고 이전과 비교하자</li>
</ul>
</li>
<li><a href="https://coupa.ng/bk3lXj" target="_blank">팩트풀니스</a> 책 참고</li>
</ul>
<blockquote>
<p>셀프 평가는 진짜 뻔뻔하게 작성하자</p>
</blockquote>
<p><img src="https://baek.dev/assets/images/post/2019/2019_011_KIM_002.jpg" alt="김미경님 발표"></p>
<h3>글쓰기</h3>
<ul>
<li>타이틀을 세분화하고</li>
<li>타이틀을 연속적으로 이야기하면서</li>
<li>이미지를 만들고 역량을 보여주는 것</li>
<li>1줄 내용보다 1줄 타이틀이 강할 때가 있음</li>
<li>
<p>글쓰기는 꾸준히 연습</p>
<ul>
<li>제품은 한 줄의 카피라이트로 팔림</li>
</ul>
</li>
<li>경영서적을 잘 읽어보면 경영자들이 좋아하는 단어가 있음</li>
<li>그리고 행사 이후 <a href="http://minieetea.com/2019/12/archives/5799" target="_blank">나다운 글쓰기 수련법</a>으로 추가 공유</li>
</ul>
<p>김미경님의 지난 <a href="https://speakerdeck.com/minieetea/yeonghonggaji-ggeuleosseuneun-jagipyeongga-isanghanmoim-99con" target="_blank">제2회 구구콘 &#x3C;성과평과> 발표 자료</a></p>
<!-- <script async class="speakerdeck-embed" data-id="d95440945f8d4462873221c7567d75b7" data-ratio="1.77777777777778" src="//speakerdeck.comhttps://baek.dev/assets/embed.js"></script> -->
<h2>양평 같은 방</h2>
<p><img src="https://baek.dev/assets/images/post/2019/2019_011_ROOM_YANGPYEONG.jpg" alt="양평 같은 방">
이 날 행사는 우아한 형제들 작은 집에서 진행됐다. 특히 이번 행사에서는 DR팀 담당자분께서 작은 집 투어를 진행해주셨다. 우형에는 공간 디자인팀이 따로 있을 정도로 공간마다 직원을 생각하는 배려가 많이 느껴졌다.</p>
<p>양평 같은 방은 들어서자마자 펜션 인상을 받았다.<br>
멀리 떠나지 않아도 놀러 온 분위기를 낼 수 있어 팀이 소규모 워크샵을 하거나 조용히 이야기를 나누거나 요리를 할 수도 있는 공간이다.</p>
<p>이렇게 2019 마지막 99콘의 행사가 끝났다. 아쉽게도 내년에는 행사 계획이 없다고 한다.<br>
포스팅으로나마 <strong>좋은 행사 기획해주셔서 감사의 말씀 드리고 싶다.</strong></p>
<p>다음에도 99콘이 열린다면 꼭 참석할께요 :)</p>]]></description><link>https://baek.dev/post/11/</link><guid isPermaLink="false">https://baek.dev/post/11/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 22 Dec 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;import ExternalLink from &apos;components/ExternalLink&apos;;&lt;/p&gt;
&lt;p&gt;지난 12월 14일, &lt;ExternalLink href=&quot;https://www.weirdx.io/&quot; target=&quot;_blank&quot; text=&quot;이상한 모임&quot; /&gt;에서 주최한 99콘 제4회 연봉협상에 참석해 후기를 작성한다.&lt;/p&gt;
&lt;p&gt;먼저 99콘에 대해 잠깐 설명하자면, &lt;strong&gt;수습생활 - 성과평가 - 이력서 - 연봉협상의 주제를 가지고 올 한해 기획된 행사&lt;/strong&gt;다. 나는 성과평가 회차를 제외한 모든 회차에 참여했는데 정말 너무 만족스러운 행사였다. 세션마다 내용이 모두 알찼고 같은 분야에 종사하는 연사들의 발표 내용은 매우 공감되었으며 꿀팁들이 참 많았다. 일정상 참여가 여러워 제2회 성과평과를 참여하지 못했는데 참 아쉬웠다.&lt;br&gt;
이번 제4회는 연봉협상에 관한 내용이 메인이지만 메인 세션 전에 연말정산 하는 취지에서 1회부터 ~ 3회까지의 세션을 하나씩 더 가졌다. 지난 회차와 동일한 내용이 반복되는 것은 아닐까 걱정했지만, 지난 세션 내용에 그 이후 내용까지 더 해져서 보강된 발표라 더 좋았다.&lt;/p&gt;
&lt;p&gt;그럼 &lt;u&gt;사전에 발표 자료가 비공개로 공지&lt;/u&gt; 된 만큼 많은 내용을 이 포스팅에서 담기는 어렵겠지만 개괄적으로 정리해보려고 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/post/2/&quot;&gt;99콘 제2회 이력서편 후기 - 개발자 이력서 작성 방법&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/11/&quot;&gt;99콘 제4회 연봉협상편 후기 - 이직자, 재직자 모두에게 필요한 연봉협상 스킬&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;메인세션1. 연봉협상 어디까지 튕겨봤니?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;손현태&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;11년차 모래알 같은 자바 개발자&lt;/li&gt;
&lt;li&gt;우아한형제들 → 카카오&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;손현태님은 이직하면서 진행한 연봉협상 과정을 카카오톡 대화 형태로 구성하여 발표를 하셔서 몰입이 매우 잘 되었고, 일목요연했다.&lt;br&gt;
특히 연봉협상 과정에서 변하는 상황마다 대처해야 할 방법, 감정과 위기에 대해 자세히 공유해주셔서 같은 을(乙)의 입장에서 매우 공감되었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_011_SON_005.jpg&quot; alt=&quot;손현태님 발표&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;회사측에서 처음에 제안한 금액을 바로 받아들이는 개발자가 너무 많다.&lt;/li&gt;
&lt;li&gt;알 수 있는 방법을 총동원해 연봉의 범위를 알도록 하고, 연봉협상에서 유리한 고지를 점령하는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비슷한 회사의 면접과 연봉협상을 동시에 진행하라.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이곳이 아니어도 갈 곳이 있음에 좀 더 여유 있는 마음과 태도를 가질 수 있다.&lt;/li&gt;
&lt;li&gt;현재 나의 객관적인 연봉 수준을 알 수 있어서 다른 회사와 비교를 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;희망 연봉의 근거를 반드시 설정해야 한다.&lt;/li&gt;
&lt;li&gt;사이닝 보너스(signing bonus)는 명시한 기간을 채워야 하는 1회 성이므로 잘 따져봐야 한다.&lt;/li&gt;
&lt;li&gt;그리고 꼭! 고민하는 시간을 충분히 가지자.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_011_SON_001.jpg&quot; alt=&quot;손현태님 발표&quot;&gt;&lt;/p&gt;
&lt;h2&gt;메인세션2. 연봉협상도 통역이 되나요?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;천성권&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HR&lt;/li&gt;
&lt;li&gt;삼성 멀티캠퍼스&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;천성권님은 연봉협상을 잘하기 위해서는 일단 &lt;strong&gt;연봉이 어떻게 구성되는지&lt;/strong&gt; 자세히 따져볼 필요가 있다고 하셨다.&lt;br&gt;
연봉은 회사마다 구성하는 요소, 언급하는 범위가 모두 다르기 때문에 단순히 연봉이라는 워딩으로 퉁쳐서 말하지 말고, 구성 성분으로 이야기해야 함을 강조했다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;싸인하신 연봉의 구성항목이 어떻게 되나요?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_011_CHEON_001.jpg&quot; alt=&quot;천성권님 발표&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;하지만 우리는 돈을 직접적으로 입에 담는 것을 예전부터 두려워했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(너무 속물처럼 보일까 봐 아닐까? - 글쓴이 생각)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;천성권님은 추하지 않게 숫자(=돈)를 말할 수 있는 방법에 대해 살펴봤다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;급여 명세서 ≠ 연봉 계약서 ≠ 원천징수 영수증&lt;/strong&gt; 임을 알아야 하고&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;단순히 &apos;저는 얼마 받고 싶어요&apos; 보다는&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;소득&lt;/code&gt; = 연봉 + ( 부가 소득 + 생계형 복리후생 + 인센티브 ) 이기 때문에&lt;/li&gt;
&lt;li&gt;계약 연봉에 포함/불포함 되는 여부를 잘 챙겨야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Q. 면접이나 연봉협상 등을 급하게 진행하는 경우에는 어떤 이유가 있을까요?&lt;br&gt;
A. 그건 회사 측에 여쭤봐도 된다. 정말 다양한 사유가 존재할 수 있는데 이 사유를 숨기는 곳이라면 입사가 꺼려질 수밖에 없다.&lt;/p&gt;
&lt;p&gt;이 세션을 통해 막연하게만 생각했던 연봉이란 단어에 대해 좀 더 깊이 생각하는 계기가 되었다. 단순히 숫자의 크기만을 중요시 생각하기보다는 연봉 이외의 복지나 재직하면서 개인적으로 발생할 수 있는 추가 비용 등을 고려해 불필요한 기회비용이 생기지는 않는지 살펴보는 것이 중요하다.&lt;/p&gt;
&lt;h2&gt;스페셜세션. 당신은 더 높은 연봉을 받을 자격이 있다.&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;김나이&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;J.P 모건 -&gt; 커리어 엑셀러레이터(창직)&lt;/li&gt;
&lt;li&gt;중앙일보 foll-in 에디터&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;증권사에 재직 당시 본인이 해온 일에 대해 숫자로 시장 대비 성과를 구체적으로 이야기해서 연봉 협상에 성공했다.&lt;/li&gt;
&lt;li&gt;회사에서 중요하게 보는 KPI를 챙겨야 한다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PLC(Product Life Cycle)에 이직하고 싶은 회사를 대입해 본다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;아무리 대기업이라고 하더라고 하향기에 입사는 리스크가 크다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_011_SP_KIM_001.jpg&quot; alt=&quot;김나이님 발표&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가능하면 연봉협상에서 숫자를 언급하는 것을 최대한 미루도록 하라.&lt;/li&gt;
&lt;li&gt;과거의 숫자 그 자체에 머물지 말고 미래 가치에 집중하도록 하자.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;연봉 = 기본 연봉 + 스톡옵션 + RSU(= 주식) + 인센티브&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내가 이 연봉으로 이렇게 이렇게 살아야 하는데 당신이라면 어떻게 하겠어요?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위에 작성한 내용 외에도 좋은 내용이 정말 많아 피가 되고 살이되는 실직적인 조언이 담긴 세션이었다.&lt;br&gt;
단순히 돈으로, 숫자로 말하는 것이 아니라 &lt;strong&gt;내 가치를 끌어내고 나의 밸류에 집중시킬 수 있도록&lt;/strong&gt; 하는 방법에 대해 생각하는 것이 중요함으로 발표를 요약할 수 있다.&lt;/p&gt;
&lt;h2&gt;연말정산 세션1. 경력에도 수습은 필요하다&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;안성현&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;뱅크샐러드&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3&gt;이직시 참고&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;비슷한 지역의 면접은 하루에 몰아서 같은 날 3군데 본적도 있음&lt;/li&gt;
&lt;li&gt;면접 결과는 노션에 칸반 형태로 정리함&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;이직 결정표를 통해 가중치를 주고 이를 수치화&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;비슷한 도메인의 회사가 실리콘밸리 혹은 유니콘 회사를 비교&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;해당 도메인의 회사가 어떤 가치를 지니는가?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;경력자 ≠ 시니어&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;시니어시니까! 시니어에 대한 기대감을 받음&lt;/li&gt;
&lt;li&gt;하지만 정작 본인은 시니어라고 생각해 본 적이 없었는데 강제로 시니어로 편입되는 느낌이었음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;시니어리티(Seniority)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;기술적/경험적으로 알려주기&lt;/li&gt;
&lt;li&gt;모르는 것은 모른다고 말하기&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;먼저 실천하기&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;발표 후 1년이 지난 뒤&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1년 동안 도를 닦았다&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;스타트업에서의 1년&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다사다난, 웃픈 현실&lt;/li&gt;
&lt;li&gt;건강관리&lt;/li&gt;
&lt;li&gt;사업/조직 개편&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;기술 스택 변화&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;역할에 대한 고민&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;지금 우리 조직에 필요한 것이 무엇인가&lt;/li&gt;
&lt;li&gt;내가 해야할 일의 방향은 무엇인가&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내가 지금 해야할 일이 무엇인가&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자연스레 성장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- &lt;script async class=&quot;speakerdeck-embed&quot; data-id=&quot;accbf16875504bb29f3aae4d1796b374&quot; data-ratio=&quot;1.77777777777778&quot; src=&quot;//speakerdeck.comhttps://baek.dev/assets/embed.js&quot;&gt;&lt;/script&gt;   --&gt;
&lt;p&gt;안성현님의 &lt;a href=&quot;https://speakerdeck.com/ahnseonghyun/ributeu-gyeongryeogjaegedo-suseubi-pilyohan-sungan&quot; target=&quot;_blank&quot;&gt;지난 제1회 구구콘 &amp;#x3C;수습생활&gt; 발표 자료&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;연말정산 세션2. 영혼까지 끌어쓰는 자기평가&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;김미경&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;우아한형제들&lt;/li&gt;
&lt;li&gt;기획자&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;평가를 작성하기 전에&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;업무 이력에서 지난날 업무들을 추출&lt;/li&gt;
&lt;li&gt;추출한 업무들을 분류하고, 가중치 등을 부여하여 정량화&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_011_KIM_001.jpg&quot; alt=&quot;김미경님 발표&quot;&gt;&lt;/p&gt;
&lt;h3&gt;평가자가 바라는 인재상&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;내가 무엇을 해야할지 모를 땐 차라리 물어보면 된다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;제가 뭘 하면 좋을까요?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;그럼 내 보스는 대답하려고 노력하고 -&gt; 생각이 정리되면 -&gt; 평가 기준이 생긴다&lt;/li&gt;
&lt;li&gt;바뀌는 인재상 -&gt; 조직장이 원하는 역할을 인지함&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;상태체크 -&gt; 평가기준 리마인드 &amp;#x26; 현상 &amp;#x26; 방향성 체크&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;회사는 항상 바뀜&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;셀프 평가 작성시&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;어필할 항목을 추린다&lt;/li&gt;
&lt;li&gt;초안을 작성한다&lt;/li&gt;
&lt;li&gt;팩트는 숫자로 말하자&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;달성 기준은 목표를 명시하자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그래서 잘 된거야?&lt;/li&gt;
&lt;li&gt;목표를 명시하고 이전과 비교하자&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://coupa.ng/bk3lXj&quot; target=&quot;_blank&quot;&gt;팩트풀니스&lt;/a&gt; 책 참고&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;셀프 평가는 진짜 뻔뻔하게 작성하자&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_011_KIM_002.jpg&quot; alt=&quot;김미경님 발표&quot;&gt;&lt;/p&gt;
&lt;h3&gt;글쓰기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;타이틀을 세분화하고&lt;/li&gt;
&lt;li&gt;타이틀을 연속적으로 이야기하면서&lt;/li&gt;
&lt;li&gt;이미지를 만들고 역량을 보여주는 것&lt;/li&gt;
&lt;li&gt;1줄 내용보다 1줄 타이틀이 강할 때가 있음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;글쓰기는 꾸준히 연습&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;제품은 한 줄의 카피라이트로 팔림&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;경영서적을 잘 읽어보면 경영자들이 좋아하는 단어가 있음&lt;/li&gt;
&lt;li&gt;그리고 행사 이후 &lt;a href=&quot;http://minieetea.com/2019/12/archives/5799&quot; target=&quot;_blank&quot;&gt;나다운 글쓰기 수련법&lt;/a&gt;으로 추가 공유&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;김미경님의 지난 &lt;a href=&quot;https://speakerdeck.com/minieetea/yeonghonggaji-ggeuleosseuneun-jagipyeongga-isanghanmoim-99con&quot; target=&quot;_blank&quot;&gt;제2회 구구콘 &amp;#x3C;성과평과&gt; 발표 자료&lt;/a&gt;&lt;/p&gt;
&lt;!-- &lt;script async class=&quot;speakerdeck-embed&quot; data-id=&quot;d95440945f8d4462873221c7567d75b7&quot; data-ratio=&quot;1.77777777777778&quot; src=&quot;//speakerdeck.comhttps://baek.dev/assets/embed.js&quot;&gt;&lt;/script&gt; --&gt;
&lt;h2&gt;양평 같은 방&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_011_ROOM_YANGPYEONG.jpg&quot; alt=&quot;양평 같은 방&quot;&gt;
이 날 행사는 우아한 형제들 작은 집에서 진행됐다. 특히 이번 행사에서는 DR팀 담당자분께서 작은 집 투어를 진행해주셨다. 우형에는 공간 디자인팀이 따로 있을 정도로 공간마다 직원을 생각하는 배려가 많이 느껴졌다.&lt;/p&gt;
&lt;p&gt;양평 같은 방은 들어서자마자 펜션 인상을 받았다.&lt;br&gt;
멀리 떠나지 않아도 놀러 온 분위기를 낼 수 있어 팀이 소규모 워크샵을 하거나 조용히 이야기를 나누거나 요리를 할 수도 있는 공간이다.&lt;/p&gt;
&lt;p&gt;이렇게 2019 마지막 99콘의 행사가 끝났다. 아쉽게도 내년에는 행사 계획이 없다고 한다.&lt;br&gt;
포스팅으로나마 &lt;strong&gt;좋은 행사 기획해주셔서 감사의 말씀 드리고 싶다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;다음에도 99콘이 열린다면 꼭 참석할께요 :)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[단기속성 4주완성 퀵퀵각코, 운영 회고록]]></title><description><![CDATA[<p>import ResizeImage from 'components/ResizeImage'
import ExternalLink from 'components/ExternalLink'</p>
<p>지난 26일 토요일에 퀵퀵각코 마지막 모임인 <code>발표&#x26;회고</code>를 진행했다. 단기속성 4주완성 기간제 목표형 모각코인 퀵퀵각코가 도래하기까지의 어떤 고민이 있었고 어떤 방법으로 풀었는지 회고하는 시간을 가져본다.</p>
<blockquote>
<p>참고</p>
<ul>
<li>
<ExternalLink href="https://www.notion.so/baekdev/4-0a3e47e8583e4019b5215a1ec83d5a1a" target="_blank" text="퀵퀵각코 모집글" />
</li>
</ul>
</blockquote>
<h2>출석률</h2>
<p><img src="https://baek.dev/assets/images/post/2019/2019_003_003.png" alt="모각코 달력"></p>
<p>총 5주를 진행했고, 출석부도 작성했다. 개인 정보를 위해 이름은 변경했다. 회비 내역도 공개를 했고 비용이 조금 남아 마지막 날 샌드위치 간식까지 준비하여 공금을 남김없이 다 소진했다.</p>
<p>나는 8주, 12주짜리 모각코를 이전에 운영해 보았는데 이번 한 달 모각까지 합쳐 공통점을 발견했다.</p>
<blockquote>
<p>한 달을 하든 두 달을 하든 세 달을 하든 출석률 그래프 모양은 같다.</p>
</blockquote>
<ul>
<li>초반에는 목표 달성 의지로 많은 분들이 참여를 하고</li>
<li>중간에는 여러 사정으로 인해 결석이 많다.</li>
<li>그러다 후반 직전에 출석률이 증가한다.</li>
</ul>
<p>참가자들의 회고에서 언급된 공통된 내용은 <code>목표 설정의 어려움과 아쉬움</code>이었다.</p>
<h2>실천 가능한 작고 구체화된 목표 설정</h2>
<p>참가자들은 스스로 설정한 실현하기 어려운 목표로 좌절을 경험했고, 이번 경험을 통해 목표 구체화에 대한 실전 경험을 할 수 있게 되었다. 나는 참가자들 각자가 공유해준 목표에 더 구체화할 수 있도록 가이드를 해주고 싶었지만 스스로 실패를 경험해보는 것이 더 강한 인상을 남길 것이라 생각했다.</p>
<blockquote>
<p>실제로 사람은 자신이 필요로 하지 않는 정보에 대해서는 특별히 큰 관심을 두지 않는 경향이 있기 때문이다.</p>
</blockquote>
<h2>가장 좋은 학습법은 가르치는 것</h2>
<p>이번에는 타이트하게 준비를 요하진 않았지만 각자 공부한 내용을 개괄적으로 공유하는 것을 부탁드렸다. 하지만 참여자분들은 이 공유, 설명에 대해 많은 부담을 느끼는 것 같았다. 당연하다. 내가 공부한 내용이 그 분야의 전부가 아니고, 강의도 해본 적이 없으니 부담스러운 것은 당연하다.</p>
<p><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=70740411">소프트 스킬</a>이라는 책에서는 <code>배움의 10단계</code> 중 가장 높은 10단계에 <strong>가르치기</strong> 방법을 최고로 꼽고 있다. 내가 아는 지식을 설명하기 위해서는 한 번 더 내용의 옳고 그름을 확인하는 과정을 갖게 되니 지식이 더 견고해지기 때문이다. 또한 꼭 그 지식을 통달해야만 가르칠 수 있는 것은 아니라고 했다.</p>
<p>그래서 나는 모각코 마지막에 항상 발표하는 시간을 가진다.</p>
<p><ExternalLink 
    href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=70740411" 
    target="_blank"
    src="https://image.aladin.co.kr/product/7074/4/cover500/k662434482_2.jpg"
    alt="소프트 스킬"
    width="200px"
    /></p>
<h2>회고 플랫폼을 각자 운영</h2>
<p>기존 모각코는 모각코 전용 블로그(github.io)에 회고를 기고하는 형식으로 운영했다. 이 운영 방식에는 몇가지 넛지가 있는데,</p>
<h3>git(github) 사용 장려</h3>
<p>git을 접해보지 못했거나, 혹은 숙련되지 않은 분들을 위해 git을 의도적으로 사용하도록 하는 목적이 의도되었다. 물론 혼자서 git을 써볼 순 있으나, git의 진가는 여러 사람이 동시에 하나의 repository를 공유함으로써 나타난다고 생각한다. 혼자서 사용하게 되면 해피 케이스만 경험하기 때문이다.</p>
<p><img src="https://baek.dev/assets/images/post/2019/2019_010_001.png" alt="git contributions"></p>
<h3>회고 기고 및 부담감 주입</h3>
<p>당시에는 회고를 돌아가면서 매주 한 명이 작성했는데 이로 인해 모임에 좀 더 적극적으로 참여할 수 있고, 다른 참가자의 목표에 대해 좀 더 관심을 갖게 하도록 하는 넛지가 있었다.</p>
<h3>모각코 블로그 컨텐츠 생산</h3>
<p>모각코 블로그에 컨텐츠 생상을 할 수 있는 계기가 되고 참여자의 기고를 통해 모임 운영에 참여를 이끌어 낼 수 있는 의도가 있었다.</p>
<h3>하지만 이 회고를 각자 한다면?</h3>
<p>퀵퀵가코, 모각코를 시작하기 전에 <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=187823405">커리어 스킬</a>이라는 책을 읽었다. 저자는 개발자에게 블로그가 얼마나 중요하고 커리어 발전에 도움이 되는지 입에 침이 마르도록 칭찬한다. 나는 이것을 보고 지금의 블로그를 시작하게 되었다. 그리고 회고록을 작성하기 위해 기존처럼 퀵퀵각코 블로그 구축을 github에 하고 있었다. 하지만 문뜩 드는 생각이 이 좋은 블로깅을 나만 할 수 없지 않는가. 블로깅을 하지 않는 참가자들에게 블로그를 하도록 조금의 동기 부여를 주고 싶었다. 그래서 모두에게 반드시 회고 플랫폼을 마련하도록 모임 시작전에 공지했다. 퀵퀵각코에서 정한 시작 전에 공지는 단 2개였다.</p>
<blockquote>
<ol>
<li>작고 실천가능 한 목표 구체화</li>
<li>회고 플랫폼 마련</li>
</ol>
</blockquote>
<p>깃허브, 티스토리, 미디엄 등등 어느 플랫폼이든 상관없으나 단, <code>검색엔진에서 회고록이 검색이 되는 플랫폼이어야 한다</code>가 전제 조건이었다.<br>
블로깅 초반에는 사실 <strong>컨텐츠 생산에 많은 어려움</strong>이 따른다. 어떤 내용을 써야 할지도 모르겠고 글쓰기에 대한 부담이 상당해서 블로깅에서 점점 멀어지기 부지기수다. 그래서 이 진입장벽을 허물기 위해 회고를 작성하다 보면 늘어나는 포스팅에 조금은 뿌듯할 수 있고, 검색을 통해 유입자가 늘어나면 재미도 조금씩 붙을 것이라 생각했다.</p>
<p><ExternalLink 
    href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=187823405"
    target="_blank"
    src="https://image.aladin.co.kr/product/18782/34/cover500/k662635470_1.jpg" 
    alt="커리어 스킬" 
    width="200px" /></p>
<h2>운영 리소스는 최대한 줄일 것</h2>
<p>지난 모각코와 달리 이번에는 상대적으로 운영에 많은 시간을 투자하지 않았다.</p>
<ul>
<li>공간 예약과 출석 관리</li>
<li>공용 회고 플랫폼 마련과 관리</li>
<li>간식 준비</li>
<li>그룹 관리</li>
<li>발표 자료</li>
<li>스티커 제작</li>
<li>마지막 세미나 게스트 초대와 다과 준비 등</li>
</ul>
<p>위 리스트를 포함하여 많은 것을 혼자 운영했다. 덕분에 퀄리티 있는 모각코를 운영했고 참가자들의 만족도도 매우 높았다. 하지만 높은 운영 비용으로 인해 <strong>정작 내 목표는 달성하지 못했었다.</strong> 참가자들은 자신의 목표 성과를 세미나에서 발표할 수 있었지만 나는 세미나에서 목표 달성하지 못한 반성문을 낭독하느라 매우 민망했다. 그래서 이번 퀵퀵각코에서는 운영에 최대한 리소스를 최대한 할당하지 않으려 고민했다.</p>
<h3>4주라는 매우 짧은 기간제 모각코를 만들어 사이클을 빨리 운영하고자 했다.</h3>
<p>모임 횟수는 12번이었지만 연말 행사로 인해 거의 4달짜리 기간제 모각코를 한 적이 있다. 모임 호흡이 늘어지고 목표를 바꾸게 되는 상황도 많았다. 또한 토이프로젝트는 짧게 짧게 시행착오를 겪는 것이 중요하다고 생각했다. 그래서 이번에는 시도해보지 않았던 4주로 책정했다.</p>
<p>이번에 설정한 내 목표가 나와 맞지 않았다면 잠깐 쉬고 다시 새로운 목표를 시작하더라도 죄책감을 느끼지 않아도 된다. 모임 중간에 목표를 변경하게 되면 실패감과 새로운 목표에 대한 부담이 동시에 다가오기 때문이다.</p>
<h3>모임 장소인 스터디룸을 저렴한 곳으로 모각코 총 인원만큼 예약했다.</h3>
<p>해당 주차에 결석자가 발생하면 비용 낭비가 발생할 순 있지만 이 금액으로 인해 운영자와 참가자가 모두 출결에 독촉 받는 구조가 될 수 있어서 그런 스트레스는 없애는것이 더 중요하다고 판단했다.</p>
<h3>회비는 오로지 스터디룸 예약 비용만 책정했다.</h3>
<p>이전에는 간식비 등이 포함되었지만 이번에는 오로지 스터디룸 비용만 책정했다. 간식을 구매함에 있어 인원수를 알아야 하는데 그럼 결국 출결을 독촉받는 구조로 또 이어지게 된다. 또한 간식 당번을 운영하는 리소스가 들어가고 당번은 간식을 준비해야 하는 업무가 생기게 된다.</p>
<ResizeImage src="https://baek.dev/assets/images/post/2019/2019_010_002.jpg" alt="처음이자 마지막 간식" width="400px;"/>
<p>비용이 남아 마지막 모임에 간식을 준비했다. 서로 고민과 좋은 내용을 공유하면서 이번 퀵퀵각코를 마무리했다. 아쉬운 점도 분명 있었지만 새로운 시도를 통해 여러 경험을 해본 것 같아 만족스럽다. 즉석에서 익명으로 만족도 설문 조사를 통해 나온 <code>4주</code>라는 기간에 대해-</p>
<ul>
<li>4주가 좋다는 분도</li>
<li>8주는 해야하지 않겠냐는 분도 계셨고</li>
<li>그 중간인 6주 운영에 대한 의견도 나왔다.</li>
</ul>
<p>사실 기간은 너무 길지만 않으면 크게 중요하지 않은 것 같다. 목표를 이룰 수 있도록 서로 선의의 감시자가 되어주고 다독여주는 동료가 되어가는 것이 더 의미가 있는 것 같다.</p>
<p>이제 목표 달성에 대한 부담감을 잠시 내려놓고 늦잠을 자거나 여가를 보낼 수 있도록 토요일 오전을 마음껏 즐겨야겠다.</p>]]></description><link>https://baek.dev/post/10/</link><guid isPermaLink="false">https://baek.dev/post/10/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Mon, 28 Oct 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;import ResizeImage from &apos;components/ResizeImage&apos;
import ExternalLink from &apos;components/ExternalLink&apos;&lt;/p&gt;
&lt;p&gt;지난 26일 토요일에 퀵퀵각코 마지막 모임인 &lt;code&gt;발표&amp;#x26;회고&lt;/code&gt;를 진행했다. 단기속성 4주완성 기간제 목표형 모각코인 퀵퀵각코가 도래하기까지의 어떤 고민이 있었고 어떤 방법으로 풀었는지 회고하는 시간을 가져본다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;참고&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ExternalLink href=&quot;https://www.notion.so/baekdev/4-0a3e47e8583e4019b5215a1ec83d5a1a&quot; target=&quot;_blank&quot; text=&quot;퀵퀵각코 모집글&quot; /&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;출석률&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_003_003.png&quot; alt=&quot;모각코 달력&quot;&gt;&lt;/p&gt;
&lt;p&gt;총 5주를 진행했고, 출석부도 작성했다. 개인 정보를 위해 이름은 변경했다. 회비 내역도 공개를 했고 비용이 조금 남아 마지막 날 샌드위치 간식까지 준비하여 공금을 남김없이 다 소진했다.&lt;/p&gt;
&lt;p&gt;나는 8주, 12주짜리 모각코를 이전에 운영해 보았는데 이번 한 달 모각까지 합쳐 공통점을 발견했다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;한 달을 하든 두 달을 하든 세 달을 하든 출석률 그래프 모양은 같다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;초반에는 목표 달성 의지로 많은 분들이 참여를 하고&lt;/li&gt;
&lt;li&gt;중간에는 여러 사정으로 인해 결석이 많다.&lt;/li&gt;
&lt;li&gt;그러다 후반 직전에 출석률이 증가한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;참가자들의 회고에서 언급된 공통된 내용은 &lt;code&gt;목표 설정의 어려움과 아쉬움&lt;/code&gt;이었다.&lt;/p&gt;
&lt;h2&gt;실천 가능한 작고 구체화된 목표 설정&lt;/h2&gt;
&lt;p&gt;참가자들은 스스로 설정한 실현하기 어려운 목표로 좌절을 경험했고, 이번 경험을 통해 목표 구체화에 대한 실전 경험을 할 수 있게 되었다. 나는 참가자들 각자가 공유해준 목표에 더 구체화할 수 있도록 가이드를 해주고 싶었지만 스스로 실패를 경험해보는 것이 더 강한 인상을 남길 것이라 생각했다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;실제로 사람은 자신이 필요로 하지 않는 정보에 대해서는 특별히 큰 관심을 두지 않는 경향이 있기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;가장 좋은 학습법은 가르치는 것&lt;/h2&gt;
&lt;p&gt;이번에는 타이트하게 준비를 요하진 않았지만 각자 공부한 내용을 개괄적으로 공유하는 것을 부탁드렸다. 하지만 참여자분들은 이 공유, 설명에 대해 많은 부담을 느끼는 것 같았다. 당연하다. 내가 공부한 내용이 그 분야의 전부가 아니고, 강의도 해본 적이 없으니 부담스러운 것은 당연하다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=70740411&quot;&gt;소프트 스킬&lt;/a&gt;이라는 책에서는 &lt;code&gt;배움의 10단계&lt;/code&gt; 중 가장 높은 10단계에 &lt;strong&gt;가르치기&lt;/strong&gt; 방법을 최고로 꼽고 있다. 내가 아는 지식을 설명하기 위해서는 한 번 더 내용의 옳고 그름을 확인하는 과정을 갖게 되니 지식이 더 견고해지기 때문이다. 또한 꼭 그 지식을 통달해야만 가르칠 수 있는 것은 아니라고 했다.&lt;/p&gt;
&lt;p&gt;그래서 나는 모각코 마지막에 항상 발표하는 시간을 가진다.&lt;/p&gt;
&lt;p&gt;&lt;ExternalLink 
    href=&quot;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=70740411&quot; 
    target=&quot;_blank&quot;
    src=&quot;https://image.aladin.co.kr/product/7074/4/cover500/k662434482_2.jpg&quot;
    alt=&quot;소프트 스킬&quot;
    width=&quot;200px&quot;
    /&gt;&lt;/p&gt;
&lt;h2&gt;회고 플랫폼을 각자 운영&lt;/h2&gt;
&lt;p&gt;기존 모각코는 모각코 전용 블로그(github.io)에 회고를 기고하는 형식으로 운영했다. 이 운영 방식에는 몇가지 넛지가 있는데,&lt;/p&gt;
&lt;h3&gt;git(github) 사용 장려&lt;/h3&gt;
&lt;p&gt;git을 접해보지 못했거나, 혹은 숙련되지 않은 분들을 위해 git을 의도적으로 사용하도록 하는 목적이 의도되었다. 물론 혼자서 git을 써볼 순 있으나, git의 진가는 여러 사람이 동시에 하나의 repository를 공유함으로써 나타난다고 생각한다. 혼자서 사용하게 되면 해피 케이스만 경험하기 때문이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_010_001.png&quot; alt=&quot;git contributions&quot;&gt;&lt;/p&gt;
&lt;h3&gt;회고 기고 및 부담감 주입&lt;/h3&gt;
&lt;p&gt;당시에는 회고를 돌아가면서 매주 한 명이 작성했는데 이로 인해 모임에 좀 더 적극적으로 참여할 수 있고, 다른 참가자의 목표에 대해 좀 더 관심을 갖게 하도록 하는 넛지가 있었다.&lt;/p&gt;
&lt;h3&gt;모각코 블로그 컨텐츠 생산&lt;/h3&gt;
&lt;p&gt;모각코 블로그에 컨텐츠 생상을 할 수 있는 계기가 되고 참여자의 기고를 통해 모임 운영에 참여를 이끌어 낼 수 있는 의도가 있었다.&lt;/p&gt;
&lt;h3&gt;하지만 이 회고를 각자 한다면?&lt;/h3&gt;
&lt;p&gt;퀵퀵가코, 모각코를 시작하기 전에 &lt;a href=&quot;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=187823405&quot;&gt;커리어 스킬&lt;/a&gt;이라는 책을 읽었다. 저자는 개발자에게 블로그가 얼마나 중요하고 커리어 발전에 도움이 되는지 입에 침이 마르도록 칭찬한다. 나는 이것을 보고 지금의 블로그를 시작하게 되었다. 그리고 회고록을 작성하기 위해 기존처럼 퀵퀵각코 블로그 구축을 github에 하고 있었다. 하지만 문뜩 드는 생각이 이 좋은 블로깅을 나만 할 수 없지 않는가. 블로깅을 하지 않는 참가자들에게 블로그를 하도록 조금의 동기 부여를 주고 싶었다. 그래서 모두에게 반드시 회고 플랫폼을 마련하도록 모임 시작전에 공지했다. 퀵퀵각코에서 정한 시작 전에 공지는 단 2개였다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;작고 실천가능 한 목표 구체화&lt;/li&gt;
&lt;li&gt;회고 플랫폼 마련&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;깃허브, 티스토리, 미디엄 등등 어느 플랫폼이든 상관없으나 단, &lt;code&gt;검색엔진에서 회고록이 검색이 되는 플랫폼이어야 한다&lt;/code&gt;가 전제 조건이었다.&lt;br&gt;
블로깅 초반에는 사실 &lt;strong&gt;컨텐츠 생산에 많은 어려움&lt;/strong&gt;이 따른다. 어떤 내용을 써야 할지도 모르겠고 글쓰기에 대한 부담이 상당해서 블로깅에서 점점 멀어지기 부지기수다. 그래서 이 진입장벽을 허물기 위해 회고를 작성하다 보면 늘어나는 포스팅에 조금은 뿌듯할 수 있고, 검색을 통해 유입자가 늘어나면 재미도 조금씩 붙을 것이라 생각했다.&lt;/p&gt;
&lt;p&gt;&lt;ExternalLink 
    href=&quot;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=187823405&quot;
    target=&quot;_blank&quot;
    src=&quot;https://image.aladin.co.kr/product/18782/34/cover500/k662635470_1.jpg&quot; 
    alt=&quot;커리어 스킬&quot; 
    width=&quot;200px&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;운영 리소스는 최대한 줄일 것&lt;/h2&gt;
&lt;p&gt;지난 모각코와 달리 이번에는 상대적으로 운영에 많은 시간을 투자하지 않았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;공간 예약과 출석 관리&lt;/li&gt;
&lt;li&gt;공용 회고 플랫폼 마련과 관리&lt;/li&gt;
&lt;li&gt;간식 준비&lt;/li&gt;
&lt;li&gt;그룹 관리&lt;/li&gt;
&lt;li&gt;발표 자료&lt;/li&gt;
&lt;li&gt;스티커 제작&lt;/li&gt;
&lt;li&gt;마지막 세미나 게스트 초대와 다과 준비 등&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위 리스트를 포함하여 많은 것을 혼자 운영했다. 덕분에 퀄리티 있는 모각코를 운영했고 참가자들의 만족도도 매우 높았다. 하지만 높은 운영 비용으로 인해 &lt;strong&gt;정작 내 목표는 달성하지 못했었다.&lt;/strong&gt; 참가자들은 자신의 목표 성과를 세미나에서 발표할 수 있었지만 나는 세미나에서 목표 달성하지 못한 반성문을 낭독하느라 매우 민망했다. 그래서 이번 퀵퀵각코에서는 운영에 최대한 리소스를 최대한 할당하지 않으려 고민했다.&lt;/p&gt;
&lt;h3&gt;4주라는 매우 짧은 기간제 모각코를 만들어 사이클을 빨리 운영하고자 했다.&lt;/h3&gt;
&lt;p&gt;모임 횟수는 12번이었지만 연말 행사로 인해 거의 4달짜리 기간제 모각코를 한 적이 있다. 모임 호흡이 늘어지고 목표를 바꾸게 되는 상황도 많았다. 또한 토이프로젝트는 짧게 짧게 시행착오를 겪는 것이 중요하다고 생각했다. 그래서 이번에는 시도해보지 않았던 4주로 책정했다.&lt;/p&gt;
&lt;p&gt;이번에 설정한 내 목표가 나와 맞지 않았다면 잠깐 쉬고 다시 새로운 목표를 시작하더라도 죄책감을 느끼지 않아도 된다. 모임 중간에 목표를 변경하게 되면 실패감과 새로운 목표에 대한 부담이 동시에 다가오기 때문이다.&lt;/p&gt;
&lt;h3&gt;모임 장소인 스터디룸을 저렴한 곳으로 모각코 총 인원만큼 예약했다.&lt;/h3&gt;
&lt;p&gt;해당 주차에 결석자가 발생하면 비용 낭비가 발생할 순 있지만 이 금액으로 인해 운영자와 참가자가 모두 출결에 독촉 받는 구조가 될 수 있어서 그런 스트레스는 없애는것이 더 중요하다고 판단했다.&lt;/p&gt;
&lt;h3&gt;회비는 오로지 스터디룸 예약 비용만 책정했다.&lt;/h3&gt;
&lt;p&gt;이전에는 간식비 등이 포함되었지만 이번에는 오로지 스터디룸 비용만 책정했다. 간식을 구매함에 있어 인원수를 알아야 하는데 그럼 결국 출결을 독촉받는 구조로 또 이어지게 된다. 또한 간식 당번을 운영하는 리소스가 들어가고 당번은 간식을 준비해야 하는 업무가 생기게 된다.&lt;/p&gt;
&lt;ResizeImage src=&quot;https://baek.dev/assets/images/post/2019/2019_010_002.jpg&quot; alt=&quot;처음이자 마지막 간식&quot; width=&quot;400px;&quot;/&gt;
&lt;p&gt;비용이 남아 마지막 모임에 간식을 준비했다. 서로 고민과 좋은 내용을 공유하면서 이번 퀵퀵각코를 마무리했다. 아쉬운 점도 분명 있었지만 새로운 시도를 통해 여러 경험을 해본 것 같아 만족스럽다. 즉석에서 익명으로 만족도 설문 조사를 통해 나온 &lt;code&gt;4주&lt;/code&gt;라는 기간에 대해-&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4주가 좋다는 분도&lt;/li&gt;
&lt;li&gt;8주는 해야하지 않겠냐는 분도 계셨고&lt;/li&gt;
&lt;li&gt;그 중간인 6주 운영에 대한 의견도 나왔다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;사실 기간은 너무 길지만 않으면 크게 중요하지 않은 것 같다. 목표를 이룰 수 있도록 서로 선의의 감시자가 되어주고 다독여주는 동료가 되어가는 것이 더 의미가 있는 것 같다.&lt;/p&gt;
&lt;p&gt;이제 목표 달성에 대한 부담감을 잠시 내려놓고 늦잠을 자거나 여가를 보낼 수 있도록 토요일 오전을 마음껏 즐겨야겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[쿠버네티스 Controller 살펴보기1 Deployment - 기초(4)]]></title><description><![CDATA[<blockquote>
<p>쿠버네티스 기초 시리즈</p>
<ul>
<li><a href="/post/5">쿠버네티스란 무엇인지 살펴보기 - 기초(1)</a></li>
<li><a href="/post/6">쿠버네티스 Object 살펴보기1 Pod/Service/Volume - 기초(2)</a></li>
<li><a href="/post/8">쿠버네티스 Object 살펴보기2 ConfigMap, Secret, Namespace, ResourceQuota, LimitRanger - 기초(3)</a></li>
<li><a href="/post/9">쿠버네티스 Controller 살펴보기1 Deployment - 기초(4)</a></li>
</ul>
</blockquote>
<h2>Controller 주요 기능</h2>
<h3>Auto Healing</h3>
<p>Pod 혹은 Node가 다운된 경우 즉각 새로운 Pod와 Node로 만들어주는 것</p>
<h3>Auto Scaling</h3>
<p>Pod의 리소스가 다 찬 경우 이 상태를 파악하여 새로운 파드를 만들어서 부하 분산 시켜줌</p>
<h3>Software Update</h3>
<p>여러 Pod에 대한 버전 업그레이드를 해야하는 경우 컨트롤러를 통해 한 번에 할 수 있음</p>
<p>업그레이드 도중 에러가 생기면 롤백 가능</p>
<h3>Job</h3>
<p>일시적인 작업을 해야하는 경우 일시적으로 Pod를 만들어서 종료하기때문에 자원 활용이 가능함</p>
<h2>ReplicaSet</h2>
<p>기존 Replication Controller(deprecated)이 ReplicaSet으로 변경 됨</p>
<h3>Template</h3>
<ul>
<li>Controller가 Pod를 생성할 때 사용할 Pod용 템플릿</li>
<li>버전을 업그레이드 하고자 할 때 이 템플릿을 변경하고 Pod를 다운 시키면 새로운 버전으로 Pod가 생성됨</li>
</ul>
<h3>Replicas</h3>
<ul>
<li>scale in/out에 관련한 옵션</li>
<li>pod template를 같이 정의하면 해당 템플릿으로 스케일-인/아웃이 일어남</li>
</ul>
<h3>Selector ( only ReplicaSet )</h3>
<ul>
<li>Pod를 select하기 위한 옵션</li>
<li>기존 replcation에서는 label이 정확히 일치해야만 Pod 연결이 가능했지만</li>
<li>
<p>ReplicaSet에서는 다양한 match옵션을 제공함</p>
<ul>
<li>Exists : Key가 일치하는 경우만, Vaule는 상관 없음</li>
<li>DoesNotExists : Key가 일치하지 않는 경우만, Vaule는 상관 없음</li>
<li>In : Key가 일치하는 경우만, 일치할 Vaules를 여러개 지정</li>
<li>NotIn : Key가 일치하는 경우만, 일치하지 않을 Vaules를 여러개 지정</li>
</ul>
</li>
</ul>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: replica1
spec:
  replicas: 1
  selector: # selector의 내용이 바로 아래의 template#labels에 포함되어야 함!
    matchLabels:
      type: web
      ver: v1
    matchExpressions:
      - { key: type, operator: In, values: [web] }
      - { key: ver, operator: Exists }
  template:
    metadata:
      labels:
        type: web
        ver: v1
        location: dev
    spec:
      containers:
        - name: container
          image: tmkube/app:v1
      terminationGracePeriodSeconds: 0 # Pod를 몇초 후에 삭제할지 옵션, default 30sec
</code></pre>
<pre><code class="language-yaml"># 컨트롤러 삭제 명령
# --cascade=false : Controller 삭제시 연결된 Pod도 함께 삭제 되는데, 이 옵션은 Pod는 남겨달라는 옵션
kubectl delete replicationcontrollers replication1 --cascade=false
</code></pre>
<h2>Deployment</h2>
<p>새로운 버전의 릴리스를 관리하는 객체로 애플리케이션의 특정 소프트웨어 버전보다 상위 버전으로 배포된 애플리케이션임</p>
<ul>
<li>ReCreate는 Downtime이 존재함</li>
<li>Rolling Update, Blue/Green, Canary는 zero downtime이지만 자원량이 배포시에 더 필요함</li>
</ul>
<h3>ReCreate 전략</h3>
<ul>
<li>deployment template에 버전을 올림</li>
<li>기존 ReplicaSet의 Pod를 제거</li>
<li>여기서 다운타임 발생</li>
<li>새로운 ReplicaSet을 만들어서 Pod를 생성시킴</li>
</ul>
<h3>Rolling Update 전략</h3>
<ul>
<li>새로운 ReplicaSet을 추가한 뒤 replicas를 1로 조정</li>
<li>그럼 기존 replicaSet + 신규 replicaSet으로 트래픽이 분산됨</li>
<li>기존 replicaSet의 replicas를 1로 변경하여 Pod를 하나 줄임</li>
<li>신규 replicaSet의 replicas를 1개 올리고</li>
<li>기존 replicaSet의 replicas를 0ㅇ로 변경하여 기존 Pod를 제거함</li>
</ul>
<h3>Blue/Green 전략</h3>
<ul>
<li>Blue와 Green group을 구분하여 기존 버전의 애플리케이션과 새로운 버전의 애플리케이션을 구분하여 스위칭</li>
</ul>
<h3>Canary 전략</h3>
<ul>
<li>카나리 전략은 광산에 산소 부족을 확인하기 위하여 산소 부족에 민감한 카나리아 새를 들고 들어가던 방식에서 유래함</li>
<li>새로운 버전의 애플리케이션을 1개의 레플리카 셋으로 기존 버전의 애플리케이션에 추가로 생성</li>
<li>에러나 장애가 없으면 새로운 버전의 애플리케이션의 레플리카 셋을 원하는 수만큼으로 늘림</li>
<li>기존 버전의 애플리케이션의 레플리카 셋을 0으로 조정하여 배포를 마침</li>
</ul>]]></description><link>https://baek.dev/post/9/</link><guid isPermaLink="false">https://baek.dev/post/9/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 27 Oct 2019 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;쿠버네티스 기초 시리즈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/post/5&quot;&gt;쿠버네티스란 무엇인지 살펴보기 - 기초(1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/6&quot;&gt;쿠버네티스 Object 살펴보기1 Pod/Service/Volume - 기초(2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/8&quot;&gt;쿠버네티스 Object 살펴보기2 ConfigMap, Secret, Namespace, ResourceQuota, LimitRanger - 기초(3)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/9&quot;&gt;쿠버네티스 Controller 살펴보기1 Deployment - 기초(4)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Controller 주요 기능&lt;/h2&gt;
&lt;h3&gt;Auto Healing&lt;/h3&gt;
&lt;p&gt;Pod 혹은 Node가 다운된 경우 즉각 새로운 Pod와 Node로 만들어주는 것&lt;/p&gt;
&lt;h3&gt;Auto Scaling&lt;/h3&gt;
&lt;p&gt;Pod의 리소스가 다 찬 경우 이 상태를 파악하여 새로운 파드를 만들어서 부하 분산 시켜줌&lt;/p&gt;
&lt;h3&gt;Software Update&lt;/h3&gt;
&lt;p&gt;여러 Pod에 대한 버전 업그레이드를 해야하는 경우 컨트롤러를 통해 한 번에 할 수 있음&lt;/p&gt;
&lt;p&gt;업그레이드 도중 에러가 생기면 롤백 가능&lt;/p&gt;
&lt;h3&gt;Job&lt;/h3&gt;
&lt;p&gt;일시적인 작업을 해야하는 경우 일시적으로 Pod를 만들어서 종료하기때문에 자원 활용이 가능함&lt;/p&gt;
&lt;h2&gt;ReplicaSet&lt;/h2&gt;
&lt;p&gt;기존 Replication Controller(deprecated)이 ReplicaSet으로 변경 됨&lt;/p&gt;
&lt;h3&gt;Template&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Controller가 Pod를 생성할 때 사용할 Pod용 템플릿&lt;/li&gt;
&lt;li&gt;버전을 업그레이드 하고자 할 때 이 템플릿을 변경하고 Pod를 다운 시키면 새로운 버전으로 Pod가 생성됨&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Replicas&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;scale in/out에 관련한 옵션&lt;/li&gt;
&lt;li&gt;pod template를 같이 정의하면 해당 템플릿으로 스케일-인/아웃이 일어남&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Selector ( only ReplicaSet )&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Pod를 select하기 위한 옵션&lt;/li&gt;
&lt;li&gt;기존 replcation에서는 label이 정확히 일치해야만 Pod 연결이 가능했지만&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ReplicaSet에서는 다양한 match옵션을 제공함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exists : Key가 일치하는 경우만, Vaule는 상관 없음&lt;/li&gt;
&lt;li&gt;DoesNotExists : Key가 일치하지 않는 경우만, Vaule는 상관 없음&lt;/li&gt;
&lt;li&gt;In : Key가 일치하는 경우만, 일치할 Vaules를 여러개 지정&lt;/li&gt;
&lt;li&gt;NotIn : Key가 일치하는 경우만, 일치하지 않을 Vaules를 여러개 지정&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: replica1
spec:
  replicas: 1
  selector: # selector의 내용이 바로 아래의 template#labels에 포함되어야 함!
    matchLabels:
      type: web
      ver: v1
    matchExpressions:
      - { key: type, operator: In, values: [web] }
      - { key: ver, operator: Exists }
  template:
    metadata:
      labels:
        type: web
        ver: v1
        location: dev
    spec:
      containers:
        - name: container
          image: tmkube/app:v1
      terminationGracePeriodSeconds: 0 # Pod를 몇초 후에 삭제할지 옵션, default 30sec
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# 컨트롤러 삭제 명령
# --cascade=false : Controller 삭제시 연결된 Pod도 함께 삭제 되는데, 이 옵션은 Pod는 남겨달라는 옵션
kubectl delete replicationcontrollers replication1 --cascade=false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Deployment&lt;/h2&gt;
&lt;p&gt;새로운 버전의 릴리스를 관리하는 객체로 애플리케이션의 특정 소프트웨어 버전보다 상위 버전으로 배포된 애플리케이션임&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ReCreate는 Downtime이 존재함&lt;/li&gt;
&lt;li&gt;Rolling Update, Blue/Green, Canary는 zero downtime이지만 자원량이 배포시에 더 필요함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ReCreate 전략&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;deployment template에 버전을 올림&lt;/li&gt;
&lt;li&gt;기존 ReplicaSet의 Pod를 제거&lt;/li&gt;
&lt;li&gt;여기서 다운타임 발생&lt;/li&gt;
&lt;li&gt;새로운 ReplicaSet을 만들어서 Pod를 생성시킴&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Rolling Update 전략&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;새로운 ReplicaSet을 추가한 뒤 replicas를 1로 조정&lt;/li&gt;
&lt;li&gt;그럼 기존 replicaSet + 신규 replicaSet으로 트래픽이 분산됨&lt;/li&gt;
&lt;li&gt;기존 replicaSet의 replicas를 1로 변경하여 Pod를 하나 줄임&lt;/li&gt;
&lt;li&gt;신규 replicaSet의 replicas를 1개 올리고&lt;/li&gt;
&lt;li&gt;기존 replicaSet의 replicas를 0ㅇ로 변경하여 기존 Pod를 제거함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Blue/Green 전략&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Blue와 Green group을 구분하여 기존 버전의 애플리케이션과 새로운 버전의 애플리케이션을 구분하여 스위칭&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Canary 전략&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;카나리 전략은 광산에 산소 부족을 확인하기 위하여 산소 부족에 민감한 카나리아 새를 들고 들어가던 방식에서 유래함&lt;/li&gt;
&lt;li&gt;새로운 버전의 애플리케이션을 1개의 레플리카 셋으로 기존 버전의 애플리케이션에 추가로 생성&lt;/li&gt;
&lt;li&gt;에러나 장애가 없으면 새로운 버전의 애플리케이션의 레플리카 셋을 원하는 수만큼으로 늘림&lt;/li&gt;
&lt;li&gt;기존 버전의 애플리케이션의 레플리카 셋을 0으로 조정하여 배포를 마침&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[쿠버네티스 Object 살펴보기2 ConfigMap, Secret, Namespace, ResourceQuota, LimitRanger - 기초(3)]]></title><description><![CDATA[<blockquote>
<p>쿠버네티스 기초 시리즈</p>
<ul>
<li><a href="/post/5">쿠버네티스란 무엇인지 살펴보기 - 기초(1)</a></li>
<li><a href="/post/6">쿠버네티스 Object 살펴보기1 Pod/Service/Volume - 기초(2)</a></li>
<li><a href="/post/8">쿠버네티스 Object 살펴보기2 ConfigMap, Secret, Namespace, ResourceQuota, LimitRanger - 기초(3)</a></li>
<li><a href="/post/9">쿠버네티스 Controller 살펴보기1 Deployment - 기초(4)</a></li>
</ul>
</blockquote>
<h2>Object ConfigMap, Secret</h2>
<p>개발시 테스트 하는 dev server와 실제 서비스를 운영하는 production server는 각각 환경 설정이 다를 수 있다. 이 때 각각의 이미지를 따로 운영하게 되면 환경 설정만 다른데 같은 이미지를 2배로 운영해야하는 부담이 따른다. 그래서 이 환경 설정을 외부에 전달받는 인자로 분리를 하고, 이미지에서는 이 값을 전달받아 사용하도록 하면 이미지는 한 개로만 운영한다.</p>
<p>외부로부터 전달받도록 사용하는 쿠버네티스 오브젝트가 바로 ConfigMap과 Sercret이다. vaule로 문자열, 파일을 정의할 수 있다. 환경 변수 방식은 한 번 주입되면 변경이 되지 않음을 주의해야한다. 반영이 되려면 Pod가 재생성 되어야 한다. 단, file을 voulme mount하는 경우 volume에 있는 file이 변경되면 변경이 가능하다.</p>
<h3>ConfigMap</h3>
<p>key와 value로 구성된 오브젝트로 무한이 넣을 수 있음</p>
<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: cm-dev
data:
  SSH: ‘false’ # boolean값으로 넣고자 할 때는 single quatation을 붙여줘야 함. 기본 string이기 때문
  User: dev
</code></pre>
<h3>Secret</h3>
<p>보안이 필요한 vaule를 저장하는 오브젝트로 메모리에 저장되고 최대 1MB까지만 사용할 수 있음 (pw는 base64 인코딩)</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Secret
metadata:
  name: sec-dev
data:
  Key: MTIzNA== #base64 encoding 필수. 하지 않은채로 값을 넣으면 에러가 발생함.
</code></pre>
<h3>Pod 생성시 ConfigMap과 Secret사용 예제</h3>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-1
spec:
  containers:
    - name: container
      image: tmkube/init
      envFrom:
        - configMapRef:
            name: cm-dev
        - secretRef:
            name: sec-dev
</code></pre>
<pre><code class="language-shell">in pod-1 $> env
Key=1234
</code></pre>
<h3>e.g.) 1.Create env file</h3>
<pre><code class="language-yaml">echo "Content" >> file-c.txt
kubectl create configmap cm-file --from-file=./file-c.txt
echo "Content" >> file-s.txt
kubectl create secret generic sec-file --from-file=./file-s.txt
</code></pre>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-file
spec:
  containers:
    - name: container
      image: tmkube/init
      env:
        - name: file-c
          valueFrom:
            configMapKeyRef:
              name: cm-file
              key: file-c.txt
        - name: file-s
          valueFrom:
            secretKeyRef:
              name: sec-file
              key: file-s.txt
</code></pre>
<pre><code class="language-shell">in pod-1 $> env
file:s=Content
</code></pre>
<h3>e.g.) 2 Volume Mount (File)</h3>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-mount
spec:
  containers:
  - name: container
    image: tmkube/init
    volumeMounts:
    - name: file-volume
      mountPath: /mount
  volumes:
  - name: file-volume
    configMap:
      name: cm-file

```shell
in pod-1 $> env
file:c=Content
file:s=Content
</code></pre>
<h2>Object - Namespace, ResourceQuota, LimitRange</h2>
<h3>Namespace</h3>
<ul>
<li>자원을 분할 하여 사용할 수 구분</li>
<li>동일한 이름의 Pod를 생성할 수 없음</li>
<li>다른 네임스페이스의 자원과 분리된 자원을 관리 할 수 있음</li>
<li>다른 네임스페이스의 Pod와 Service는 연결할 수 없음</li>
</ul>
<pre><code class="language-yaml"># Namespace
apiVersion: v1
kind: Namespace
metadata:
  name: nm-1
</code></pre>
<pre><code class="language-yaml"># Pod
apiVersion: v1
kind: Pod
metadata:
  name: pod-1
  namespace: nm-1
  labels:
    app: pod
spec:
  containers:
    - name: container
      image: tmkube/app
      ports:
        - containerPort: 8080
</code></pre>
<pre><code class="language-yaml"># Service
apiVersion: v1
kind: Service
metadata:
  name: svc-1
  namespace: nm-1
spec:
  selector:
    app: pod
  ports:
    - port: 9000
      targetPort: 8080
</code></pre>
<h3>ResourceQuota</h3>
<ul>
<li>네임 스페이스의 자원 limit을 설정할 수 있음</li>
<li>
<p>ResouceQuota가 명세된 네임스페이스 안에서 Pod는 반드시 reqeusts와 limits를 명세해야만 해당 네임스페이스로 들어올 수 있음</p>
<ul>
<li>제한 할 수 있는 자원은 cpu, memory, storage가 있고 Pod, service, configMap 등 오브젝트 개수도 제한 할 수 있음</li>
<li>쿠버네티스 버전에 따라 제한 할 수있는 오브젝트가 다름</li>
</ul>
</li>
</ul>
<pre><code class="language-yaml"># Namespace
apiVersion: v1
kind: Namespace
metadata:
  name: nm-3
</code></pre>
<pre><code class="language-yaml"># ResouceQuota
apiVersion: v1
kind: ResourceQuota
metadata:
  name: rq-1
  namespace: nm-3
spec:
  hard:
    requests.memory: 1Gi
    limits.memory: 1Gi
</code></pre>
<pre><code class="language-shell">    # ResourceQuota 확인
    $> kubectl describe resourcequotas --namespace=nm-3
</code></pre>
<pre><code class="language-yaml"># Pod
apiVersion: v1
kind: Pod
metadata:
  name: pod-3
spec:
  containers:
    - name: container
      image: tmkube/app
      resources:
        requests:
          memory: 0.5Gi
        limits:
          memory: 0.5Gi
</code></pre>
<h3>LimitRange</h3>
<ul>
<li>Namespace에 들어올 수 있는 Pod의 용량을 제한 할 수 있음</li>
<li>
<p>종류</p>
<ul>
<li>min : 최소</li>
<li>max : 최대</li>
<li>maxLimitRequestRatio : request값과 limits의 비율이 최대 설정된 값을 넘지 않아야 함</li>
</ul>
</li>
</ul>
<pre><code class="language-yaml"># Namespace
apiVersion: v1
kind: Namespace
metadata:
  name: nm-5
</code></pre>
<pre><code class="language-yaml"># LimitRange
apiVersion: v1
kind: LimitRange
metadata:
  name: lr-1
spec:
  limits:
    - type: Container
      min:
        memory: 0.1Gi
      max:
        memory: 0.4Gi
      maxLimitRequestRatio:
        memory: 3
      defaultRequest:
        memory: 0.1Gi
      default:
        memory: 0.2Gi
</code></pre>
<pre><code class="language-shell">$> kubectl describe limitranges --namespace=nm-5
</code></pre>
<pre><code class="language-yaml"># Pod
apiVersion: v1
kind: Pod
metadata:
  name: pod-1
spec:
  containers:
    - name: container
      image: tmkube/app
      resources:
        requests:
          memory: 0.1Gi
        limits:
          memory: 0.5Gi
</code></pre>]]></description><link>https://baek.dev/post/8/</link><guid isPermaLink="false">https://baek.dev/post/8/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Tue, 15 Oct 2019 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;쿠버네티스 기초 시리즈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/post/5&quot;&gt;쿠버네티스란 무엇인지 살펴보기 - 기초(1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/6&quot;&gt;쿠버네티스 Object 살펴보기1 Pod/Service/Volume - 기초(2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/8&quot;&gt;쿠버네티스 Object 살펴보기2 ConfigMap, Secret, Namespace, ResourceQuota, LimitRanger - 기초(3)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/9&quot;&gt;쿠버네티스 Controller 살펴보기1 Deployment - 기초(4)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Object ConfigMap, Secret&lt;/h2&gt;
&lt;p&gt;개발시 테스트 하는 dev server와 실제 서비스를 운영하는 production server는 각각 환경 설정이 다를 수 있다. 이 때 각각의 이미지를 따로 운영하게 되면 환경 설정만 다른데 같은 이미지를 2배로 운영해야하는 부담이 따른다. 그래서 이 환경 설정을 외부에 전달받는 인자로 분리를 하고, 이미지에서는 이 값을 전달받아 사용하도록 하면 이미지는 한 개로만 운영한다.&lt;/p&gt;
&lt;p&gt;외부로부터 전달받도록 사용하는 쿠버네티스 오브젝트가 바로 ConfigMap과 Sercret이다. vaule로 문자열, 파일을 정의할 수 있다. 환경 변수 방식은 한 번 주입되면 변경이 되지 않음을 주의해야한다. 반영이 되려면 Pod가 재생성 되어야 한다. 단, file을 voulme mount하는 경우 volume에 있는 file이 변경되면 변경이 가능하다.&lt;/p&gt;
&lt;h3&gt;ConfigMap&lt;/h3&gt;
&lt;p&gt;key와 value로 구성된 오브젝트로 무한이 넣을 수 있음&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: ConfigMap
metadata:
  name: cm-dev
data:
  SSH: ‘false’ # boolean값으로 넣고자 할 때는 single quatation을 붙여줘야 함. 기본 string이기 때문
  User: dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Secret&lt;/h3&gt;
&lt;p&gt;보안이 필요한 vaule를 저장하는 오브젝트로 메모리에 저장되고 최대 1MB까지만 사용할 수 있음 (pw는 base64 인코딩)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: Secret
metadata:
  name: sec-dev
data:
  Key: MTIzNA== #base64 encoding 필수. 하지 않은채로 값을 넣으면 에러가 발생함.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Pod 생성시 ConfigMap과 Secret사용 예제&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: Pod
metadata:
  name: pod-1
spec:
  containers:
    - name: container
      image: tmkube/init
      envFrom:
        - configMapRef:
            name: cm-dev
        - secretRef:
            name: sec-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;in pod-1 $&gt; env
Key=1234
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;e.g.) 1.Create env file&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;echo &quot;Content&quot; &gt;&gt; file-c.txt
kubectl create configmap cm-file --from-file=./file-c.txt
echo &quot;Content&quot; &gt;&gt; file-s.txt
kubectl create secret generic sec-file --from-file=./file-s.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: Pod
metadata:
  name: pod-file
spec:
  containers:
    - name: container
      image: tmkube/init
      env:
        - name: file-c
          valueFrom:
            configMapKeyRef:
              name: cm-file
              key: file-c.txt
        - name: file-s
          valueFrom:
            secretKeyRef:
              name: sec-file
              key: file-s.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;in pod-1 $&gt; env
file:s=Content
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;e.g.) 2 Volume Mount (File)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: Pod
metadata:
  name: pod-mount
spec:
  containers:
  - name: container
    image: tmkube/init
    volumeMounts:
    - name: file-volume
      mountPath: /mount
  volumes:
  - name: file-volume
    configMap:
      name: cm-file

```shell
in pod-1 $&gt; env
file:c=Content
file:s=Content
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Object - Namespace, ResourceQuota, LimitRange&lt;/h2&gt;
&lt;h3&gt;Namespace&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;자원을 분할 하여 사용할 수 구분&lt;/li&gt;
&lt;li&gt;동일한 이름의 Pod를 생성할 수 없음&lt;/li&gt;
&lt;li&gt;다른 네임스페이스의 자원과 분리된 자원을 관리 할 수 있음&lt;/li&gt;
&lt;li&gt;다른 네임스페이스의 Pod와 Service는 연결할 수 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# Namespace
apiVersion: v1
kind: Namespace
metadata:
  name: nm-1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# Pod
apiVersion: v1
kind: Pod
metadata:
  name: pod-1
  namespace: nm-1
  labels:
    app: pod
spec:
  containers:
    - name: container
      image: tmkube/app
      ports:
        - containerPort: 8080
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# Service
apiVersion: v1
kind: Service
metadata:
  name: svc-1
  namespace: nm-1
spec:
  selector:
    app: pod
  ports:
    - port: 9000
      targetPort: 8080
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ResourceQuota&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;네임 스페이스의 자원 limit을 설정할 수 있음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ResouceQuota가 명세된 네임스페이스 안에서 Pod는 반드시 reqeusts와 limits를 명세해야만 해당 네임스페이스로 들어올 수 있음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;제한 할 수 있는 자원은 cpu, memory, storage가 있고 Pod, service, configMap 등 오브젝트 개수도 제한 할 수 있음&lt;/li&gt;
&lt;li&gt;쿠버네티스 버전에 따라 제한 할 수있는 오브젝트가 다름&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# Namespace
apiVersion: v1
kind: Namespace
metadata:
  name: nm-3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# ResouceQuota
apiVersion: v1
kind: ResourceQuota
metadata:
  name: rq-1
  namespace: nm-3
spec:
  hard:
    requests.memory: 1Gi
    limits.memory: 1Gi
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;    # ResourceQuota 확인
    $&gt; kubectl describe resourcequotas --namespace=nm-3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# Pod
apiVersion: v1
kind: Pod
metadata:
  name: pod-3
spec:
  containers:
    - name: container
      image: tmkube/app
      resources:
        requests:
          memory: 0.5Gi
        limits:
          memory: 0.5Gi
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;LimitRange&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Namespace에 들어올 수 있는 Pod의 용량을 제한 할 수 있음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;종류&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;min : 최소&lt;/li&gt;
&lt;li&gt;max : 최대&lt;/li&gt;
&lt;li&gt;maxLimitRequestRatio : request값과 limits의 비율이 최대 설정된 값을 넘지 않아야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# Namespace
apiVersion: v1
kind: Namespace
metadata:
  name: nm-5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# LimitRange
apiVersion: v1
kind: LimitRange
metadata:
  name: lr-1
spec:
  limits:
    - type: Container
      min:
        memory: 0.1Gi
      max:
        memory: 0.4Gi
      maxLimitRequestRatio:
        memory: 3
      defaultRequest:
        memory: 0.1Gi
      default:
        memory: 0.2Gi
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$&gt; kubectl describe limitranges --namespace=nm-5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# Pod
apiVersion: v1
kind: Pod
metadata:
  name: pod-1
spec:
  containers:
    - name: container
      image: tmkube/app
      resources:
        requests:
          memory: 0.1Gi
        limits:
          memory: 0.5Gi
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title><![CDATA[[리뷰] 나는 LINE 개발자입니다 - 라인 개발자의 일상을 간접 경험해볼 수 있다]]></title><description><![CDATA[<p><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=204587884">&#x3C;나는 LINE 개발자입니다></a> 책은 라인의 여러 분야의 개발자들이 어떻게 커리어를 쌓았고 어떻게 라인에서 일하는지에 대한 책이다. 라인의 솔루션 아키텍트, 보안 서비스, 메시징 서비스, 커뮤니케이션 서버, 동영상 생중계 플랫폼, 딜리버리 플랫폼, 라인파이낸셜플러스, 블록체인, 테크니컬 라이터, 에반젤리스트 등 다양한 분야의 개발자가 가져왔던 고민과 경험을 간접적으로 경험해볼 수 있는 책이다.</p>
<p>이 책은 마치 우리가 기대하는 바를 꿰뚫어 보기라도 한 것처럼 <strong>라인에 입사하는 비책과 같은 내용은 없다고 책 초반부터 강조</strong>한다. 하지만 나는 <strong>이 책을 다 읽고 나니 실제 라인의 개발자들이 어떻게 일하는지 알게 되었고, 그들이 일하는 방법에서 라인 개발자라면 필요한 덕목을 짐작</strong>할 수 있다. 라인 입사에 희망하는 분들은 이 책을 반드시 읽겠지만, 꼭 입사 희망자가 아니더라도 다음과 같은 상황에 있는 분들도 읽어두면 좋은 내용이다.</p>
<blockquote>
<ul>
<li>대용량 트래픽 혹은 특정 이벤트에 트래픽 집중되는 시스템을 처음 겪거나 혹은 아직 겪어 보지 못한 분</li>
<li>글로벌 서비스를 하면서 준비해야 할 개괄적인 내용</li>
<li>개발 직군 내에서 직무 변화를 고민 중</li>
<li>테크니컬 라이터 혹은 에반젤리스트 등 상대적으로 정보를 얻기 힘들었던 직군</li>
</ul>
</blockquote>
<p>총 12명의 라인 개발자들의 이야기를 단숨에 후루룩 읽을 수 있었다.</p>
<p>특히 많이 공감되고 인상에 남는 부분이 몇 군데 있었는데 그중 간략히 공유를 해보자면 나는 일단 <code>하태호</code>님이 가장 인상 깊었다. 라인에서 태호봇(bot)이라는 별명을 가진 하태호님은 <strong>주니어 개발자의 성장기와 개발 공부 팁</strong>이라는 주제로 이야기를 시작했다.</p>
<p>개발자 중에서도 서버 개발자가 되고 싶었던 주니어 개발자 하태호님은 깊은 고민을 통해 문제를 실질적으로 해결해나가는 영역은 서버 개발 부분에서 많이 진행되고 있다고 생각해 서버 개발자가 되었다고 한다. 특히 시대적 변화에 부응하는 좋은 서버 개발자가 되기 위해서는 <code>대규모 인프라와 트래픽을 감당할 수 있는 역량을 갖춰야</code> 한다고 생각했고 <strong>이러한 역량은 개인의 노력만으로는 획득할 수 없기에</strong> 이런 점을 소화할 수 있는 개발팀에 일하기를 소망했다.</p>
<p>그렇게 라인에 입사한 하태호님은 <code>라인의 코드 리뷰 문화, 장애 리뷰 문화를 장점</code>으로 꼽았다. 코드 리뷰를 통해 내가 미처 생각지 못했던 버그를 잡을 수 있고, 여러 개발자들이 서로 의견을 나누며 더 좋은 방향에 대해 고민함으로써 서로 배우며 성장할 수 있다고 한다. 특히 코드 리뷰를 하게 되면 버그나 장애 발생 시 그 피처의 오너에게 책임을 추궁하기보다는 리뷰를 통해 우리 모두가 미처 발견하지 못한 점이라고 리뷰이를 탓하지 않게 된다는 것이다. 장애가 발생하면 우리 시스템의 어느 부분이 부족했는지 논의하고 향후 개선 방향에 대해서만 계속 고민을 하는 문화라서 서로를 탓하는데 시간을 낭비하지 않고 다 함께 문제를 빠르게 해결하기 위해 집중한다고 한다.</p>
<p>나도 이 부분에 적극 공감하며 지금 재직 중인 회사에서도 이런 제도가 있다. 항상 배포하기 전 반드시 코드 리뷰를 하고 thumb up을 받아야만 배포를 나갈 수가 있다. 아직 동료들과 코드 리뷰를 경험하기 이전분들 중에서는 '그런 방식이 배포에 걸림돌이 될 수 있지 않냐, 시간이 많이 소요될 것 같다'라고 생각할 수도 있다. 물론 리뷰로 인해 시간이 더 소요되는 것은 필연적인 것이다. 하지만 이로 인해 얻는 점은 무궁무진하다.</p>
<p>그 중 제일은 장애 및 버그를 미연에 방지할 수 있다.<br>
장애와 버그가 어느 정도 수용 가능한 시스템도 있지만 반대로 그렇지 않아야 하는 시스템도 있다. 실시간 주문을 처리해야하거나, 고객 접점에 위치해 고객 경험을 해칠 수 있거나 혹은 정산 시스템 등 이런 시스템들은 장애나 버그 발생 후 재처리하는 시스템을 갖추고 있지 않으면 failover하는데 많은 시간이 소요된다. 그렇게 되면 <strong>배포하다 장애를 경험한 개발자는 점점 자신감을 잃게 되고 배포를 두려워하게 되는 지경에 까지</strong> 이르게 된다.</p>
<p>또한 해당 배포 피처의 오너는 개발을 진행하는 동안 코드가 너무 익숙해진 나머지 억지스러운 코드나 구조를 미처 인지하지 못해 스파게티 코드가 되고 이 코드에 개발자가 끌려가게 된다. 이런 코드는 개발이 거듭될수록 개발 비용이 증가하고 훗날 장애시 디버깅을 하기도 어려워진다. 그래서 동료와 코드 리뷰를 하거나 페어 프로그래밍을 하기 어려운 경우라면 <strong>고무 오리 문제 해결법</strong><sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>을 시도해보는 것도 좋다.</p>
<p><img src="https://baek.dev/assets/images/post/2019/2019_007_002.jpg" alt="개발자 블로깅이 필요한 이유 - 박민우님 편"></p>
<blockquote>
<p>개발자는 게을러야 한다.</p>
</blockquote>
<p>이 말을 들어본 적이 있을 것이다. 게으른 개발자는 반복적인 작업을 귀찮아해 자동화를 하게 된다.<br>
앞서 언급했듯 태호봇이라는 별명을 가진 하태호님은 반복적인 작업을 자동화하고 팀 문화에 기여하게 될 때 재미와 보람을 느낀다고 한다. 이렇게 소소하지만, 문화를 바꾸는 개발도 있지만, 업무에서는 문제 해결을 위한 도전을 매일매일하고 있다고 한다. 기술의 깊이를 높이기 위해 평소에도 기술 블로그나 뉴스를 꾸준히 읽으려고 노력하는 편이라고 한다. 다른 개발자가 쓴 해결책을 100% 다 이해하지 못하더라도 그들이 접한 문제와 해결을 위해 접근한 방법을 보는 것만으로 배우는 것이 많기 때문이다. <a href="https://awesome-devblog.netlify.com/">awesome-devblog</a>는 국내외 기술 블로그를 아카이빙해놓은 사이트라 추천한다.</p>
<p>&#x3C;나는 LINE 개발자입니다> 책을 읽다 보면 다른 개발자의 일상을 함께 지낸 기분이 든다. 그들은 현실에 안주하지 않고 항상 나름의 루틴과 함께 매일의 도전을 즐기며 글로벌로 나아가고 있다. 많이 공감했고 많이 자극 된 책이다. 시간 이 좀 더 흘러 &#x3C;나는 LINE 개발자입니다2> 가 발간되면 좋겠다.</p>
<p><img src="https://baek.dev/assets/images/post/2019/2019_007_001.jpg" alt="나는 LINE 개발자입니다."></p>
<div class="footnotes">
<hr>
<ol>
<li id="fn-1">
<p><a href="https://wikibook.co.kr/article/rubber-duck-problem-solving/">위키북스 - 고무 오리 문제 해결법</a></p>
<a href="#fnref-1" class="footnote-backref">↩</a>
</li>
</ol>
</div>]]></description><link>https://baek.dev/post/7/</link><guid isPermaLink="false">https://baek.dev/post/7/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Mon, 14 Oct 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=204587884&quot;&gt;&amp;#x3C;나는 LINE 개발자입니다&gt;&lt;/a&gt; 책은 라인의 여러 분야의 개발자들이 어떻게 커리어를 쌓았고 어떻게 라인에서 일하는지에 대한 책이다. 라인의 솔루션 아키텍트, 보안 서비스, 메시징 서비스, 커뮤니케이션 서버, 동영상 생중계 플랫폼, 딜리버리 플랫폼, 라인파이낸셜플러스, 블록체인, 테크니컬 라이터, 에반젤리스트 등 다양한 분야의 개발자가 가져왔던 고민과 경험을 간접적으로 경험해볼 수 있는 책이다.&lt;/p&gt;
&lt;p&gt;이 책은 마치 우리가 기대하는 바를 꿰뚫어 보기라도 한 것처럼 &lt;strong&gt;라인에 입사하는 비책과 같은 내용은 없다고 책 초반부터 강조&lt;/strong&gt;한다. 하지만 나는 &lt;strong&gt;이 책을 다 읽고 나니 실제 라인의 개발자들이 어떻게 일하는지 알게 되었고, 그들이 일하는 방법에서 라인 개발자라면 필요한 덕목을 짐작&lt;/strong&gt;할 수 있다. 라인 입사에 희망하는 분들은 이 책을 반드시 읽겠지만, 꼭 입사 희망자가 아니더라도 다음과 같은 상황에 있는 분들도 읽어두면 좋은 내용이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;대용량 트래픽 혹은 특정 이벤트에 트래픽 집중되는 시스템을 처음 겪거나 혹은 아직 겪어 보지 못한 분&lt;/li&gt;
&lt;li&gt;글로벌 서비스를 하면서 준비해야 할 개괄적인 내용&lt;/li&gt;
&lt;li&gt;개발 직군 내에서 직무 변화를 고민 중&lt;/li&gt;
&lt;li&gt;테크니컬 라이터 혹은 에반젤리스트 등 상대적으로 정보를 얻기 힘들었던 직군&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;총 12명의 라인 개발자들의 이야기를 단숨에 후루룩 읽을 수 있었다.&lt;/p&gt;
&lt;p&gt;특히 많이 공감되고 인상에 남는 부분이 몇 군데 있었는데 그중 간략히 공유를 해보자면 나는 일단 &lt;code&gt;하태호&lt;/code&gt;님이 가장 인상 깊었다. 라인에서 태호봇(bot)이라는 별명을 가진 하태호님은 &lt;strong&gt;주니어 개발자의 성장기와 개발 공부 팁&lt;/strong&gt;이라는 주제로 이야기를 시작했다.&lt;/p&gt;
&lt;p&gt;개발자 중에서도 서버 개발자가 되고 싶었던 주니어 개발자 하태호님은 깊은 고민을 통해 문제를 실질적으로 해결해나가는 영역은 서버 개발 부분에서 많이 진행되고 있다고 생각해 서버 개발자가 되었다고 한다. 특히 시대적 변화에 부응하는 좋은 서버 개발자가 되기 위해서는 &lt;code&gt;대규모 인프라와 트래픽을 감당할 수 있는 역량을 갖춰야&lt;/code&gt; 한다고 생각했고 &lt;strong&gt;이러한 역량은 개인의 노력만으로는 획득할 수 없기에&lt;/strong&gt; 이런 점을 소화할 수 있는 개발팀에 일하기를 소망했다.&lt;/p&gt;
&lt;p&gt;그렇게 라인에 입사한 하태호님은 &lt;code&gt;라인의 코드 리뷰 문화, 장애 리뷰 문화를 장점&lt;/code&gt;으로 꼽았다. 코드 리뷰를 통해 내가 미처 생각지 못했던 버그를 잡을 수 있고, 여러 개발자들이 서로 의견을 나누며 더 좋은 방향에 대해 고민함으로써 서로 배우며 성장할 수 있다고 한다. 특히 코드 리뷰를 하게 되면 버그나 장애 발생 시 그 피처의 오너에게 책임을 추궁하기보다는 리뷰를 통해 우리 모두가 미처 발견하지 못한 점이라고 리뷰이를 탓하지 않게 된다는 것이다. 장애가 발생하면 우리 시스템의 어느 부분이 부족했는지 논의하고 향후 개선 방향에 대해서만 계속 고민을 하는 문화라서 서로를 탓하는데 시간을 낭비하지 않고 다 함께 문제를 빠르게 해결하기 위해 집중한다고 한다.&lt;/p&gt;
&lt;p&gt;나도 이 부분에 적극 공감하며 지금 재직 중인 회사에서도 이런 제도가 있다. 항상 배포하기 전 반드시 코드 리뷰를 하고 thumb up을 받아야만 배포를 나갈 수가 있다. 아직 동료들과 코드 리뷰를 경험하기 이전분들 중에서는 &apos;그런 방식이 배포에 걸림돌이 될 수 있지 않냐, 시간이 많이 소요될 것 같다&apos;라고 생각할 수도 있다. 물론 리뷰로 인해 시간이 더 소요되는 것은 필연적인 것이다. 하지만 이로 인해 얻는 점은 무궁무진하다.&lt;/p&gt;
&lt;p&gt;그 중 제일은 장애 및 버그를 미연에 방지할 수 있다.&lt;br&gt;
장애와 버그가 어느 정도 수용 가능한 시스템도 있지만 반대로 그렇지 않아야 하는 시스템도 있다. 실시간 주문을 처리해야하거나, 고객 접점에 위치해 고객 경험을 해칠 수 있거나 혹은 정산 시스템 등 이런 시스템들은 장애나 버그 발생 후 재처리하는 시스템을 갖추고 있지 않으면 failover하는데 많은 시간이 소요된다. 그렇게 되면 &lt;strong&gt;배포하다 장애를 경험한 개발자는 점점 자신감을 잃게 되고 배포를 두려워하게 되는 지경에 까지&lt;/strong&gt; 이르게 된다.&lt;/p&gt;
&lt;p&gt;또한 해당 배포 피처의 오너는 개발을 진행하는 동안 코드가 너무 익숙해진 나머지 억지스러운 코드나 구조를 미처 인지하지 못해 스파게티 코드가 되고 이 코드에 개발자가 끌려가게 된다. 이런 코드는 개발이 거듭될수록 개발 비용이 증가하고 훗날 장애시 디버깅을 하기도 어려워진다. 그래서 동료와 코드 리뷰를 하거나 페어 프로그래밍을 하기 어려운 경우라면 &lt;strong&gt;고무 오리 문제 해결법&lt;/strong&gt;&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;을 시도해보는 것도 좋다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_007_002.jpg&quot; alt=&quot;개발자 블로깅이 필요한 이유 - 박민우님 편&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;개발자는 게을러야 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 말을 들어본 적이 있을 것이다. 게으른 개발자는 반복적인 작업을 귀찮아해 자동화를 하게 된다.&lt;br&gt;
앞서 언급했듯 태호봇이라는 별명을 가진 하태호님은 반복적인 작업을 자동화하고 팀 문화에 기여하게 될 때 재미와 보람을 느낀다고 한다. 이렇게 소소하지만, 문화를 바꾸는 개발도 있지만, 업무에서는 문제 해결을 위한 도전을 매일매일하고 있다고 한다. 기술의 깊이를 높이기 위해 평소에도 기술 블로그나 뉴스를 꾸준히 읽으려고 노력하는 편이라고 한다. 다른 개발자가 쓴 해결책을 100% 다 이해하지 못하더라도 그들이 접한 문제와 해결을 위해 접근한 방법을 보는 것만으로 배우는 것이 많기 때문이다. &lt;a href=&quot;https://awesome-devblog.netlify.com/&quot;&gt;awesome-devblog&lt;/a&gt;는 국내외 기술 블로그를 아카이빙해놓은 사이트라 추천한다.&lt;/p&gt;
&lt;p&gt;&amp;#x3C;나는 LINE 개발자입니다&gt; 책을 읽다 보면 다른 개발자의 일상을 함께 지낸 기분이 든다. 그들은 현실에 안주하지 않고 항상 나름의 루틴과 함께 매일의 도전을 즐기며 글로벌로 나아가고 있다. 많이 공감했고 많이 자극 된 책이다. 시간 이 좀 더 흘러 &amp;#x3C;나는 LINE 개발자입니다2&gt; 가 발간되면 좋겠다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_007_001.jpg&quot; alt=&quot;나는 LINE 개발자입니다.&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://wikibook.co.kr/article/rubber-duck-problem-solving/&quot;&gt;위키북스 - 고무 오리 문제 해결법&lt;/a&gt;&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[쿠버네티스 Object 살펴보기1 Pod/Service/Volume - 기초(2)]]></title><description><![CDATA[<blockquote>
<p>쿠버네티스 기초 시리즈</p>
<ul>
<li><a href="/post/5">쿠버네티스란 무엇인지 살펴보기 - 기초(1)</a></li>
<li><a href="/post/6">쿠버네티스 Object 살펴보기1 Pod/Service/Volume - 기초(2)</a></li>
<li><a href="/post/8">쿠버네티스 Object 살펴보기2 ConfigMap, Secret, Namespace, ResourceQuota, LimitRange - 기초(3)</a></li>
<li><a href="/post/9">쿠버네티스 Controller 살펴보기1 Deployment - 기초(4)</a></li>
</ul>
</blockquote>
<h2>What is Kubernetes Object?</h2>
<p>이전 포스팅에서는 쿠버네티스가 무엇인지 간략하게 살펴보았습니다. 쿠버네티스는 시스템의 상태를 나타내는 <code>오브젝트(Object)</code>라는 영구 엔티티라는 개념이 있습니다. 오브젝트는 의도를 담은 레코드로, 객체가 존재하도록 지속적으로 작동하게 됩니다. 오브젝트를 사용, 생성, 수정 또는 삭제하기 위해서 Kubernetes API를 사용하게 됩니다.</p>
<p>오브젝트는 크게 다음과 같은 의미를 갖습니다.</p>
<ul>
<li>컨테이너화 된 애플리케이션이 실행중인 노드</li>
<li>해당 응용 프로그램에서 사용 가능한 리소스</li>
<li>재시작 정책, 업그레이드 및 내결함성과 같은 해당 응용 프로그램의 동작 방식에 대한 정책</li>
</ul>
<p>가장 보편적으로 사용되는 오브젝트를 기술 방법은 <code>.yaml</code>을 이용하게 됩니다.</p>
<pre><code class="language-yaml">apiVersion: apps/v1 # apps/v1beta2를 사용하는 1.9.0보다 더 이전의 버전용
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2 # 템플릿에 매칭되는 파드 2개를 구동하는 디플로이먼트임
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx:1.7.9
          ports:
            - containerPort: 80
</code></pre>
<h3>Namespace</h3>
<p>쿠버네티스는 동일 물리 클러스터를 기반으로 하는 복수의 가상 클러스터를 지원하는데, 이 가상 클러스터를 네이스페이스라고 칭합니다. 여러개의 팀이나 프로젝트에 걸쳐 많은 사용자가 있는 환경에서 사용하도록 만들어졌습니다.</p>
<h3>Label</h3>
<p>레이블은 목적에 따라 오브젝트들을 분류하고 분류된 오브젝트들만 따로 연결하기 위해 사용합니다. Pod와 같은 오브젝트에 첨부된 key&#x26;value로 이뤄집니다.<br>
레이블은 오브젝트의 특성을 식별하는데 사용되어 사용자에게 중요하지만, 코어 시스템에게는 직접적인 의미가 없습니다. 이 레이블을 이용하면 오브젝트 하위 집합을 선택하는데 있어 용이합니다. 즉, 사용자가 느슨하게 결합한 방식으로 조직 구조와 시스템 오브젝트를 매핑할 수 있습니다.<br>
더불어 레이블을 이용하면 dev zone과 production zone을 나눠서 셋팅할 수 있습니다.</p>
<h2>Pod</h2>
<p>Pod는 쿠버네티스의 최소 배포 단위로 클러스터에서의 Running Process를 나타냅니다.<br>
Namespace는 이 Pod들을 연결해주고 각각 ip를 할당해주는 역할을 하고, 서로 다른 네임스페이스의 Pod들은 연결 할 수 없습니다.</p>
<ul>
<li>Pod안에는 여러 컨테이너가 들어갈 수 있으므로 여러 앱을 띄울 수 있습니다.</li>
<li>
<p>만약 Pod에 에러가 있어서 재생성되면 Pod내의 데이터가 날아갈 수 있습니다.</p>
<ul>
<li>그래서 Volume을 따로 잡아서 데이터를 별도로 저장합니다.</li>
</ul>
</li>
</ul>
<p>쿠버네티스 클러스터 내부의 파드는 주로 두 가지 방법으로 사용되는데,</p>
<ol>
<li>
<p><strong>단일 컨테이너만 동작하는 파드</strong></p>
<ul>
<li>가장 많이 사용되는 사례로, 한 개의 파드가 단일 컨테이너를 감사고 있음</li>
</ul>
</li>
<li>
<p>함께 동작하는 작업이 필요한 다중 컨테이너가 동작하는 파드</p>
<ul>
<li>리소스 공유가 필요한 다중으로 함께 배치된 컨테이너로 구성됨</li>
</ul>
</li>
</ol>
<pre><code class="language-yaml"># Pod 명세 예시
apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
    - name: myapp-container
      image: busybox
      command: ["sh", "-c", "echo 안녕하세요 쿠버네티스! &#x26;&#x26; sleep 3600"]
</code></pre>
<h3>Container</h3>
<p>하나의 Pod안에 여러 컨테이너를 가질 수 있습니다. 각 Container는 Port를 갖지만 서로 같은 Port를 가질 수는 없습니다.</p>
<h2>Service</h2>
<p>내부에서만 접근할 수 있는 Pod들을 응용 프로그램으로 표시하는 네트워크 서비스를 뜻합니다.<br>
Pod는 각각의 고유한 ip주소를 갖지만 Auto-Healing 혹은 재배포 등으로 인해 <code>재생성된 Pod는 때마다 새로운 ip를 부여</code> 받게 됩니다. 새롭게 생성된 Pod 세트에 대한 단일 DNS이름을 제공하고 이들 간에 로드 밸런스를 수행합니다.</p>
<h3>ClusterIP</h3>
<ul>
<li>
<p>쿠버네티스 클러스터 내에서만 접근이 가능한 IP</p>
<ul>
<li>→ 운영자와 같은 인가된 사람만 접근</li>
<li>→ 내부 대쉬보드</li>
<li>→ 각 Pod 디버깅</li>
</ul>
</li>
<li>클러스터 내에서 다른 오브젝트들이 접근 할 수있음</li>
<li>
<p>Q. Pod에도 클러스터 내에서 접근 할 수 있는 IP가 있고 Service에는 자신의 클러스터 IP가 있는데 굳이 Serive를 다는 이유는?</p>
<ul>
<li>→ Pod는 휘발성 IP, 언제든지 삭제 되고 재생성 될 수 있고, 그 때마다 ip가 새로 할당 됨</li>
<li>→ Service는 사용자가 직접 지우지 않는한 삭제되거나 재생성되지 않음. 항상 연결되어 있는 Pod에 접근 가능함</li>
<li>→ 여러개의 Pod를 연결시켰을 때 Service가 트래픽을 분산시킴</li>
</ul>
</li>
</ul>
<h3>NodePort</h3>
<ul>
<li>내부망 연결, 클러스터 밖에 있지만 내부 네트워크 접근 전용</li>
<li>일부 데모 등을 위해 네트워크 중계기에 포트 포워딩을 통해 임시로 열어서 접근 하기도 함</li>
<li>기본적으로 ClusterIP가 할당되고 같은 기능을 함</li>
<li>쿠버네티스 클러스터한테 연결되어 있는 모든 노드한테 똑같은 Port를 할당함</li>
<li>어느 노드이던 간에 접근을 하면 Service로 연결이 되고 Service는 어느 노드로 들어왔다고 하더라도 자신한테 연결된 Pod에 트래픽을 전달</li>
<li>Pod가 있는 노드만 포트가 생기는 것이 아니라 Pod가 없는 노드여도 포트 할당이 됨</li>
<li><code>externalTrafficPolicy: Local</code> → 특정 노드 포트의 IP로 접근하는 트래픽은 해당 노드에 있는 POD로만 트래픽을 줌</li>
</ul>
<h3>Load Balancer</h3>
<ul>
<li>클라우드 공급자의 로드 밸랜서를 사용하여 서비스를 외부에 노출</li>
<li>Node포트의 성격을 그대로 가지고 있음</li>
<li>각각의 Node에 트래픽 분산</li>
<li>로드밸런스에 접속하기 위한 외부 IP는 개별적으로 설치한경우 생기지 않고, 별도로 외부 IP를 할당하는 플러그인이 설치되어 있어야 함<br>
→ GCP, AWS, Azure, OpenStack은ExternalIP를 지원함</li>
</ul>
<h2>Volume</h2>
<p>Docker는 볼륨 개념이 있지만 다소 느슨하고 덜 관리됩니다. 단순히 디스크 또는 다른 컨테이너의 디렉토리입니다. 수명은 관리되지 않으며 최근까지는 로컬 디스크 백업 볼륨만 있었습니다.<br>
하지만 쿠버네티스는 볼륨을 묶는 포도으와 동일하게 명시적인 수명을 갖습니다. 따라서 포드 내에서 실행되는 모든 컨테이너보다 수명이 길고 컨테이너를 다시 시작해도 데이터가 보존됩니다.<br>
다음은 볼륨 유형들 중 emptyDir, hostPath, PVC/PV에 관해 간략히 살펴보겠습니다.</p>
<h3>emptyDir</h3>
<ul>
<li>Pod가 노드에 할당되고, 그 포드가 해당 노드에서 실행될 때 생성됨</li>
<li>Pod 생성 시 만들어지고 삭제 시 없어지기 때문에 일시적임을 명심해야 함</li>
<li>Container들 끼리 데이터를 공유하기 위해 볼륨을 사용하는 것으로 최초 생성 될 때 볼륨이 비어있기 떄문에 emptyDir이라고 명명됨</li>
<li>Container1이 마운트된 볼륨에 파일을 올리면 Container2가 같은 볼륨을 쓴다고 했을 때 파일을 따로 업로드하거나 할 필요없이 공유하게 됨</li>
<li>
<p>용도</p>
<ul>
<li>웹 서버 컨테이너가 데이터를 제공하는 동안 컨텐츠 관리자 컨테이너가 패치하는 파일 보유</li>
<li>충돌 복구를 위한 긴 계산을 체크 포인트</li>
<li>디스크 기반 병합 정렬과 같은 스크래치 공간</li>
</ul>
</li>
</ul>
<pre><code class="language-yaml"># emptyDir 명세 예시
apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
    - image: k8s.gcr.io/test-webserver
      name: test-container
      volumeMounts:
        - mountPath: /cache
          name: cache-volume
  volumes:
    - name: cache-volume
      emptyDir: {}
</code></pre>
<h3>hostPath</h3>
<ul>
<li>포드에 호스트 노드의 파일 시스템에서 파일이나 디렉토리를 마운트함</li>
<li>Pod들이 올라가져 있는 Node의 Path를 Volume으로 사용 하기 때문에 Pod가 재생성 되어도 Volume이 유지됨</li>
<li>하지만 신규 생성된 Pod가 기존 Volume이 있던 Node에 생성된다는 보장이 없음</li>
<li>각각의 노드에는 기본 적으로 자신을 위해 사용되는 시스템 파일이나 설정 파일 등 자신의 호스트 데이터를 읽을 때 사용</li>
<li>반드시 host-path에 기존 path가 생성이 되어 있어야 함</li>
</ul>
<pre><code class="language-yaml"># hostPath 명세 예시
apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
    - image: k8s.gcr.io/test-webserver
      name: test-container
      volumeMounts:
        - mountPath: /test-pd
          name: test-volume
  volumes:
    - name: test-volume
      hostPath:
        # directory location on host
        path: /data
        # this field is optional
        type: Directory
</code></pre>
<h3>PV &#x26; PVC</h3>
<h4>PV</h4>
<p>Persistent Volume은 관리자에 의해 제공된 이용 또는 동적 프로비저닝 된 클러스터에 저장하는 부분</p>
<ul>
<li>Local 혹은 Azuer, AWS 등의 저장소를 정의하고 연결을 함</li>
</ul>
<h4>PVC</h4>
<p>Persistent Volume Clain은 사용자에 의해 어떤 저장소를 사용할지에 대한 요청 명세</p>
<ul>
<li>포드와 비슷한 성격으로, 모드는 노드 리소스를 소비하고 PVC는 PV 리소스를 소비함</li>
<li>포드는 특정 수준의 리소스를 요청할 수 있고, PVC는 특정 크기 및 액세스 모드를 요청할 수 있음</li>
<li><code>storageClassName: ""</code> 반드시 쌍따옴표로 설정해줘야 하고, 이 부분은 추후 다시 살펴보겠습니다.</li>
</ul>
<p>쿠버네티스가 PVC 내용에 맞는 적절한 PV를 연결 해주는데 이때 PV의 spec - capacity &#x26; accessModes 로 판단 함</p>
<hr>
<ul>
<li><a href="https://kubernetes.io/docs/concepts/services-networking/service/">kubernetes.io</a></li>
</ul>]]></description><link>https://baek.dev/post/6/</link><guid isPermaLink="false">https://baek.dev/post/6/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sat, 05 Oct 2019 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;쿠버네티스 기초 시리즈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/post/5&quot;&gt;쿠버네티스란 무엇인지 살펴보기 - 기초(1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/6&quot;&gt;쿠버네티스 Object 살펴보기1 Pod/Service/Volume - 기초(2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/8&quot;&gt;쿠버네티스 Object 살펴보기2 ConfigMap, Secret, Namespace, ResourceQuota, LimitRange - 기초(3)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/9&quot;&gt;쿠버네티스 Controller 살펴보기1 Deployment - 기초(4)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;What is Kubernetes Object?&lt;/h2&gt;
&lt;p&gt;이전 포스팅에서는 쿠버네티스가 무엇인지 간략하게 살펴보았습니다. 쿠버네티스는 시스템의 상태를 나타내는 &lt;code&gt;오브젝트(Object)&lt;/code&gt;라는 영구 엔티티라는 개념이 있습니다. 오브젝트는 의도를 담은 레코드로, 객체가 존재하도록 지속적으로 작동하게 됩니다. 오브젝트를 사용, 생성, 수정 또는 삭제하기 위해서 Kubernetes API를 사용하게 됩니다.&lt;/p&gt;
&lt;p&gt;오브젝트는 크게 다음과 같은 의미를 갖습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;컨테이너화 된 애플리케이션이 실행중인 노드&lt;/li&gt;
&lt;li&gt;해당 응용 프로그램에서 사용 가능한 리소스&lt;/li&gt;
&lt;li&gt;재시작 정책, 업그레이드 및 내결함성과 같은 해당 응용 프로그램의 동작 방식에 대한 정책&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;가장 보편적으로 사용되는 오브젝트를 기술 방법은 &lt;code&gt;.yaml&lt;/code&gt;을 이용하게 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: apps/v1 # apps/v1beta2를 사용하는 1.9.0보다 더 이전의 버전용
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2 # 템플릿에 매칭되는 파드 2개를 구동하는 디플로이먼트임
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx:1.7.9
          ports:
            - containerPort: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Namespace&lt;/h3&gt;
&lt;p&gt;쿠버네티스는 동일 물리 클러스터를 기반으로 하는 복수의 가상 클러스터를 지원하는데, 이 가상 클러스터를 네이스페이스라고 칭합니다. 여러개의 팀이나 프로젝트에 걸쳐 많은 사용자가 있는 환경에서 사용하도록 만들어졌습니다.&lt;/p&gt;
&lt;h3&gt;Label&lt;/h3&gt;
&lt;p&gt;레이블은 목적에 따라 오브젝트들을 분류하고 분류된 오브젝트들만 따로 연결하기 위해 사용합니다. Pod와 같은 오브젝트에 첨부된 key&amp;#x26;value로 이뤄집니다.&lt;br&gt;
레이블은 오브젝트의 특성을 식별하는데 사용되어 사용자에게 중요하지만, 코어 시스템에게는 직접적인 의미가 없습니다. 이 레이블을 이용하면 오브젝트 하위 집합을 선택하는데 있어 용이합니다. 즉, 사용자가 느슨하게 결합한 방식으로 조직 구조와 시스템 오브젝트를 매핑할 수 있습니다.&lt;br&gt;
더불어 레이블을 이용하면 dev zone과 production zone을 나눠서 셋팅할 수 있습니다.&lt;/p&gt;
&lt;h2&gt;Pod&lt;/h2&gt;
&lt;p&gt;Pod는 쿠버네티스의 최소 배포 단위로 클러스터에서의 Running Process를 나타냅니다.&lt;br&gt;
Namespace는 이 Pod들을 연결해주고 각각 ip를 할당해주는 역할을 하고, 서로 다른 네임스페이스의 Pod들은 연결 할 수 없습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pod안에는 여러 컨테이너가 들어갈 수 있으므로 여러 앱을 띄울 수 있습니다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약 Pod에 에러가 있어서 재생성되면 Pod내의 데이터가 날아갈 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그래서 Volume을 따로 잡아서 데이터를 별도로 저장합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;쿠버네티스 클러스터 내부의 파드는 주로 두 가지 방법으로 사용되는데,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;단일 컨테이너만 동작하는 파드&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가장 많이 사용되는 사례로, 한 개의 파드가 단일 컨테이너를 감사고 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;함께 동작하는 작업이 필요한 다중 컨테이너가 동작하는 파드&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;리소스 공유가 필요한 다중으로 함께 배치된 컨테이너로 구성됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# Pod 명세 예시
apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
    - name: myapp-container
      image: busybox
      command: [&quot;sh&quot;, &quot;-c&quot;, &quot;echo 안녕하세요 쿠버네티스! &amp;#x26;&amp;#x26; sleep 3600&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Container&lt;/h3&gt;
&lt;p&gt;하나의 Pod안에 여러 컨테이너를 가질 수 있습니다. 각 Container는 Port를 갖지만 서로 같은 Port를 가질 수는 없습니다.&lt;/p&gt;
&lt;h2&gt;Service&lt;/h2&gt;
&lt;p&gt;내부에서만 접근할 수 있는 Pod들을 응용 프로그램으로 표시하는 네트워크 서비스를 뜻합니다.&lt;br&gt;
Pod는 각각의 고유한 ip주소를 갖지만 Auto-Healing 혹은 재배포 등으로 인해 &lt;code&gt;재생성된 Pod는 때마다 새로운 ip를 부여&lt;/code&gt; 받게 됩니다. 새롭게 생성된 Pod 세트에 대한 단일 DNS이름을 제공하고 이들 간에 로드 밸런스를 수행합니다.&lt;/p&gt;
&lt;h3&gt;ClusterIP&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;쿠버네티스 클러스터 내에서만 접근이 가능한 IP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;→ 운영자와 같은 인가된 사람만 접근&lt;/li&gt;
&lt;li&gt;→ 내부 대쉬보드&lt;/li&gt;
&lt;li&gt;→ 각 Pod 디버깅&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;클러스터 내에서 다른 오브젝트들이 접근 할 수있음&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Q. Pod에도 클러스터 내에서 접근 할 수 있는 IP가 있고 Service에는 자신의 클러스터 IP가 있는데 굳이 Serive를 다는 이유는?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;→ Pod는 휘발성 IP, 언제든지 삭제 되고 재생성 될 수 있고, 그 때마다 ip가 새로 할당 됨&lt;/li&gt;
&lt;li&gt;→ Service는 사용자가 직접 지우지 않는한 삭제되거나 재생성되지 않음. 항상 연결되어 있는 Pod에 접근 가능함&lt;/li&gt;
&lt;li&gt;→ 여러개의 Pod를 연결시켰을 때 Service가 트래픽을 분산시킴&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;NodePort&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;내부망 연결, 클러스터 밖에 있지만 내부 네트워크 접근 전용&lt;/li&gt;
&lt;li&gt;일부 데모 등을 위해 네트워크 중계기에 포트 포워딩을 통해 임시로 열어서 접근 하기도 함&lt;/li&gt;
&lt;li&gt;기본적으로 ClusterIP가 할당되고 같은 기능을 함&lt;/li&gt;
&lt;li&gt;쿠버네티스 클러스터한테 연결되어 있는 모든 노드한테 똑같은 Port를 할당함&lt;/li&gt;
&lt;li&gt;어느 노드이던 간에 접근을 하면 Service로 연결이 되고 Service는 어느 노드로 들어왔다고 하더라도 자신한테 연결된 Pod에 트래픽을 전달&lt;/li&gt;
&lt;li&gt;Pod가 있는 노드만 포트가 생기는 것이 아니라 Pod가 없는 노드여도 포트 할당이 됨&lt;/li&gt;
&lt;li&gt;&lt;code&gt;externalTrafficPolicy: Local&lt;/code&gt; → 특정 노드 포트의 IP로 접근하는 트래픽은 해당 노드에 있는 POD로만 트래픽을 줌&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Load Balancer&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;클라우드 공급자의 로드 밸랜서를 사용하여 서비스를 외부에 노출&lt;/li&gt;
&lt;li&gt;Node포트의 성격을 그대로 가지고 있음&lt;/li&gt;
&lt;li&gt;각각의 Node에 트래픽 분산&lt;/li&gt;
&lt;li&gt;로드밸런스에 접속하기 위한 외부 IP는 개별적으로 설치한경우 생기지 않고, 별도로 외부 IP를 할당하는 플러그인이 설치되어 있어야 함&lt;br&gt;
→ GCP, AWS, Azure, OpenStack은ExternalIP를 지원함&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Volume&lt;/h2&gt;
&lt;p&gt;Docker는 볼륨 개념이 있지만 다소 느슨하고 덜 관리됩니다. 단순히 디스크 또는 다른 컨테이너의 디렉토리입니다. 수명은 관리되지 않으며 최근까지는 로컬 디스크 백업 볼륨만 있었습니다.&lt;br&gt;
하지만 쿠버네티스는 볼륨을 묶는 포도으와 동일하게 명시적인 수명을 갖습니다. 따라서 포드 내에서 실행되는 모든 컨테이너보다 수명이 길고 컨테이너를 다시 시작해도 데이터가 보존됩니다.&lt;br&gt;
다음은 볼륨 유형들 중 emptyDir, hostPath, PVC/PV에 관해 간략히 살펴보겠습니다.&lt;/p&gt;
&lt;h3&gt;emptyDir&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Pod가 노드에 할당되고, 그 포드가 해당 노드에서 실행될 때 생성됨&lt;/li&gt;
&lt;li&gt;Pod 생성 시 만들어지고 삭제 시 없어지기 때문에 일시적임을 명심해야 함&lt;/li&gt;
&lt;li&gt;Container들 끼리 데이터를 공유하기 위해 볼륨을 사용하는 것으로 최초 생성 될 때 볼륨이 비어있기 떄문에 emptyDir이라고 명명됨&lt;/li&gt;
&lt;li&gt;Container1이 마운트된 볼륨에 파일을 올리면 Container2가 같은 볼륨을 쓴다고 했을 때 파일을 따로 업로드하거나 할 필요없이 공유하게 됨&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;용도&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;웹 서버 컨테이너가 데이터를 제공하는 동안 컨텐츠 관리자 컨테이너가 패치하는 파일 보유&lt;/li&gt;
&lt;li&gt;충돌 복구를 위한 긴 계산을 체크 포인트&lt;/li&gt;
&lt;li&gt;디스크 기반 병합 정렬과 같은 스크래치 공간&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# emptyDir 명세 예시
apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
    - image: k8s.gcr.io/test-webserver
      name: test-container
      volumeMounts:
        - mountPath: /cache
          name: cache-volume
  volumes:
    - name: cache-volume
      emptyDir: {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;hostPath&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;포드에 호스트 노드의 파일 시스템에서 파일이나 디렉토리를 마운트함&lt;/li&gt;
&lt;li&gt;Pod들이 올라가져 있는 Node의 Path를 Volume으로 사용 하기 때문에 Pod가 재생성 되어도 Volume이 유지됨&lt;/li&gt;
&lt;li&gt;하지만 신규 생성된 Pod가 기존 Volume이 있던 Node에 생성된다는 보장이 없음&lt;/li&gt;
&lt;li&gt;각각의 노드에는 기본 적으로 자신을 위해 사용되는 시스템 파일이나 설정 파일 등 자신의 호스트 데이터를 읽을 때 사용&lt;/li&gt;
&lt;li&gt;반드시 host-path에 기존 path가 생성이 되어 있어야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# hostPath 명세 예시
apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
    - image: k8s.gcr.io/test-webserver
      name: test-container
      volumeMounts:
        - mountPath: /test-pd
          name: test-volume
  volumes:
    - name: test-volume
      hostPath:
        # directory location on host
        path: /data
        # this field is optional
        type: Directory
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;PV &amp;#x26; PVC&lt;/h3&gt;
&lt;h4&gt;PV&lt;/h4&gt;
&lt;p&gt;Persistent Volume은 관리자에 의해 제공된 이용 또는 동적 프로비저닝 된 클러스터에 저장하는 부분&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Local 혹은 Azuer, AWS 등의 저장소를 정의하고 연결을 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;PVC&lt;/h4&gt;
&lt;p&gt;Persistent Volume Clain은 사용자에 의해 어떤 저장소를 사용할지에 대한 요청 명세&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;포드와 비슷한 성격으로, 모드는 노드 리소스를 소비하고 PVC는 PV 리소스를 소비함&lt;/li&gt;
&lt;li&gt;포드는 특정 수준의 리소스를 요청할 수 있고, PVC는 특정 크기 및 액세스 모드를 요청할 수 있음&lt;/li&gt;
&lt;li&gt;&lt;code&gt;storageClassName: &quot;&quot;&lt;/code&gt; 반드시 쌍따옴표로 설정해줘야 하고, 이 부분은 추후 다시 살펴보겠습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;쿠버네티스가 PVC 내용에 맞는 적절한 PV를 연결 해주는데 이때 PV의 spec - capacity &amp;#x26; accessModes 로 판단 함&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/service/&quot;&gt;kubernetes.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[쿠버네티스란 무엇인지 살펴보기 - 기초(1)]]></title><description><![CDATA[<blockquote>
<p>쿠버네티스 기초 시리즈</p>
<ul>
<li><a href="/post/5">쿠버네티스란 무엇인지 살펴보기 - 기초(1)</a></li>
<li><a href="/post/6">쿠버네티스 Object 살펴보기1 Pod/Service/Volume - 기초(2)</a></li>
<li><a href="/post/8">쿠버네티스 Object 살펴보기2 ConfigMap, Secret, Namespace, ResourceQuota, LimitRange - 기초(3)</a></li>
<li><a href="/post/9">쿠버네티스 Controller 살펴보기1 Deployment - 기초(4)</a></li>
</ul>
</blockquote>
<h2>Kubernetes란?</h2>
<ul>
<li>쿠버네티스는 디플로이 자동화, 스케일링, 컨테이너화된 애플리케이션의 관리를 위한 오픈 소스 시스템</li>
<li>여러 클러스터의 호스트 간에 애플리케이션 컨테이너의 배치, 스케일링, 운영을 자동화하기 위한 플랫폼을 제공하기 위함</li>
<li>도커를 포함하여 일련의 컨테이너 도구들과 함께 동작<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup></li>
<li>쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장가능한 플랫폼<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup></li>
</ul>
<h2>Kubernetes가 도래하기까지의 과정</h2>
<ul>
<li>1991년, Linux를 이용한 서버 운영이 가능했지만 리소스를 관리 및 할당 면에서 어려움이 따름</li>
<li>이후 VM이 출시 되어 기업들은 물론 일반인들도 쉽게 사용할 수 있도록 발전 됨</li>
<li>
<p>VM은 자동화는 되는 것 같았지만 시스템 효율이 나지 않아 2010년 openstack<sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup>이 탄생하게 됨</p>
<ul>
<li>작은 서버를 띄워야 할 때에도 덩치가 큰 OS를 써야하는 단점</li>
</ul>
</li>
<li>
<p>Docker 출범</p>
<ul>
<li>Linux의 어려운 자원 공유 기술을 <code>컨테이너</code>라는 공유 기능을 통해 효율적으로 만듬</li>
<li>컨테이 가상화 기술은 서비스 간의 자원을 격리하는데 있어 OS를 별도로 띄우지 않아도 됨</li>
<li>즉, 하나의 OS위에서 여러개 컨테이너를 띄우는 형태</li>
<li>자동화에 OS 기동 시간이 없기 때문에 배포가 빠름</li>
<li>한 서비스를 가상화 시켜서 배포를 하는 것이지 엄청 많은 서비스를 한 번에 가상화 시켜주는 것은 아님<br>
-> 이런 것을 해주는것이 바로 <strong>오케스트레이션</strong>, 도커 스웜이 있음<br>
-> 여러 컨테이너들을 관리해주는 것</li>
</ul>
</li>
<li>
<p>쿠버네티스 출범</p>
<ul>
<li>쿠버네티스는 여러 업체들이 참여해서 오케스트레이션을 고도화함</li>
</ul>
</li>
</ul>
<blockquote>
<p>IT에서는 가장 많이 사용하는게 표준이 됨</p>
</blockquote>
<h2>그럼 왜 쿠버네티스일까?</h2>
<blockquote>
<p>트래픽 예측이 힘들고 여러 서비스를 운영하는 경우 더 어렵고 힘들다.</p>
</blockquote>
<p>애플리케이션을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인해야합니다. 예를 들어 컨테이너가 다운되면 다른 컨테이너를 다시 시작해야 합니다. 이런 과정을 시스템에 의해 자동으로 처리되도록 하는 것이 바로 쿠버네티스가 필요한 이유입니다. 즉, <code>분산 시스템을 탄력적으로 실행하기 위한 프레임 워크</code>를 제공합니다.</p>
<ul>
<li>Storage Orchestration : 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재할 수 있습니다.</li>
<li>Auto Scaling&#x26;Healing : 트래픽에 따라 인스턴스 증감, 장애가 난 서버 대신 새로운 서버로 옮겨 서비스 지속을 가능하게 합니다.</li>
<li>Deployment를 통해 rollingupdate &#x26; recreate : 무중단 서비스 배포가 가능합니다.</li>
<li>자동화된 빈 패킹 : 각 컨테이너에 필요한 자원의 양을 지정할 수 있고, 컨테이너에 자원이 요청되면 쿠버네티스는 자원 관리를 위해 더 나은 결정을 내릴 수 있습니다.</li>
<li>시크릿과 구성 관리 : 쿠버네티스를 사용하면 암호, OAuth 토큰 및 ssh 키와 같은 중요한 정보를 저장하고 관리할 수 있습니다.</li>
</ul>
<h2>VM과 Container 차이</h2>
<h3>VM</h3>
<ul>
<li>Hypervisor - 호스트 위에서 작동하는 가상화 시켜주는 스택</li>
<li>하이퍼바이저 위에서 각 서비스마다 OS를 띄워야 함</li>
<li>VM은 뚫려도 각 서비스별로 OS 격리가 되어 있어서 상대적으로 안전함</li>
</ul>
<h3>Container</h3>
<ul>
<li>각 서버 환경별 이미지만 있으면 다른 환경의 도커 위에서 컨테이너를 띄우는 것이 가능함</li>
<li>하나의 OS를 공유하는 개념</li>
<li>한 컨테이너가 뚫려서 OS에 접근하면 다른 컨테이너도 접근이 가능함</li>
<li>한 서비스를 만들때 모듈별로 나눠서 각각 만들고, 각각 컨테이너에 나눠 담는게 좋음</li>
</ul>
<h4>Docker</h4>
<ul>
<li>namespace - kernel에 관한 영역 분리</li>
<li>cgroups - 자원에 대한 영역 분리</li>
<li>os에서 제공하는 자원 격리 기술을 이용해서 컨테이너라는 단위로 서비스를 분리할 수 있게 해줌</li>
<li>컨테이너 가상화가 깔려있는 OS에서는 개발환경에 대한 걱정없이 배포가 가능</li>
</ul>
<h4>Kubernetes</h4>
<ul>
<li>Pod에 모듈을 담을 수 있고, Pod이 배포 단위임</li>
<li>Pod 등 쿠버네티스의 오브젝트에 관해서는 다음 포스팅에 구체적으로 설명하겠습니다.</li>
</ul>
<p>다음 포스팅에 들어가기에 앞서 쿠버네티스는 Master와 Node로 구성되고 이들이 연결되어 클러스터라는 개념이 됩니다. 하나의 Master에는 여러 Node가 연결되구요.</p>
<ul>
<li>
<p>Master</p>
<ul>
<li>쿠버네티스의 전반적인 기능들을 컨트롤클러스터에 관한 스케줄링과 같은 전반적인 결정을 수행하고 클러스터 이벤트를 감지하고 반응</li>
</ul>
</li>
<li>
<p>Node</p>
<ul>
<li>자원을 제공하기 때문에 클러스터 전체 자원을 늘리고 싶다면 노드를 계속 추가하면 됨</li>
</ul>
</li>
</ul>
<div class="footnotes">
<hr>
<ol>
<li id="fn-1">
<p><a href="https://ko.wikipedia.org/wiki/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4">ko.wikipedia.org</a></p>
<a href="#fnref-1" class="footnote-backref">↩</a>
</li>
<li id="fn-2">
<p><a href="https://kubernetes.io">kubernetes.io</a></p>
<a href="#fnref-2" class="footnote-backref">↩</a>
</li>
<li id="fn-3">
<p>openstack - IaaS(infrastructure as a Service) 형태의 클라우드 컴퓨딩 오픈 소스 프로젝트</p>
<a href="#fnref-3" class="footnote-backref">↩</a>
</li>
</ol>
</div>]]></description><link>https://baek.dev/post/5/</link><guid isPermaLink="false">https://baek.dev/post/5/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Fri, 04 Oct 2019 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;쿠버네티스 기초 시리즈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/post/5&quot;&gt;쿠버네티스란 무엇인지 살펴보기 - 기초(1)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/6&quot;&gt;쿠버네티스 Object 살펴보기1 Pod/Service/Volume - 기초(2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/8&quot;&gt;쿠버네티스 Object 살펴보기2 ConfigMap, Secret, Namespace, ResourceQuota, LimitRange - 기초(3)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/post/9&quot;&gt;쿠버네티스 Controller 살펴보기1 Deployment - 기초(4)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Kubernetes란?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;쿠버네티스는 디플로이 자동화, 스케일링, 컨테이너화된 애플리케이션의 관리를 위한 오픈 소스 시스템&lt;/li&gt;
&lt;li&gt;여러 클러스터의 호스트 간에 애플리케이션 컨테이너의 배치, 스케일링, 운영을 자동화하기 위한 플랫폼을 제공하기 위함&lt;/li&gt;
&lt;li&gt;도커를 포함하여 일련의 컨테이너 도구들과 함께 동작&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장가능한 플랫폼&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Kubernetes가 도래하기까지의 과정&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;1991년, Linux를 이용한 서버 운영이 가능했지만 리소스를 관리 및 할당 면에서 어려움이 따름&lt;/li&gt;
&lt;li&gt;이후 VM이 출시 되어 기업들은 물론 일반인들도 쉽게 사용할 수 있도록 발전 됨&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VM은 자동화는 되는 것 같았지만 시스템 효율이 나지 않아 2010년 openstack&lt;sup id=&quot;fnref-3&quot;&gt;&lt;a href=&quot;#fn-3&quot; class=&quot;footnote-ref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;이 탄생하게 됨&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;작은 서버를 띄워야 할 때에도 덩치가 큰 OS를 써야하는 단점&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Docker 출범&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux의 어려운 자원 공유 기술을 &lt;code&gt;컨테이너&lt;/code&gt;라는 공유 기능을 통해 효율적으로 만듬&lt;/li&gt;
&lt;li&gt;컨테이 가상화 기술은 서비스 간의 자원을 격리하는데 있어 OS를 별도로 띄우지 않아도 됨&lt;/li&gt;
&lt;li&gt;즉, 하나의 OS위에서 여러개 컨테이너를 띄우는 형태&lt;/li&gt;
&lt;li&gt;자동화에 OS 기동 시간이 없기 때문에 배포가 빠름&lt;/li&gt;
&lt;li&gt;한 서비스를 가상화 시켜서 배포를 하는 것이지 엄청 많은 서비스를 한 번에 가상화 시켜주는 것은 아님&lt;br&gt;
-&gt; 이런 것을 해주는것이 바로 &lt;strong&gt;오케스트레이션&lt;/strong&gt;, 도커 스웜이 있음&lt;br&gt;
-&gt; 여러 컨테이너들을 관리해주는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;쿠버네티스 출범&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;쿠버네티스는 여러 업체들이 참여해서 오케스트레이션을 고도화함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;IT에서는 가장 많이 사용하는게 표준이 됨&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;그럼 왜 쿠버네티스일까?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;트래픽 예측이 힘들고 여러 서비스를 운영하는 경우 더 어렵고 힘들다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;애플리케이션을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인해야합니다. 예를 들어 컨테이너가 다운되면 다른 컨테이너를 다시 시작해야 합니다. 이런 과정을 시스템에 의해 자동으로 처리되도록 하는 것이 바로 쿠버네티스가 필요한 이유입니다. 즉, &lt;code&gt;분산 시스템을 탄력적으로 실행하기 위한 프레임 워크&lt;/code&gt;를 제공합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Storage Orchestration : 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재할 수 있습니다.&lt;/li&gt;
&lt;li&gt;Auto Scaling&amp;#x26;Healing : 트래픽에 따라 인스턴스 증감, 장애가 난 서버 대신 새로운 서버로 옮겨 서비스 지속을 가능하게 합니다.&lt;/li&gt;
&lt;li&gt;Deployment를 통해 rollingupdate &amp;#x26; recreate : 무중단 서비스 배포가 가능합니다.&lt;/li&gt;
&lt;li&gt;자동화된 빈 패킹 : 각 컨테이너에 필요한 자원의 양을 지정할 수 있고, 컨테이너에 자원이 요청되면 쿠버네티스는 자원 관리를 위해 더 나은 결정을 내릴 수 있습니다.&lt;/li&gt;
&lt;li&gt;시크릿과 구성 관리 : 쿠버네티스를 사용하면 암호, OAuth 토큰 및 ssh 키와 같은 중요한 정보를 저장하고 관리할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;VM과 Container 차이&lt;/h2&gt;
&lt;h3&gt;VM&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Hypervisor - 호스트 위에서 작동하는 가상화 시켜주는 스택&lt;/li&gt;
&lt;li&gt;하이퍼바이저 위에서 각 서비스마다 OS를 띄워야 함&lt;/li&gt;
&lt;li&gt;VM은 뚫려도 각 서비스별로 OS 격리가 되어 있어서 상대적으로 안전함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Container&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;각 서버 환경별 이미지만 있으면 다른 환경의 도커 위에서 컨테이너를 띄우는 것이 가능함&lt;/li&gt;
&lt;li&gt;하나의 OS를 공유하는 개념&lt;/li&gt;
&lt;li&gt;한 컨테이너가 뚫려서 OS에 접근하면 다른 컨테이너도 접근이 가능함&lt;/li&gt;
&lt;li&gt;한 서비스를 만들때 모듈별로 나눠서 각각 만들고, 각각 컨테이너에 나눠 담는게 좋음&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Docker&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;namespace - kernel에 관한 영역 분리&lt;/li&gt;
&lt;li&gt;cgroups - 자원에 대한 영역 분리&lt;/li&gt;
&lt;li&gt;os에서 제공하는 자원 격리 기술을 이용해서 컨테이너라는 단위로 서비스를 분리할 수 있게 해줌&lt;/li&gt;
&lt;li&gt;컨테이너 가상화가 깔려있는 OS에서는 개발환경에 대한 걱정없이 배포가 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Kubernetes&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Pod에 모듈을 담을 수 있고, Pod이 배포 단위임&lt;/li&gt;
&lt;li&gt;Pod 등 쿠버네티스의 오브젝트에 관해서는 다음 포스팅에 구체적으로 설명하겠습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다음 포스팅에 들어가기에 앞서 쿠버네티스는 Master와 Node로 구성되고 이들이 연결되어 클러스터라는 개념이 됩니다. 하나의 Master에는 여러 Node가 연결되구요.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Master&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;쿠버네티스의 전반적인 기능들을 컨트롤클러스터에 관한 스케줄링과 같은 전반적인 결정을 수행하고 클러스터 이벤트를 감지하고 반응&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Node&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자원을 제공하기 때문에 클러스터 전체 자원을 늘리고 싶다면 노드를 계속 추가하면 됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4&quot;&gt;ko.wikipedia.org&lt;/a&gt;&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io&quot;&gt;kubernetes.io&lt;/a&gt;&lt;/p&gt;
&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-3&quot;&gt;
&lt;p&gt;openstack - IaaS(infrastructure as a Service) 형태의 클라우드 컴퓨딩 오픈 소스 프로젝트&lt;/p&gt;
&lt;a href=&quot;#fnref-3&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[utterances를 블로그 댓글로 적용하기]]></title><description><![CDATA[<p>여러분은 블로그 댓글을 어떤 앱으로 운영하고 계신가요?<br>
오늘은 utterances라는 아주 가벼우면서 설정이 쉬운 댓글 앱을 소개해 드리려고 합니다.</p>
<h2>utterances 도입 계기</h2>
<p>저는 그동안 블로그에 facebook comments 혹은 disqus를 이용하여 댓글을 운영했습니다. 티스토리 혹은 미디엄 등에서 블로그를 운영하시는 분들이라면 어떤 댓글 앱을 쓸지 따로 크게 고민이 필요치 않은 부분입니다. 하지만 utterances는 깃허브 블로그에만 운영할 수 있는 것은 아닙니다. 다양한 방식으로 github issue와 맵핑만 할 수 있다면 어느 곳에서든 댓글 앱으로 채택할 수 있습니다.</p>
<p>다른 유명하고 더 많은 부가 기능을 제공하는 댓글 앱을 제치고 utterances를 도입하게 된 계기가 무엇일까요?<br>
요약하면 크게 2가지입니다.</p>
<ol>
<li>유저가 댓글 남기기 위해 별도 절차가 필요한가?</li>
<li>관리가 용이한가?</li>
</ol>
<blockquote>
<p>첫번째는<br>
사적인 공간으로서 더 큰 역할을 하는 facebook 계정을 기술 블로그 댓글에 직접적인 로그인 수단으로 사용하고 싶지 않았습니다.</p>
</blockquote>
<p>처음 페이스북 댓글 앱을 사용하게 된 계기는 위 이유와 반대로 SNS를 댓글 로그인에 사용하고 싶었습니다. 그러면 좀 더 댓글 실명제를 운영할 수 있을 것 같았습니다.</p>
<p><strong>하지만 이 SNS 계정으로 인해 다양한 피드백에 대한 허들이 생기는 것 같았습니다.</strong> 물론 익명을 추구하는 것은 아닙니다. 이를테면 공과 사를 구분 할 수 있는 정도의 느낌으로 페이스북 앱 철회를 생각하게 되었습니다.</p>
<p>disqus는 유명한 댓글 앱이지만 위와 반대되는 성격으로 탈락하였습니다.<br>
물론 disqus를 많이 그리고 자주 사용하시는 유저도 계시겠지만, 댓글을 남기기 위해 disqus에 가입해야 하는 절차를 드리게 되는 것 같아 이 역시 또 하나의 피로가 될 것으 생각했습니다.</p>
<blockquote>
<p>두번째는<br>
관리자 입장에서 관리 비용이 적절한가입니다.</p>
</blockquote>
<p>페이스북은 댓글 알림을 받기 힘들어 댓글에 대한 의견 교환 시기를 많이 놓치기도 했습니다. 댓글 관리를 위해서는 페이스북 댓글 앱 사이트에 다시 들어가야 는 추가 관문(?)이 생겨 쉽사리 관리 궤도에 오르지 못했습니다. 또한 disqus 역시 관리를 위해 별도의 사이트로 진입해야만 설정을 할 수 있다는 점에서 블로그 운영자 입장에서도 손에 쉽사리 잡히지 않는 툴로 느껴졌습니다.</p>
<p>위 앱들은 스팸 필터 및 방지, 댓글 대기열, 댓글 리액션 등 다양한 기능을 제공하는 앱들이지만 저는 순수하게 댓글 기능 자체에 집중하고 싶었습니다. 더불어 github app인 utterances는 개발자 블로그와 성향이 매우 유사하 적극 도입을 하게 되었습니다.</p>
<h2>utterances의 장점</h2>
<ul>
<li>
<p>깃허브는 다수 개발자가 가입은 해둔 플랫폼입니다.</p>
<ul>
<li>깃허브 앱인 utterances는 깃허브 계정만 있으면 되기 때문에 블로그 운영자와 사용자는 대부분 별도 가입을 하지 않아도 됩니다.</li>
</ul>
</li>
<li>
<p>특별한 관리 부담이 필요치 않습니다.</p>
<ul>
<li>운영자 입장에서도 자주 사용하는 플랫폼인 깃허브는 친숙한 환경이기에 설치나 관리에 대한 부담이 없습니다.</li>
</ul>
</li>
<li>
<p>댓글 알림을 받을 수 있습니다.</p>
<ul>
<li>github issues를 댓글 쓰레드로 사용하는 utterances는 댓글이 등록되면, 즉 새로운 issue가 등록된 것이므로 메일 알림을 받을 수 있습니다.</li>
<li>이 때문에 소중한 독자와 소통하는 타이밍을 놓치지 않게 됩니다.</li>
</ul>
</li>
<li>
<p>설치 및 설정이 쉽습니다.</p>
<ul>
<li>utterances앱을 깃허브 계정에 추가한 뒤 댓글 저장 용도로 사용될 신규 레포지토리 추가하여 권한을 주면 됩니다.</li>
<li>이후 댓글 영역에 스크립트 코드 한 줄만 추가해주면 셋팅이 끝납니다.</li>
</ul>
</li>
<li>
<p>Markdown 문법을 이용하여 댓글 작성이 가능합니다.</p>
<ul>
<li>github 플랫폼을 이용하기 때문에 당연히 마크다운 문법 사용이 가능합니다.</li>
</ul>
</li>
</ul>
<p>어때요. 참 쉽죠?<br>
<img src="https://baek.dev/assets/images/post/2019/bob_easy.jpg" alt="어때요. 참 쉽죠?"></p>
<h2>utterances 댓글 적용</h2>
<p><strong>github에 신규 repository를 생성합니다.</strong><br>
보통은 <code>blog-comments</code>라는 이름으로 많이 생성합니다. 저는 <code>baekdev-comments</code>로 작명했습니다. <strong>언제 어디서든 네이밍은 고독하고 힘들지만</strong> 네이밍 자체가 이 앱 설정에 중요한 부분은 아닙니다.</p>
<p><img src="https://baek.dev/assets/images/post/2019/2019_004_001.png" alt="baekdev/baekdev-comments"></p>
<p><strong>utterances.json file을 생성합니다.</strong><br>
origins안의 value는 각자 블로그의 도메인으로 지정하면 됩니다. 보통 깃허브에 커스텀 도메인을 적용하지 않았다면 <code>계정.github.io</code>와 같은 블로그 도메인을 작성하면 됩니다. 저는 커스텀 도메인을 적용했으므로 <code>https://baek.dev</code>로 채웠습니다.</p>
<pre><code class="language-javascript">// utterances.json
{
  "origins": ["https://baek.dev"]
}
</code></pre>
<p><strong>utterances app을 github 계정에 추가합니다.</strong><br>
<a href="https://github.com/apps/utterances">github.com/apps/utterances</a>로 이동하여 app을 추가합니다.<br>
앱이 레포지토리에 접근 권한을 가져야 하므로 조금 전 새롭게 만든 레포지토리를 선택해줍니다.</p>
<p><strong>블로그 코드에 script를 추가합니다.</strong></p>
<p><a href="https://utteranc.es/">utteranc.es</a>에 접속하여 스크립트 복사를 하면 됩니다.<br>
복사하기 전에 다음 순서대로 input box에 값을 채우면 스크립트에 자동완성이 됩니다.</p>
<p><strong>위에서 신규로 만든 레포지토리를 입력해줍니다.</strong></p>
<p><img src="https://baek.dev/assets/images/post/2019/2019_004_002.png" alt="baekdev/baekdev-comments"></p>
<p><strong>포스팅과 깃허브 이슈를 어떻게 맵핑할 것인지 선택합니다.</strong><br>
개별 포스팅 주소가 유효하다면 첫번째 포스팅 경로 맵핑을 선택하면 됩니다. 각자 블로그 구조에 맞는 맵핑 방법을 선택하면 됩니다. 저는 첫번째 경로 맵핑을 선택했습니다.</p>
<p><img src="https://baek.dev/assets/images/post/2019/2019_004_003.png" alt="post &#x26; issue mapping"></p>
<p><strong>테마를 선택하고 Copy 버튼을 클릭하여 블로그 댓글 위치에 붙여 넣어 줍니다.</strong></p>
<p><img src="https://baek.dev/assets/images/post/2019/2019_004_004.png" alt="choose theme &#x26; copy script"></p>
<p>이제 운영에서 확인해보겠습니다.<br>
실제 포스팅에 테스트용 댓글을 남겼더니,<br>
<img src="https://baek.dev/assets/images/post/2019/2019_004_005.png" alt="test comment"></p>
<p>baekdev/baekdev-comments 레포지토리에 새로운 이슈가 생성되었고<br>
<img src="https://baek.dev/assets/images/post/2019/2019_004_006.png" alt="created an issue"></p>
<p>이에 따라 전 메일로 알림을 받게 되었습니다.<br>
<img src="https://baek.dev/assets/images/post/2019/2019_004_007.png" alt="received email that the created issue"></p>
<p>길고 먼 여정처럼 설명이 길었지만 보신 바와 같이 utterances 셋팅은 정말 간단합니다. 이제 사용자는 깃헙 로그인을 통해 댓글을 남길 수 있고, 필요하다면 특정 포스팅의 댓글 알림도 같이 받을 수 있습니다. 운영자는 댓글 설정 및 관리에 필요 이상의 투자를 하지 않아도 되죠. <code>조금 더 개발자스러운 댓글 앱, utterances를 적용해보니 정말 마음에 듭니다.</code></p>
<p>지금 이 글을 읽고 계신다면 깃헙 로그인을 통해 <strong>테스트 댓글을 하나 남겨보시면 어떨까요?</strong></p>]]></description><link>https://baek.dev/post/4/</link><guid isPermaLink="false">https://baek.dev/post/4/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Tue, 01 Oct 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;여러분은 블로그 댓글을 어떤 앱으로 운영하고 계신가요?&lt;br&gt;
오늘은 utterances라는 아주 가벼우면서 설정이 쉬운 댓글 앱을 소개해 드리려고 합니다.&lt;/p&gt;
&lt;h2&gt;utterances 도입 계기&lt;/h2&gt;
&lt;p&gt;저는 그동안 블로그에 facebook comments 혹은 disqus를 이용하여 댓글을 운영했습니다. 티스토리 혹은 미디엄 등에서 블로그를 운영하시는 분들이라면 어떤 댓글 앱을 쓸지 따로 크게 고민이 필요치 않은 부분입니다. 하지만 utterances는 깃허브 블로그에만 운영할 수 있는 것은 아닙니다. 다양한 방식으로 github issue와 맵핑만 할 수 있다면 어느 곳에서든 댓글 앱으로 채택할 수 있습니다.&lt;/p&gt;
&lt;p&gt;다른 유명하고 더 많은 부가 기능을 제공하는 댓글 앱을 제치고 utterances를 도입하게 된 계기가 무엇일까요?&lt;br&gt;
요약하면 크게 2가지입니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;유저가 댓글 남기기 위해 별도 절차가 필요한가?&lt;/li&gt;
&lt;li&gt;관리가 용이한가?&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;첫번째는&lt;br&gt;
사적인 공간으로서 더 큰 역할을 하는 facebook 계정을 기술 블로그 댓글에 직접적인 로그인 수단으로 사용하고 싶지 않았습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;처음 페이스북 댓글 앱을 사용하게 된 계기는 위 이유와 반대로 SNS를 댓글 로그인에 사용하고 싶었습니다. 그러면 좀 더 댓글 실명제를 운영할 수 있을 것 같았습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;하지만 이 SNS 계정으로 인해 다양한 피드백에 대한 허들이 생기는 것 같았습니다.&lt;/strong&gt; 물론 익명을 추구하는 것은 아닙니다. 이를테면 공과 사를 구분 할 수 있는 정도의 느낌으로 페이스북 앱 철회를 생각하게 되었습니다.&lt;/p&gt;
&lt;p&gt;disqus는 유명한 댓글 앱이지만 위와 반대되는 성격으로 탈락하였습니다.&lt;br&gt;
물론 disqus를 많이 그리고 자주 사용하시는 유저도 계시겠지만, 댓글을 남기기 위해 disqus에 가입해야 하는 절차를 드리게 되는 것 같아 이 역시 또 하나의 피로가 될 것으 생각했습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;두번째는&lt;br&gt;
관리자 입장에서 관리 비용이 적절한가입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;페이스북은 댓글 알림을 받기 힘들어 댓글에 대한 의견 교환 시기를 많이 놓치기도 했습니다. 댓글 관리를 위해서는 페이스북 댓글 앱 사이트에 다시 들어가야 는 추가 관문(?)이 생겨 쉽사리 관리 궤도에 오르지 못했습니다. 또한 disqus 역시 관리를 위해 별도의 사이트로 진입해야만 설정을 할 수 있다는 점에서 블로그 운영자 입장에서도 손에 쉽사리 잡히지 않는 툴로 느껴졌습니다.&lt;/p&gt;
&lt;p&gt;위 앱들은 스팸 필터 및 방지, 댓글 대기열, 댓글 리액션 등 다양한 기능을 제공하는 앱들이지만 저는 순수하게 댓글 기능 자체에 집중하고 싶었습니다. 더불어 github app인 utterances는 개발자 블로그와 성향이 매우 유사하 적극 도입을 하게 되었습니다.&lt;/p&gt;
&lt;h2&gt;utterances의 장점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;깃허브는 다수 개발자가 가입은 해둔 플랫폼입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;깃허브 앱인 utterances는 깃허브 계정만 있으면 되기 때문에 블로그 운영자와 사용자는 대부분 별도 가입을 하지 않아도 됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;특별한 관리 부담이 필요치 않습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;운영자 입장에서도 자주 사용하는 플랫폼인 깃허브는 친숙한 환경이기에 설치나 관리에 대한 부담이 없습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;댓글 알림을 받을 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github issues를 댓글 쓰레드로 사용하는 utterances는 댓글이 등록되면, 즉 새로운 issue가 등록된 것이므로 메일 알림을 받을 수 있습니다.&lt;/li&gt;
&lt;li&gt;이 때문에 소중한 독자와 소통하는 타이밍을 놓치지 않게 됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;설치 및 설정이 쉽습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;utterances앱을 깃허브 계정에 추가한 뒤 댓글 저장 용도로 사용될 신규 레포지토리 추가하여 권한을 주면 됩니다.&lt;/li&gt;
&lt;li&gt;이후 댓글 영역에 스크립트 코드 한 줄만 추가해주면 셋팅이 끝납니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Markdown 문법을 이용하여 댓글 작성이 가능합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github 플랫폼을 이용하기 때문에 당연히 마크다운 문법 사용이 가능합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;어때요. 참 쉽죠?&lt;br&gt;
&lt;img src=&quot;https://baek.dev/assets/images/post/2019/bob_easy.jpg&quot; alt=&quot;어때요. 참 쉽죠?&quot;&gt;&lt;/p&gt;
&lt;h2&gt;utterances 댓글 적용&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;github에 신규 repository를 생성합니다.&lt;/strong&gt;&lt;br&gt;
보통은 &lt;code&gt;blog-comments&lt;/code&gt;라는 이름으로 많이 생성합니다. 저는 &lt;code&gt;baekdev-comments&lt;/code&gt;로 작명했습니다. &lt;strong&gt;언제 어디서든 네이밍은 고독하고 힘들지만&lt;/strong&gt; 네이밍 자체가 이 앱 설정에 중요한 부분은 아닙니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_004_001.png&quot; alt=&quot;baekdev/baekdev-comments&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;utterances.json file을 생성합니다.&lt;/strong&gt;&lt;br&gt;
origins안의 value는 각자 블로그의 도메인으로 지정하면 됩니다. 보통 깃허브에 커스텀 도메인을 적용하지 않았다면 &lt;code&gt;계정.github.io&lt;/code&gt;와 같은 블로그 도메인을 작성하면 됩니다. 저는 커스텀 도메인을 적용했으므로 &lt;code&gt;https://baek.dev&lt;/code&gt;로 채웠습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// utterances.json
{
  &quot;origins&quot;: [&quot;https://baek.dev&quot;]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;utterances app을 github 계정에 추가합니다.&lt;/strong&gt;&lt;br&gt;
&lt;a href=&quot;https://github.com/apps/utterances&quot;&gt;github.com/apps/utterances&lt;/a&gt;로 이동하여 app을 추가합니다.&lt;br&gt;
앱이 레포지토리에 접근 권한을 가져야 하므로 조금 전 새롭게 만든 레포지토리를 선택해줍니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;블로그 코드에 script를 추가합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://utteranc.es/&quot;&gt;utteranc.es&lt;/a&gt;에 접속하여 스크립트 복사를 하면 됩니다.&lt;br&gt;
복사하기 전에 다음 순서대로 input box에 값을 채우면 스크립트에 자동완성이 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;위에서 신규로 만든 레포지토리를 입력해줍니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_004_002.png&quot; alt=&quot;baekdev/baekdev-comments&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;포스팅과 깃허브 이슈를 어떻게 맵핑할 것인지 선택합니다.&lt;/strong&gt;&lt;br&gt;
개별 포스팅 주소가 유효하다면 첫번째 포스팅 경로 맵핑을 선택하면 됩니다. 각자 블로그 구조에 맞는 맵핑 방법을 선택하면 됩니다. 저는 첫번째 경로 맵핑을 선택했습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_004_003.png&quot; alt=&quot;post &amp;#x26; issue mapping&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;테마를 선택하고 Copy 버튼을 클릭하여 블로그 댓글 위치에 붙여 넣어 줍니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_004_004.png&quot; alt=&quot;choose theme &amp;#x26; copy script&quot;&gt;&lt;/p&gt;
&lt;p&gt;이제 운영에서 확인해보겠습니다.&lt;br&gt;
실제 포스팅에 테스트용 댓글을 남겼더니,&lt;br&gt;
&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_004_005.png&quot; alt=&quot;test comment&quot;&gt;&lt;/p&gt;
&lt;p&gt;baekdev/baekdev-comments 레포지토리에 새로운 이슈가 생성되었고&lt;br&gt;
&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_004_006.png&quot; alt=&quot;created an issue&quot;&gt;&lt;/p&gt;
&lt;p&gt;이에 따라 전 메일로 알림을 받게 되었습니다.&lt;br&gt;
&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_004_007.png&quot; alt=&quot;received email that the created issue&quot;&gt;&lt;/p&gt;
&lt;p&gt;길고 먼 여정처럼 설명이 길었지만 보신 바와 같이 utterances 셋팅은 정말 간단합니다. 이제 사용자는 깃헙 로그인을 통해 댓글을 남길 수 있고, 필요하다면 특정 포스팅의 댓글 알림도 같이 받을 수 있습니다. 운영자는 댓글 설정 및 관리에 필요 이상의 투자를 하지 않아도 되죠. &lt;code&gt;조금 더 개발자스러운 댓글 앱, utterances를 적용해보니 정말 마음에 듭니다.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;지금 이 글을 읽고 계신다면 깃헙 로그인을 통해 &lt;strong&gt;테스트 댓글을 하나 남겨보시면 어떨까요?&lt;/strong&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[쿠버네티스 - 퀵퀵각코 회고록]]></title><description><![CDATA[<p>import ResizeImage from 'components/ResizeImage'</p>
<p><a href="https://www.notion.so/baekdev/4-0a3e47e8583e4019b5215a1ec83d5a1a">퀵퀵각코</a>에 참여하며 진행하는 쿠버네티스 스터디 회고록입니다. 총 4회 모임과 마지막 발표로 마무리하기까지 계속 업데이트됩니다. ✍🏻</p>
<h2>1주차 - 2019.09.29</h2>
<p>킥오프인 만큼 다들 각자 자기소개와 어떤 목표를 삼았는지 공유하는 시간을 가졌습니다.<br>
저는 이번 모각코에 쿠버네티스 온라인 강의 수강 완료를 하고 블로그에 쿠버네티스 내용을 정리하는 것으로 목표로 삼았습니다. 조금은 여유롭게 설정하게 되었는데요, 이유는 평일에는 회사 업무로 진도를 많이 나가기 어렵고 매주 블로깅도 같이 해야 하니 너무 타이트하게 잡으면 목표 달성이 어려워질 것 같았습니다.</p>
<p>예전에는 기술 포스팅을 대부분 단순히 step by step의 커맨드 나열 위주로만 작성했었습니다. 이렇게 작성하는 방식은 당시 <strong>어떻게 트러블 슈팅을 해결했는지</strong> 혹은 <strong>다른 failover 과정은 없었는지</strong> 등 <em>경험적 측면의 이야기가 결여되어 단순히 코드를 모아놓은 메모장 같다는 결론</em>을 내리게 되었습니다. 시간은 훨씬 더 많이 걸리겠지만, 더 좋은 글을 쓰기 위한 트레이닝도 할 겸해서 최대한 최선을 다해 글을 작성해보려고 하기에 목표에 많은 버퍼를 두게 되었습니다.</p>
<ResizeImage src="https://baek.dev/assets/images/post/2019/2019_003_001.png" alt="퀵퀵각코 목표 설정" height="500px" />
  
여유로운 목표 덕분에 1주차 목표한 강의들 수강은 완료했습니다. 물론 초반은 상대적으로 실습도 적고, 개괄적인 내용이다 보니 시간 내에 완료할 수 있었습니다. 목표 리스트에서 체크하며 수강하다 보니 성취감이 매우 높아졌고, 쉬고 싶었던 주말을 반납하고 나온 보람이 있었습니다.
<p>특히 강의 내용은 가상화나 컨테이너에 대한 이해도가 부족해도 자세한 설명을 해주기 때문에 매우 좋았습니다. 더불어 쿠버네티스까지 어떻게 탄생하게 되었는지 Linux부터 VM, Container 순서로 히스토리를 쭈욱 훑을 수 있어서 너무 좋았습니다. 어느 기술 책 초반에 나온 내용 중 <code>해당 기술이 도래하기까지의 과정을 아는 것이 중요하다</code>는 이야기가 쓰여있었습니다. 저도 이 말에 매우 공감합니다. 단순히 트렌드를 쫓기보다는 기술의 탄생 배경을 이해하고 어떻게, 왜 써야 하는지 알 수 있기 때문에 반드시 책이든, 강좌든 포함되어 있으면 그렇게 좋을 수가 없습니다.</p>
<p>오랜만의 모각코이다 보니 정말 좋았고, 아침 일찍 일어나야 하다보니 피곤하기도 했지만 매우 뿌듯했습니다. 모각코 기간이 길게 늘어지는 것보다 짧게 짧게 자주 운영하는 것이 좀 더 효과적일 것 같습니다.</p>
<blockquote>
<p>기간이 길면 컨텍스트 스위칭이 잘되지 않기도 합니다.</p>
<ul>
<li>3개월 기간의 모각코 참여자의 말</li>
</ul>
</blockquote>
<h2>2주차 - 2019.10.05</h2>
<p>2주차 모임이 시작되기 직전에 <a href="%7B%7Bsite.url%7D%7D%7B%7Bsite.baseurl%7D%7D/post/5">블로깅</a> 및 <a href="%7B%7Bsite.url%7D%7D%7B%7Bsite.baseurl%7D%7D/post/3">회고</a>까지 작성이 목표였습니다. 다행이도 목표를 완수 했고 오늘은 쿠버네티스의 Object 개념에 대해 공부할 예정입니다. 역시 지난주는 개요라서 그런지 진도 나감에 있어 막힘이 없었지만 오늘은 처음 보는 내용에 분량도 많아서 쉽사리 따라가기 어려웠습니다.<br>
<code>쿠버네티스 구조를 반드시 손으로 그림을 그려보면서</code> 직접 설명할 수 있는지를 확인해봐야 할 것 같습니다. 이 그림을 포스트에도 첨부할 수 있으면 더 좋을 것 같네요. 더불어 쿠버네티스 공식 문서를 함께 공부하면서 정리를 하다 보니 좀 더 알찬 포스팅을 할 수 있을 것 같습니다.</p>
<p>오늘은 예정된 시간보다 30분 정도 일찍 자리에서 일어나야해서 오늘 목표의 80% 정도 달성했습니다. 주중에 나머지 부분 목표 완료하고 두번째 포스팅도 해야겠습니다!</p>
<h2>3주차 - 2019.10.12</h2>
<p>오늘은 별도로 일이 있어 공부에 집중하기 어려웠습니다.<br>
그래도 쿠버네티스 오브젝트 ConfigMap과 Secret은 공부한 뒤 정리하는 것으로 목표를 짧게 세웠고 다행히도 이것은 지켰습니다. 주말 간에 3주차 목표 완수하고 블로깅도 끝내야겠습니다.</p>
<p>주중에는 서점에 들러 쿠버네티스 책들을 몇 권 살펴봤습니다. 대체로 크게 두 부류로 나뉘는 것 같습니다.</p>
<ul>
<li>개념을 설명한 책</li>
<li>레시피를 설명한 책</li>
</ul>
<p>이 두 가지가 모두 있고 두껍지 않아서 빠르게 볼 수 있는 책을 두 권 골랐습니다. 현재는 강의를 수강하며 공부 중인데 책과 함께 살펴보는 게 좋을 것 같습니다. 이제 곧 회사에서도 쿠버네티스를 사용하려는 단계라 좀 더 빠르게 진도를 빼야겠습니다.</p>
<ResizeImage src="https://baek.dev/assets/images/post/2019/2019_003_002.jpg" alt="3주차 인증샷" height="400px"/>
<p>그리고 요즘 환절기에 일교차가 크다 보니 다들 컨디션이 좋지 않아서 빠지신 분들이 꽤 있었습니다. 거기에 개인 일정이 있으신 분들도 오늘 함께하지 못했습니다. 건강과 개인 일정이 물론 제일 중요하죠. 하지만 남겨진 자들은 사실 이렇게 많이 빠지면 소수가 될수록 의지가 많이 흔들리기 마련입니다. 왜냐하면, 제가 흔들렸기 때문..ㅠㅠ 그래도 소현님이 의지를 다잡아주셔서 오늘 잘 출석할 수 있었습니다.</p>
<h2>4주차 - 2019.10.19</h2>
<p><code>유령 정체</code>라는 용어가 있다. 명절 혹은 휴가철과 같이 민족 대 이동이 발생하는 때에 고속도로에서 교통사고 등 큰 이벤트가 없음에도 도로에 정체가 발생하는 현상을 일컫는다. 정체가 시작된 지점의 첫 번째 차 앞으로 끼어들기가 발생하면 그 차는 브레이크로 멈췄다가 출발하게 된다. 그럼 뒤 차도 앞 차와의 추돌을 피하기 위해 속도를 줄이면서 멈추었다 출발하게 된다. 그럼 세 번째에 있던 차도 두 번째 차로 인해 멈추었다 출발하게 되고, 이런 식으로 그 멈춤이 뒤로 전달되면서 그 시간은 점점 커진다. 그래서 뒤쪽에 있는 차들은 몇 배가 된 정체 시간을 갖게 된다.</p>
<p>4주 차는 컨디션이 좋지 않아 불참했다. 요즘 체력이 많이 부족하다는 것을 느낀다. 운동으로 체력을 다져야 좋아하는 코딩도 모임도 세미나도 꾸준히 다닐 수 있을 것 같다. 주말에 하지 못했던 공부는 평일에 조금씩 따라잡아 포스팅까지 마무리할 수 있었다.</p>
<p>이때부터 밀리기 시작한 공부는 좀처럼 따라잡기 힘들어졌다. 내 컨디션 난조와 야근은 고속도로의 끼어들기와 비슷하다. 이 끼어들기로 목표가 밀리기 시작한다. 한 번 밀리기 시작하면 지난 목표와 이번 주에 목표가 합쳐져서 내가 해야 될 공부가 배가 되기 때문에 부담이 된다. 그러면 다시 궤도에 오르기 위한 출발은 마음에 부담이 된다. 나는 이것을 <code>목표의 유령 정체</code>라고 칭하고 싶다.</p>
<blockquote>
<p>목표가 밀렸다면 빠른 시일 안에 그 밀림을 해결해야 한다.</p>
</blockquote>
<h2>5주차 - 2019.10.26</h2>
<p>마지막 5주차는 발표로 마무리하는 시간을 가졌다. 아쉽게도 야근이 매일같이 있던 주라 지난주에 발생한 <strong>목표의 유령 정체</strong>를 해결하지 못하였다. 그래도 <code>83.3%</code>라는 목표 성과는 달성할 수 있었다. 간단히 쿠버네티스에서 대해 설명하고 운영자로서의 회고로 발표를 하고 퀵퀵각코를 마무리했다.</p>
<ResizeImage src="https://baek.dev/assets/images/post/2019/2019_003_004.png" alt="퀵퀵각코 목표 성과" height="500px" />
<p>아직 남은 목표가 조금 있고, 중급으로 더 깊게 공부하기 위해서 쿠버네티스 스터디는 계속 진행할 것이다.</p>
<p>퀵퀵각코 전체에 대한 회고는 <a href="%7B%7Bsite.url%7D%7D%7B%7Bsite.baseurl%7D%7D/post/10">이 곳에서</a> 볼 수 있다.</p>]]></description><link>https://baek.dev/post/3/</link><guid isPermaLink="false">https://baek.dev/post/3/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sun, 29 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;import ResizeImage from &apos;components/ResizeImage&apos;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.notion.so/baekdev/4-0a3e47e8583e4019b5215a1ec83d5a1a&quot;&gt;퀵퀵각코&lt;/a&gt;에 참여하며 진행하는 쿠버네티스 스터디 회고록입니다. 총 4회 모임과 마지막 발표로 마무리하기까지 계속 업데이트됩니다. ✍🏻&lt;/p&gt;
&lt;h2&gt;1주차 - 2019.09.29&lt;/h2&gt;
&lt;p&gt;킥오프인 만큼 다들 각자 자기소개와 어떤 목표를 삼았는지 공유하는 시간을 가졌습니다.&lt;br&gt;
저는 이번 모각코에 쿠버네티스 온라인 강의 수강 완료를 하고 블로그에 쿠버네티스 내용을 정리하는 것으로 목표로 삼았습니다. 조금은 여유롭게 설정하게 되었는데요, 이유는 평일에는 회사 업무로 진도를 많이 나가기 어렵고 매주 블로깅도 같이 해야 하니 너무 타이트하게 잡으면 목표 달성이 어려워질 것 같았습니다.&lt;/p&gt;
&lt;p&gt;예전에는 기술 포스팅을 대부분 단순히 step by step의 커맨드 나열 위주로만 작성했었습니다. 이렇게 작성하는 방식은 당시 &lt;strong&gt;어떻게 트러블 슈팅을 해결했는지&lt;/strong&gt; 혹은 &lt;strong&gt;다른 failover 과정은 없었는지&lt;/strong&gt; 등 &lt;em&gt;경험적 측면의 이야기가 결여되어 단순히 코드를 모아놓은 메모장 같다는 결론&lt;/em&gt;을 내리게 되었습니다. 시간은 훨씬 더 많이 걸리겠지만, 더 좋은 글을 쓰기 위한 트레이닝도 할 겸해서 최대한 최선을 다해 글을 작성해보려고 하기에 목표에 많은 버퍼를 두게 되었습니다.&lt;/p&gt;
&lt;ResizeImage src=&quot;https://baek.dev/assets/images/post/2019/2019_003_001.png&quot; alt=&quot;퀵퀵각코 목표 설정&quot; height=&quot;500px&quot; /&gt;
  
여유로운 목표 덕분에 1주차 목표한 강의들 수강은 완료했습니다. 물론 초반은 상대적으로 실습도 적고, 개괄적인 내용이다 보니 시간 내에 완료할 수 있었습니다. 목표 리스트에서 체크하며 수강하다 보니 성취감이 매우 높아졌고, 쉬고 싶었던 주말을 반납하고 나온 보람이 있었습니다.
&lt;p&gt;특히 강의 내용은 가상화나 컨테이너에 대한 이해도가 부족해도 자세한 설명을 해주기 때문에 매우 좋았습니다. 더불어 쿠버네티스까지 어떻게 탄생하게 되었는지 Linux부터 VM, Container 순서로 히스토리를 쭈욱 훑을 수 있어서 너무 좋았습니다. 어느 기술 책 초반에 나온 내용 중 &lt;code&gt;해당 기술이 도래하기까지의 과정을 아는 것이 중요하다&lt;/code&gt;는 이야기가 쓰여있었습니다. 저도 이 말에 매우 공감합니다. 단순히 트렌드를 쫓기보다는 기술의 탄생 배경을 이해하고 어떻게, 왜 써야 하는지 알 수 있기 때문에 반드시 책이든, 강좌든 포함되어 있으면 그렇게 좋을 수가 없습니다.&lt;/p&gt;
&lt;p&gt;오랜만의 모각코이다 보니 정말 좋았고, 아침 일찍 일어나야 하다보니 피곤하기도 했지만 매우 뿌듯했습니다. 모각코 기간이 길게 늘어지는 것보다 짧게 짧게 자주 운영하는 것이 좀 더 효과적일 것 같습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;기간이 길면 컨텍스트 스위칭이 잘되지 않기도 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3개월 기간의 모각코 참여자의 말&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2주차 - 2019.10.05&lt;/h2&gt;
&lt;p&gt;2주차 모임이 시작되기 직전에 &lt;a href=&quot;%7B%7Bsite.url%7D%7D%7B%7Bsite.baseurl%7D%7D/post/5&quot;&gt;블로깅&lt;/a&gt; 및 &lt;a href=&quot;%7B%7Bsite.url%7D%7D%7B%7Bsite.baseurl%7D%7D/post/3&quot;&gt;회고&lt;/a&gt;까지 작성이 목표였습니다. 다행이도 목표를 완수 했고 오늘은 쿠버네티스의 Object 개념에 대해 공부할 예정입니다. 역시 지난주는 개요라서 그런지 진도 나감에 있어 막힘이 없었지만 오늘은 처음 보는 내용에 분량도 많아서 쉽사리 따라가기 어려웠습니다.&lt;br&gt;
&lt;code&gt;쿠버네티스 구조를 반드시 손으로 그림을 그려보면서&lt;/code&gt; 직접 설명할 수 있는지를 확인해봐야 할 것 같습니다. 이 그림을 포스트에도 첨부할 수 있으면 더 좋을 것 같네요. 더불어 쿠버네티스 공식 문서를 함께 공부하면서 정리를 하다 보니 좀 더 알찬 포스팅을 할 수 있을 것 같습니다.&lt;/p&gt;
&lt;p&gt;오늘은 예정된 시간보다 30분 정도 일찍 자리에서 일어나야해서 오늘 목표의 80% 정도 달성했습니다. 주중에 나머지 부분 목표 완료하고 두번째 포스팅도 해야겠습니다!&lt;/p&gt;
&lt;h2&gt;3주차 - 2019.10.12&lt;/h2&gt;
&lt;p&gt;오늘은 별도로 일이 있어 공부에 집중하기 어려웠습니다.&lt;br&gt;
그래도 쿠버네티스 오브젝트 ConfigMap과 Secret은 공부한 뒤 정리하는 것으로 목표를 짧게 세웠고 다행히도 이것은 지켰습니다. 주말 간에 3주차 목표 완수하고 블로깅도 끝내야겠습니다.&lt;/p&gt;
&lt;p&gt;주중에는 서점에 들러 쿠버네티스 책들을 몇 권 살펴봤습니다. 대체로 크게 두 부류로 나뉘는 것 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개념을 설명한 책&lt;/li&gt;
&lt;li&gt;레시피를 설명한 책&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 두 가지가 모두 있고 두껍지 않아서 빠르게 볼 수 있는 책을 두 권 골랐습니다. 현재는 강의를 수강하며 공부 중인데 책과 함께 살펴보는 게 좋을 것 같습니다. 이제 곧 회사에서도 쿠버네티스를 사용하려는 단계라 좀 더 빠르게 진도를 빼야겠습니다.&lt;/p&gt;
&lt;ResizeImage src=&quot;https://baek.dev/assets/images/post/2019/2019_003_002.jpg&quot; alt=&quot;3주차 인증샷&quot; height=&quot;400px&quot;/&gt;
&lt;p&gt;그리고 요즘 환절기에 일교차가 크다 보니 다들 컨디션이 좋지 않아서 빠지신 분들이 꽤 있었습니다. 거기에 개인 일정이 있으신 분들도 오늘 함께하지 못했습니다. 건강과 개인 일정이 물론 제일 중요하죠. 하지만 남겨진 자들은 사실 이렇게 많이 빠지면 소수가 될수록 의지가 많이 흔들리기 마련입니다. 왜냐하면, 제가 흔들렸기 때문..ㅠㅠ 그래도 소현님이 의지를 다잡아주셔서 오늘 잘 출석할 수 있었습니다.&lt;/p&gt;
&lt;h2&gt;4주차 - 2019.10.19&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;유령 정체&lt;/code&gt;라는 용어가 있다. 명절 혹은 휴가철과 같이 민족 대 이동이 발생하는 때에 고속도로에서 교통사고 등 큰 이벤트가 없음에도 도로에 정체가 발생하는 현상을 일컫는다. 정체가 시작된 지점의 첫 번째 차 앞으로 끼어들기가 발생하면 그 차는 브레이크로 멈췄다가 출발하게 된다. 그럼 뒤 차도 앞 차와의 추돌을 피하기 위해 속도를 줄이면서 멈추었다 출발하게 된다. 그럼 세 번째에 있던 차도 두 번째 차로 인해 멈추었다 출발하게 되고, 이런 식으로 그 멈춤이 뒤로 전달되면서 그 시간은 점점 커진다. 그래서 뒤쪽에 있는 차들은 몇 배가 된 정체 시간을 갖게 된다.&lt;/p&gt;
&lt;p&gt;4주 차는 컨디션이 좋지 않아 불참했다. 요즘 체력이 많이 부족하다는 것을 느낀다. 운동으로 체력을 다져야 좋아하는 코딩도 모임도 세미나도 꾸준히 다닐 수 있을 것 같다. 주말에 하지 못했던 공부는 평일에 조금씩 따라잡아 포스팅까지 마무리할 수 있었다.&lt;/p&gt;
&lt;p&gt;이때부터 밀리기 시작한 공부는 좀처럼 따라잡기 힘들어졌다. 내 컨디션 난조와 야근은 고속도로의 끼어들기와 비슷하다. 이 끼어들기로 목표가 밀리기 시작한다. 한 번 밀리기 시작하면 지난 목표와 이번 주에 목표가 합쳐져서 내가 해야 될 공부가 배가 되기 때문에 부담이 된다. 그러면 다시 궤도에 오르기 위한 출발은 마음에 부담이 된다. 나는 이것을 &lt;code&gt;목표의 유령 정체&lt;/code&gt;라고 칭하고 싶다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;목표가 밀렸다면 빠른 시일 안에 그 밀림을 해결해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;5주차 - 2019.10.26&lt;/h2&gt;
&lt;p&gt;마지막 5주차는 발표로 마무리하는 시간을 가졌다. 아쉽게도 야근이 매일같이 있던 주라 지난주에 발생한 &lt;strong&gt;목표의 유령 정체&lt;/strong&gt;를 해결하지 못하였다. 그래도 &lt;code&gt;83.3%&lt;/code&gt;라는 목표 성과는 달성할 수 있었다. 간단히 쿠버네티스에서 대해 설명하고 운영자로서의 회고로 발표를 하고 퀵퀵각코를 마무리했다.&lt;/p&gt;
&lt;ResizeImage src=&quot;https://baek.dev/assets/images/post/2019/2019_003_004.png&quot; alt=&quot;퀵퀵각코 목표 성과&quot; height=&quot;500px&quot; /&gt;
&lt;p&gt;아직 남은 목표가 조금 있고, 중급으로 더 깊게 공부하기 위해서 쿠버네티스 스터디는 계속 진행할 것이다.&lt;/p&gt;
&lt;p&gt;퀵퀵각코 전체에 대한 회고는 &lt;a href=&quot;%7B%7Bsite.url%7D%7D%7B%7Bsite.baseurl%7D%7D/post/10&quot;&gt;이 곳에서&lt;/a&gt; 볼 수 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[개발자 이력서 작성 방법 - 99콘 이력서 후기]]></title><description><![CDATA[<p>import ResizeImage from 'components/ResizeImage'</p>
<p>이력서는 가능하면 자주 업데이트해서 최대한 최신의 상태를 유지하라는 조언을 많이 들어 봤을 것입니다. 하지만 목전에 이직이 놓여 있지 않은 이상, 발등에 불이 떨어지지 않는 이상 업데이트하기 어렵습니다. 더욱이 이력서 파일을 열어놓고 드는 생각은 매번 같습니다.</p>
<blockquote>
<p>어떻게 하면 이력서를 서류 탈락 되지 않고 면접까지 이어질 수 있을까?</p>
</blockquote>
<p>어떻게 써야 간결하고 일목요연하고 나의 부족함을 드러내지 않고 서류통과 될 수 있도록 구성할 수 있을까요? 이 부끄러운 이력서를 누군가에게 첨삭 받기도 민망하니 <a href="https://blog.weirdx.io/">이상한 모임</a>에서 주최한 <a href="https://www.notion.so/3-99-e9730dcfd84f4639a796ed202304b6c2">제3회 99콘 &#x3C;이력서></a> 에 다녀와서 개선해보기로 했습니다. 99콘은 제 1회 수습생활편으로 처음 접하게 되었는데, 세션 만족도가 너무 좋아서 이번 이력서 편도 참여하게 되었습니다.</p>
<p>세션을 듣고 나니 저 역시 비추된 이력서 요소가 몇 개 있었습니다. 그동안 까득했던 이력서 업데이트가 방향은 잡을 수 있게 되었고, 이 기회를 빌어 바로 시도해봐야겠습니다. 그럼 발표 내용을 요약하니 아직 이력서 업데이트를 하지 않은 분들은 아래 내용을 참고 해서 우리 같이 이참에 업데이트해봐요 :)</p>
<p><strong>제3회 99콘 &#x3C;이력서> 초대의 말</strong></p>
<blockquote>
<p>정신 차려요. 벌써 9월이라고요.<br>
3개월만 더 지나면 SF소설에서나 나오던 2020년이 된단 말이에요!<br>
경력자 세 명만 모여도 이력서 써야지 라는 말이 최소 2번은 나올 겁니다. 그만큼 경력관리에 필수적인 투두리스트라는 얘기인데요. 매달 업데이트하는 게 좋다는 것을 알면서도, 우리는 마치 연초에 기계적으로 반복하던 금연이나 다이어트 다짐처럼, 해야지 해야지 하는 말만 되뇌고 있던 것은 아닐까요.</p>
</blockquote>
<p><a href="https://baek.dev/post/2/">99콘 제2회 이력서편 후기 - 개발자 이력서 작성 방법</a><br>
<a href="https://baek.dev/post/11/">99콘 제4회 연봉협상편 후기 - 이직자, 재직자 모두에게 필요한 연봉협상 스킬</a></p>
<h2>메인세션1. 7개의 타이틀, 7개의 기회</h2>
<blockquote>
<p>최지호님</p>
<ul>
<li><a href="http://forspacelab.com">forspacelab.com</a></li>
<li>LG전자 → Naver → forspacelab</li>
<li>다수의 면접관 경험</li>
</ul>
</blockquote>
<h3>이 친구 꼭 뽑아야겠다고 생각한 경우</h3>
<ul>
<li>
<p>경험의 폭이 좁아도 생각의 폭이 넓은 지원자</p>
<ul>
<li>작은 공유하기 기능의 버튼을 만들어본 경험 밖에 없는 지원자였지만</li>
<li>현재 자신이 속한 시스템의 문제점과 나아갈 방향까지 고민해본 지원자가</li>
</ul>
</li>
<li>
<p>무언가 탐구하고 깊이 파고드는 성향이 보이는 지원자</p>
<ul>
<li>IT는 도메인 지식이 계속 바뀌는 특성이 있고</li>
<li>이직하거나 분야를 바꿀 일이 굉장히 많음</li>
<li>계속 공부해야 함</li>
</ul>
</li>
<li>
<p>사고가 유연하고 상대를 잘 배려할 수 있어야 함</p>
<ul>
<li>폭포수가 아니고 애자일이기 때문에</li>
<li>주변 사람들이 무얼하고 하는지 잘 챙겨줘야함</li>
</ul>
</li>
<li>똑똑한 지원자</li>
<li>호기심이 많은 지원자</li>
</ul>
<h3>불합격 시킨 경우</h3>
<ul>
<li>본인이 한 일을 잘 설명하지 못하는 지원자</li>
<li>본인의 기여도를 부풀리는 지원자</li>
<li>
<p>제품의 성격/단계 맞지 않는 성향의 지원자</p>
<ul>
<li>기술 지향의 제품인데 컨텐츠 위주 경력인 경우</li>
<li>웹브라우저는 기술 지향인데 컨텐츠 위주 경력인 경우 지원자는 마음에 들지만 합격 시킬 수 없었음</li>
<li>초기 기획 단계인데 운영 위주의 경력인 경우</li>
</ul>
</li>
</ul>
<h3>좋은 평가를 주는 경우</h3>
<ul>
<li>얼마나 많이, 빠르게 배우려고 노력하는지 → 학습</li>
<li>
<p>끝까지 생각해보고 얘기하는지 → 고민의 깊이</p>
<ul>
<li>오답이라도 끝까지 생각하는 지원자는 피드백을 어떻게든 줄 수 있음</li>
<li>중간에 생각을 포기하는 사람은 질문자에게 일을 다시 되돌려 주는 것임</li>
</ul>
</li>
<li>빈 곳을 주도적으로 채우는지 → 적극성과 배려</li>
<li>두드러지는 강점 하나가 있는지 → 캐릭터의 매력</li>
<li>글쓰기, 문서화의 노력 → 커뮤니케이션</li>
</ul>
<h3>이력서없이 이직하는 방법</h3>
<blockquote>
<p>나를 증명할 무엇인가를 만드세요<br>
나의 가치를 인정해줄 사람을 만나야 합니다</p>
</blockquote>
<ul>
<li>레퍼런스를 쌓을 수 있는 일을 많이 할 것</li>
<li>이런 행사에 자주 참여</li>
<li>
<p>시끄러운 분야에서 일을 할 것</p>
<ul>
<li>ex) 우아한 형제들 → 국감에도 불려가고 ..)a</li>
<li>이런 회사에서 일을 하면 본인을 알릴 기회가 많아짐</li>
</ul>
</li>
<li>
<p>가장 중요!</p>
<ul>
<li>가까운 동료에게 인정받을 수 있게 일 할 것</li>
<li>언젠가 그 사람들이 나의 가치를 증명해 줌</li>
</ul>
</li>
</ul>
<h3>꿀팁 🍯</h3>
<ul>
<li>
<p>링크드인에 영어로 이력을 자세히 남길 것</p>
<ul>
<li>구조화된 이력서를 있어 보이게 만들 수 있음</li>
</ul>
</li>
<li>이력서를 달라는 사람들에게 링크드인 링크를 전달</li>
<li>
<p>링크드인 이력서를 pdf로 익스포트 할 수 있음</p>
<ul>
<li>파일로 이력서를 제출하라는 회사는 링크드인 pdf로 전달</li>
</ul>
</li>
</ul>
<p><a href="https://speakerdeck.com/weirdx/99kon-7gaeyi-taiteul-7beonyi-gihoe-coejiho">발표자료</a></p>
<h2>메인세션2. 주니어 개발자의 이력서 쓰기</h2>
<blockquote>
<p>이동욱님</p>
<ul>
<li>우아한 형제들</li>
<li><a href="https://jojoldu.tistory.com">블로그 - 기억보단 기록을</a></li>
<li><a href="https://jojoldu.github.io/">공개 이력서</a></li>
</ul>
</blockquote>
<h3>본인 프로필</h3>
<ul>
<li>
<p>이름, 이메일, 깃허브 → 필수</p>
<ul>
<li>주니어 개발자는 깃허브 계정 필수</li>
<li>어떻게 채워야 할지 모르겠다면? TIL부터 시작하자</li>
<li>졸업 작품이나 국비하면서 만든것을 업로드</li>
</ul>
</li>
<li>
<p>블로그 → 준필수</p>
<ul>
<li>구글에서 검색이 잘 되지 않는 네이버 블로그는 개발자가 좋아하진 않음</li>
<li>티스토리, 깃허브, 미디엄 등 구글에서 검색되는 플랫폼 이용</li>
</ul>
</li>
<li>사이드 프로젝트 있으면 가산점</li>
<li>
<p>링크드인, 페이스북 등 SNS 계정 → 선택</p>
<ul>
<li>개발자에게 큰 매리트는 없음</li>
<li>깃헙이나 블로그가 대체</li>
</ul>
</li>
</ul>
<blockquote>
<p>서류 이 도박을 하도록 만들지 마세요</p>
</blockquote>
<h3>본인 소개</h3>
<br/>
<h4>Summary</h4>
<ul>
<li>
<p>내가 어떤 개발자인지 나타낼 수 있도록 키워드를 선택해서 요약 소개</p>
<ul>
<li>키워드 : 회사와 팀에 도움이 되는 사람, 자동화를 좋아하는 사람</li>
</ul>
</li>
<li>어떤 경험을 해왔는지</li>
<li>어떤 생각을 갖고 있는지</li>
<li>평소에 어떤 노력을 하고 있는지</li>
<li>
<p>최대한 숫자로 표현</p>
<ul>
<li>대용량 / 대규모 → RPM/TPS/PV/MAU 등 구체적 숫자가 판단하는데 도움이 됨</li>
</ul>
</li>
</ul>
<br/>
<h4>피해야할 단어</h4>
<ul>
<li>열정/노력/도전 정신 등 이거 없는 분 계시나요?</li>
<li>증명할 수 있는 단어를 선택하자 -> 숫자와 기록</li>
<li>세미나 좋아하고, 교육 좋아하면 후기도 없고 블로그도 없으면 어떻게 증명 할까요?</li>
</ul>
<br/>
<h3>기술 스택</h3>
<ul>
<li>1~2번 써본 기술은 언급하진 않아야 함</li>
<li>직군에 맞게 필요한 주력 기술만 서술</li>
<li>
<p>그동안 해온 기술과 다르다면?</p>
<ul>
<li>난 그동안 파이썬만 써왔는데 내가 가고 싶은 회사가 자바 스프링이면?</li>
<li><strong>러닝커브</strong>를 강조하는 이력서로</li>
<li>3개월 밖에 안배웠지만 사용 서비스 오픈해본 경험이 있음을 어필</li>
</ul>
</li>
</ul>
<h3>경력/프로젝트</h3>
<br/>
<h4>프로젝트</h4>
<ul>
<li>질문하면 답변할 수 있는 프로젝트만</li>
<li>맡은 개발 파트 요약</li>
<li>프로젝트에서 특히 강조하고 싶은 것</li>
<li>성과/실적도 있다면 추가</li>
<li>가능하면 증명 가능한 링크</li>
</ul>
<br/>
<h4>경력</h4>
<ul>
<li>근무기간</li>
<li>프로젝트가 있으니 요약 정리</li>
<li>프로젝트 성과 외 언급 할것들</li>
<li>
<p>Q. 경력 프로젝트가 너무 적으면? → 교육/스터디로 양념을 하자</p>
<ul>
<li>백엔드 개발자로써 필요한게 있을때 학원 같은 곳을 많이 활용</li>
<li>증거 필수, 블로그 후기</li>
<li>8주면 짜리 교육이면, 매주 후기를 남김</li>
<li>스터디는 백엔드 개발자 기준</li>
<li>기본 : 테스트 코드 / OOP / 클린 코드 필수</li>
<li>확장 : 쿼리 튜닝, 리눅스</li>
<li>혼자서 MSA 연습중이라는 말은 하지 말자</li>
<li>주니어 개발자들에게 기대하는 건 탄탄한 기본기</li>
</ul>
</li>
<li>
<p>Q. start 많은 오픈소스는 효과가 있다?</p>
<ul>
<li>코드가 없는 저장소는 효과가 없다.</li>
<li>spring-boot-aws-mock</li>
<li>start는 적어도 코드가 있는 이 저장소가 더 관심이 있음</li>
</ul>
</li>
</ul>
<h3>포트폴리오</h3>
<ul>
<li>
<p><a href="http://chanywa.com/308">chanywa.com/308</a></p>
<ul>
<li>개발자로서 어떤 역량을 발휘한 작품인가?</li>
<li>작품의 호응도를 자신의 개발 실력과 혼동하는 것</li>
<li>아름답게 만드는 것보다는 개발적으로 어떻게 해결하는지가 무기</li>
</ul>
</li>
<li>
<p>졸업작품 전시회 하듯이 포트폴리오하면 효과가 없다</p>
<ul>
<li>기능, UI 기획 등등이 강조된 PPT</li>
</ul>
</li>
<li>
<p>서류 검토하시는 분들은 코드가 보고 싶다..!</p>
<ul>
<li>TC를 작성하는지, OOP를 아는지, commit message 를 어떻게 작성하는지</li>
</ul>
</li>
<li>
<p>보안 문제가 없다면 github에 올린다.</p>
<ul>
<li>README에 실행방법, 소개까지 써주자</li>
</ul>
</li>
</ul>
<h3>꿀팁 🍯</h3>
<ul>
<li>
<p>문제 해결 사례를 언급</p>
<ul>
<li>학교, 국비, 스터디 하면서 만났던 문제를 해결한 사례를 정리하자.</li>
</ul>
</li>
<li><a href="http://jojoldu.tistory.com/40">tcpdump로 post 데이터 확인하기</a></li>
<li>어떤 문제의 난이도, 즐기는지 이런걸 알 수 있음</li>
</ul>
<h3>마무리</h3>
<blockquote>
<p>잘 쓰려면 잘 살아야 한다.<br>
강원국의 글쓰기 / p.317</p>
</blockquote>
<p>이력서 잘쓰려면 좋은 개발자로 잘 살아야 한다.<br>
좋은 개발자가 되기 위한 노력이 좋은 이력서가 우선 되선 안된다.</p>
<p><a href="https://speakerdeck.com/weirdx/99con-junieo-gaebaljayi-iryeogseo-sseugi-idongug">발표자료</a></p>
<h2>패널 토크</h2>
<p>이 부분은 사전에 받은 질문에 대해 두 연사가 답변을 하는 세션이었다.</p>
<br/>
<h3>Q. 어느덧 쌓인 연차가 꽤 되어, 주니어때 했던 일들이 기억이 나지 않습니다. 특히 신입 때 햇던 것들은 기술에 대한 변별력이 없는데, 어떻게 기술해야 할까요?</h3>
<ul>
<li>
<p>A. 이동욱님</p>
<ul>
<li>기억 안나는데 써봤자 답변 못하면 감점이 된다</li>
<li>쓰기는 하는데 강조하지는 않을 것 같다</li>
<li>현재 업무하는 것에 대해서 어필하는게 좋은 것 같다</li>
</ul>
</li>
<li>
<p>A. 최지호님</p>
<ul>
<li>본인이 생각하기에 기억이 나지 않거나 변별력이 없다면 버려도 될 것 같다</li>
<li>면접관 입장에서도 별로 의미가 없는 일이다</li>
<li>조각적으로 생각나고 의미가 있는 일이라면 구체적이진 않지만 그게 지금의 나를 어떻게 만들었나 퍼즐이 만들어지면 좋을 것 같다</li>
</ul>
</li>
</ul>
<br/>
<h3>Q. 지원동기를 쓰라는 이력서가 많은데, 회사만을 위한 맞춤 지원동기를 작성하는 팁이 있을까요?</h3>
<ul>
<li>
<p>A. 최지호님</p>
<ul>
<li>사람이 싫어서 퇴사해서 이직하면 안된다</li>
<li>내가 하고 싶은 일이 있어서 거기로 가야된다</li>
<li>내가하고 싶은 일이 무엇인지 명확히 드러나고</li>
<li>어떤 프로덕트를 만들고 싶은지</li>
<li>이런게 없다면 정성이 느껴지지 않음</li>
</ul>
</li>
</ul>
<br/>
<h3>Q. 회사업무만으로는 지원하는 직무에 부족하다고 느낄 때, 사이드프로젝트로 어필해도 괜찮을까요?</h3>
<ul>
<li>
<p>A. 이동욱님</p>
<ul>
<li>너무 좋으나 사이드프로젝트가 코드로만 끝나지 않고, 웹이나 앱으로 도메인까지 붙여서 있으면 더 좋다</li>
<li>남는 시간에 내가 부족한걸 채우기위해 공부했다는 것인데 가산점이다!</li>
</ul>
</li>
</ul>
<br/>
<h3>Q. 백엔드 개발을 하다가 프론트로 전직했는데, 다시 프론트 개발자로 지원할 때, 이전 백엔드 경력을 써야하나요? 앱을 공부한적이 잇는데 직무과 연관없는 것들을 적는게 도움이 될까?</h3>
<ul>
<li>
<p>A. 이동욱님</p>
<ul>
<li>써도 무방하지만, 결국 프론트 개발에 백엔드와 앱개발이 어떻게 도움이 되었는지를 어필한다</li>
</ul>
</li>
</ul>
<br/>
<h3>Q. 다른 직무로 전직하려고 합니다. 목표하는 직무에 대한 업무 경험이 없는데, 어떻게 보완해야 할까요</h3>
<ul>
<li>
<p>A. 최지호님</p>
<ul>
<li>경험이 없으면 배우고 경험해봐야한다</li>
<li>교육을 수강한다</li>
<li>그 분야에 어떻게든 뛰어드는 것 말고는 방법이 없다</li>
<li>그리고 그것을 업무에 녹인다</li>
</ul>
</li>
</ul>
<h3>Q. 저와 맞는 회사인지 어떻게 알 수 있나요?</h3>
<ul>
<li>
<p>A. 이동욱님</p>
<ul>
<li>패를 뒤집어 보기 전까지는 모르지만</li>
<li>나랑 맞는 회사는 어떤 조건들을 가지고 있는지 리스트업 해보자</li>
<li>백퍼센트 맞는 회사는 없다, 중요도를 선별하자</li>
<li>감정적으로 판단하지 말자</li>
<li>사람이 싫으면 팀을 옮기면 된다</li>
</ul>
</li>
<li>
<p>A. 최지호님</p>
<ul>
<li>내 성향이 어디에 있는지 잘 아는게 중요하.</li>
<li>내향적인지 외향적인지</li>
<li>좋은 동료와 좋은 일이 있을 뿐이지, 좋은 회사는 없다</li>
</ul>
</li>
</ul>
<h3>Q. 프로젝트 중간에 퇴사하면 민폐가 되지 않나요?</h3>
<ul>
<li>
<p>A. 최지호님</p>
<ul>
<li>그건 니가 걱정할 일이 아니다</li>
<li>그거 걱정하라고 매니저가 있는 것이다</li>
<li>그냥 팽겨치고 나가는 건 평판에 문제가 생길 수 있으므로</li>
<li>문제가 생길 것 같으면 매니저에게 빨리 이야기하는게 답이다</li>
</ul>
</li>
</ul>
<p><img src="https://baek.dev/assets/images/post/2019/2019_002_bm.png" alt="우아한 형제들 작은집에서"></p>
<h2>라이트닝 토크1. 미래를 준비하는 자세</h2>
<blockquote>
<p>신예진님</p>
<ul>
<li>에멘탈 서비스 기획자</li>
</ul>
</blockquote>
<h3>꿀팁 🍯</h3>
<ul>
<li>
<p>이력서의 핵심과 상세를 나누기</p>
<ul>
<li>꼭 전달하고 싶은 핵심 되는 요소를 상단에 짧고 집중력 있게</li>
<li>채용담당자는 모든 이력서를 집중력 있게 읽지 않는다</li>
<li>정리된 상세 영역은 또 하나의 포트폴리오</li>
</ul>
</li>
<li>
<p>이전 회사 포트폴리오를 넣는다면 보안에 신경 쓰기</p>
<ul>
<li>기업 보안은 생각보다 중요하다</li>
<li>전에 회사를 먼저 비난하는 것은 자제</li>
</ul>
</li>
<li>지원하는 회사에 관련된 맞춤 내용을 넣기</li>
</ul>
<p><a href="https://speakerdeck.com/weirdx/99con-miraereul-junbihaneun-jase-sinyejin">발표자료</a></p>
<h2>라이트닝 토크2. SI 탈출기</h2>
<blockquote>
<p>황건구님</p>
<ul>
<li>마켓컬리</li>
<li><a href="http://blog.hwang.gg">blog.hwang.gg</a></li>
</ul>
</blockquote>
<h3>SI ~7년차</h3>
<ul>
<li>레거시, 사수없음, 저임금, 상사의 회사 사정에 대한 거짓말</li>
</ul>
<h3>SI &#x26; 전살실 문제점</h3>
<ul>
<li>과정을 고민하지 않고 결과만 고민함</li>
<li>
<p>늘 찍어내는 결과물</p>
<ul>
<li>SI : 김밥 300개를 만든다</li>
<li>서비스 : 김밥 1줄을 300만원의 가치로 모두가 투입되어 고민한다</li>
</ul>
</li>
</ul>
<blockquote>
<p>환경이 받쳐주지 않는다고 해서 계속 안주 할 수 없다<br>
능력치 분배는 나의 몫!<br>
페이스북, 깃허브, 블로그 등</p>
</blockquote>
<h2>라이트닝 토크3. 개발자 이력서 작성 팁</h2>
<blockquote>
<p>김슬기님</p>
<ul>
<li>프로그래머스 DR</li>
<li><a href="https://programmers.co.kr/pages/resume-clinic-1907">이력서 클리닉 프로젝트 시즌2</a><br>
나의 실제 발자취와 현 상황을 잘 드러내자</li>
</ul>
</blockquote>
<h3>기술 스택 - 첫인상</h3>
<ul>
<li>본인의 주력 분야를 보여줌</li>
<li>동시에 능숙한 기술은 무엇이 있는지</li>
<li>키워드 중심으로 소개</li>
<li>내가 정말 쓸 줄 아는 기술 위주로, 내 주력 분야가 드러나도록</li>
<li>가장 상위 레벨의 기술 1~2개 정도만 핵심적으로 기재</li>
<li>
<p>상세 키워드는 프로젝트나 경력사항에서 소화를 하자</p>
<ul>
<li>납득이 가는 시나리오와 함께</li>
</ul>
</li>
<li>어떤 분야에 집중된 사람인지 나타내기 위한 첫인상 파트</li>
<li>단순 키워드 나열은 지식의 넓이가 아니라 혼란을 줌</li>
</ul>
<blockquote>
<p>이력서 스크리닝은 짧은 시간안에 이뤄지는데(3~10초) 이때 일목요연해야 한다</p>
</blockquote>
<h3>경력사항 - 당장 할 수 있는가</h3>
<ul>
<li>이 사람이 우리팀에 들어오면 바로 무슨 일을 할 수 있을지 판단하는 근거</li>
<li>팀 내에서의 역할, 개발한 기능 기여한 부분</li>
<li>세부 기술 등을 드러낼 수 있는 가장 중요한 파트</li>
<li>업무 성과 중심이 아니라, 실제로 뭘 했고, 당장 뭘 할 수 있는지 드러내기</li>
</ul>
<h3>프로젝트 - 부족함을 채울 최고의 비기</h3>
<p>신입에게만 중요할까?<br>
경력이 부족한 신입에게 당연히 중요<br>
본인 분야를 바꾸려는 경력자도 매우 중요<br>
부족함을 채울 수 있는 최고의 비법</p>
<br/>
<h4>프로젝트 접근 방식</h4>
<ul>
<li>
<p>가장 편한 접근</p>
<ul>
<li>따라하기(클로닝)</li>
<li>교육 과정 등에 등록해서 주어지는 과제 발전시키기</li>
</ul>
</li>
<li>
<p>조금 노력해야하는 접근</p>
<ul>
<li>팀을 꾸리고, 주제부터 고민 해가며 진행하기</li>
<li>기존 기술의 문제점을 보완하여 만들어보기</li>
</ul>
</li>
</ul>
<h3>교육, 활동 이력 - 프로젝트 다음으로 부족함을 채울 방법</h3>
<p>단순히 어떤 교육과정의 타이틀만을 나열하기 보다는 중요한 건 뭘 배웠냐!</p>
<ul>
<li>왜 배웠나? 뭐가 부족했나? 거기서 무엇을 배웠나?</li>
<li>배운 후 어떻게 활용하고 있나?</li>
<li>지원 직무와 관련된 부분을 어필한다</li>
</ul>]]></description><link>https://baek.dev/post/2/</link><guid isPermaLink="false">https://baek.dev/post/2/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Sat, 21 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;import ResizeImage from &apos;components/ResizeImage&apos;&lt;/p&gt;
&lt;p&gt;이력서는 가능하면 자주 업데이트해서 최대한 최신의 상태를 유지하라는 조언을 많이 들어 봤을 것입니다. 하지만 목전에 이직이 놓여 있지 않은 이상, 발등에 불이 떨어지지 않는 이상 업데이트하기 어렵습니다. 더욱이 이력서 파일을 열어놓고 드는 생각은 매번 같습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;어떻게 하면 이력서를 서류 탈락 되지 않고 면접까지 이어질 수 있을까?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;어떻게 써야 간결하고 일목요연하고 나의 부족함을 드러내지 않고 서류통과 될 수 있도록 구성할 수 있을까요? 이 부끄러운 이력서를 누군가에게 첨삭 받기도 민망하니 &lt;a href=&quot;https://blog.weirdx.io/&quot;&gt;이상한 모임&lt;/a&gt;에서 주최한 &lt;a href=&quot;https://www.notion.so/3-99-e9730dcfd84f4639a796ed202304b6c2&quot;&gt;제3회 99콘 &amp;#x3C;이력서&gt;&lt;/a&gt; 에 다녀와서 개선해보기로 했습니다. 99콘은 제 1회 수습생활편으로 처음 접하게 되었는데, 세션 만족도가 너무 좋아서 이번 이력서 편도 참여하게 되었습니다.&lt;/p&gt;
&lt;p&gt;세션을 듣고 나니 저 역시 비추된 이력서 요소가 몇 개 있었습니다. 그동안 까득했던 이력서 업데이트가 방향은 잡을 수 있게 되었고, 이 기회를 빌어 바로 시도해봐야겠습니다. 그럼 발표 내용을 요약하니 아직 이력서 업데이트를 하지 않은 분들은 아래 내용을 참고 해서 우리 같이 이참에 업데이트해봐요 :)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;제3회 99콘 &amp;#x3C;이력서&gt; 초대의 말&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;정신 차려요. 벌써 9월이라고요.&lt;br&gt;
3개월만 더 지나면 SF소설에서나 나오던 2020년이 된단 말이에요!&lt;br&gt;
경력자 세 명만 모여도 이력서 써야지 라는 말이 최소 2번은 나올 겁니다. 그만큼 경력관리에 필수적인 투두리스트라는 얘기인데요. 매달 업데이트하는 게 좋다는 것을 알면서도, 우리는 마치 연초에 기계적으로 반복하던 금연이나 다이어트 다짐처럼, 해야지 해야지 하는 말만 되뇌고 있던 것은 아닐까요.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://baek.dev/post/2/&quot;&gt;99콘 제2회 이력서편 후기 - 개발자 이력서 작성 방법&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;https://baek.dev/post/11/&quot;&gt;99콘 제4회 연봉협상편 후기 - 이직자, 재직자 모두에게 필요한 연봉협상 스킬&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;메인세션1. 7개의 타이틀, 7개의 기회&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;최지호님&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://forspacelab.com&quot;&gt;forspacelab.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;LG전자 → Naver → forspacelab&lt;/li&gt;
&lt;li&gt;다수의 면접관 경험&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3&gt;이 친구 꼭 뽑아야겠다고 생각한 경우&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;경험의 폭이 좁아도 생각의 폭이 넓은 지원자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;작은 공유하기 기능의 버튼을 만들어본 경험 밖에 없는 지원자였지만&lt;/li&gt;
&lt;li&gt;현재 자신이 속한 시스템의 문제점과 나아갈 방향까지 고민해본 지원자가&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;무언가 탐구하고 깊이 파고드는 성향이 보이는 지원자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IT는 도메인 지식이 계속 바뀌는 특성이 있고&lt;/li&gt;
&lt;li&gt;이직하거나 분야를 바꿀 일이 굉장히 많음&lt;/li&gt;
&lt;li&gt;계속 공부해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;사고가 유연하고 상대를 잘 배려할 수 있어야 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;폭포수가 아니고 애자일이기 때문에&lt;/li&gt;
&lt;li&gt;주변 사람들이 무얼하고 하는지 잘 챙겨줘야함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;똑똑한 지원자&lt;/li&gt;
&lt;li&gt;호기심이 많은 지원자&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;불합격 시킨 경우&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;본인이 한 일을 잘 설명하지 못하는 지원자&lt;/li&gt;
&lt;li&gt;본인의 기여도를 부풀리는 지원자&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;제품의 성격/단계 맞지 않는 성향의 지원자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기술 지향의 제품인데 컨텐츠 위주 경력인 경우&lt;/li&gt;
&lt;li&gt;웹브라우저는 기술 지향인데 컨텐츠 위주 경력인 경우 지원자는 마음에 들지만 합격 시킬 수 없었음&lt;/li&gt;
&lt;li&gt;초기 기획 단계인데 운영 위주의 경력인 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;좋은 평가를 주는 경우&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;얼마나 많이, 빠르게 배우려고 노력하는지 → 학습&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;끝까지 생각해보고 얘기하는지 → 고민의 깊이&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;오답이라도 끝까지 생각하는 지원자는 피드백을 어떻게든 줄 수 있음&lt;/li&gt;
&lt;li&gt;중간에 생각을 포기하는 사람은 질문자에게 일을 다시 되돌려 주는 것임&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;빈 곳을 주도적으로 채우는지 → 적극성과 배려&lt;/li&gt;
&lt;li&gt;두드러지는 강점 하나가 있는지 → 캐릭터의 매력&lt;/li&gt;
&lt;li&gt;글쓰기, 문서화의 노력 → 커뮤니케이션&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;이력서없이 이직하는 방법&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;나를 증명할 무엇인가를 만드세요&lt;br&gt;
나의 가치를 인정해줄 사람을 만나야 합니다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;레퍼런스를 쌓을 수 있는 일을 많이 할 것&lt;/li&gt;
&lt;li&gt;이런 행사에 자주 참여&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;시끄러운 분야에서 일을 할 것&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ex) 우아한 형제들 → 국감에도 불려가고 ..)a&lt;/li&gt;
&lt;li&gt;이런 회사에서 일을 하면 본인을 알릴 기회가 많아짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가장 중요!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가까운 동료에게 인정받을 수 있게 일 할 것&lt;/li&gt;
&lt;li&gt;언젠가 그 사람들이 나의 가치를 증명해 줌&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;꿀팁 🍯&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;링크드인에 영어로 이력을 자세히 남길 것&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;구조화된 이력서를 있어 보이게 만들 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이력서를 달라는 사람들에게 링크드인 링크를 전달&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;링크드인 이력서를 pdf로 익스포트 할 수 있음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파일로 이력서를 제출하라는 회사는 링크드인 pdf로 전달&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://speakerdeck.com/weirdx/99kon-7gaeyi-taiteul-7beonyi-gihoe-coejiho&quot;&gt;발표자료&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;메인세션2. 주니어 개발자의 이력서 쓰기&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;이동욱님&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;우아한 형제들&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jojoldu.tistory.com&quot;&gt;블로그 - 기억보단 기록을&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jojoldu.github.io/&quot;&gt;공개 이력서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3&gt;본인 프로필&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이름, 이메일, 깃허브 → 필수&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;주니어 개발자는 깃허브 계정 필수&lt;/li&gt;
&lt;li&gt;어떻게 채워야 할지 모르겠다면? TIL부터 시작하자&lt;/li&gt;
&lt;li&gt;졸업 작품이나 국비하면서 만든것을 업로드&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;블로그 → 준필수&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;구글에서 검색이 잘 되지 않는 네이버 블로그는 개발자가 좋아하진 않음&lt;/li&gt;
&lt;li&gt;티스토리, 깃허브, 미디엄 등 구글에서 검색되는 플랫폼 이용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;사이드 프로젝트 있으면 가산점&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;링크드인, 페이스북 등 SNS 계정 → 선택&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개발자에게 큰 매리트는 없음&lt;/li&gt;
&lt;li&gt;깃헙이나 블로그가 대체&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;서류 이 도박을 하도록 만들지 마세요&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;본인 소개&lt;/h3&gt;
&lt;br/&gt;
&lt;h4&gt;Summary&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;내가 어떤 개발자인지 나타낼 수 있도록 키워드를 선택해서 요약 소개&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;키워드 : 회사와 팀에 도움이 되는 사람, 자동화를 좋아하는 사람&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;어떤 경험을 해왔는지&lt;/li&gt;
&lt;li&gt;어떤 생각을 갖고 있는지&lt;/li&gt;
&lt;li&gt;평소에 어떤 노력을 하고 있는지&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;최대한 숫자로 표현&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;대용량 / 대규모 → RPM/TPS/PV/MAU 등 구체적 숫자가 판단하는데 도움이 됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;h4&gt;피해야할 단어&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;열정/노력/도전 정신 등 이거 없는 분 계시나요?&lt;/li&gt;
&lt;li&gt;증명할 수 있는 단어를 선택하자 -&gt; 숫자와 기록&lt;/li&gt;
&lt;li&gt;세미나 좋아하고, 교육 좋아하면 후기도 없고 블로그도 없으면 어떻게 증명 할까요?&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;h3&gt;기술 스택&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1~2번 써본 기술은 언급하진 않아야 함&lt;/li&gt;
&lt;li&gt;직군에 맞게 필요한 주력 기술만 서술&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그동안 해온 기술과 다르다면?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;난 그동안 파이썬만 써왔는데 내가 가고 싶은 회사가 자바 스프링이면?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;러닝커브&lt;/strong&gt;를 강조하는 이력서로&lt;/li&gt;
&lt;li&gt;3개월 밖에 안배웠지만 사용 서비스 오픈해본 경험이 있음을 어필&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;경력/프로젝트&lt;/h3&gt;
&lt;br/&gt;
&lt;h4&gt;프로젝트&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;질문하면 답변할 수 있는 프로젝트만&lt;/li&gt;
&lt;li&gt;맡은 개발 파트 요약&lt;/li&gt;
&lt;li&gt;프로젝트에서 특히 강조하고 싶은 것&lt;/li&gt;
&lt;li&gt;성과/실적도 있다면 추가&lt;/li&gt;
&lt;li&gt;가능하면 증명 가능한 링크&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;h4&gt;경력&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;근무기간&lt;/li&gt;
&lt;li&gt;프로젝트가 있으니 요약 정리&lt;/li&gt;
&lt;li&gt;프로젝트 성과 외 언급 할것들&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Q. 경력 프로젝트가 너무 적으면? → 교육/스터디로 양념을 하자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;백엔드 개발자로써 필요한게 있을때 학원 같은 곳을 많이 활용&lt;/li&gt;
&lt;li&gt;증거 필수, 블로그 후기&lt;/li&gt;
&lt;li&gt;8주면 짜리 교육이면, 매주 후기를 남김&lt;/li&gt;
&lt;li&gt;스터디는 백엔드 개발자 기준&lt;/li&gt;
&lt;li&gt;기본 : 테스트 코드 / OOP / 클린 코드 필수&lt;/li&gt;
&lt;li&gt;확장 : 쿼리 튜닝, 리눅스&lt;/li&gt;
&lt;li&gt;혼자서 MSA 연습중이라는 말은 하지 말자&lt;/li&gt;
&lt;li&gt;주니어 개발자들에게 기대하는 건 탄탄한 기본기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Q. start 많은 오픈소스는 효과가 있다?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;코드가 없는 저장소는 효과가 없다.&lt;/li&gt;
&lt;li&gt;spring-boot-aws-mock&lt;/li&gt;
&lt;li&gt;start는 적어도 코드가 있는 이 저장소가 더 관심이 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;포트폴리오&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://chanywa.com/308&quot;&gt;chanywa.com/308&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개발자로서 어떤 역량을 발휘한 작품인가?&lt;/li&gt;
&lt;li&gt;작품의 호응도를 자신의 개발 실력과 혼동하는 것&lt;/li&gt;
&lt;li&gt;아름답게 만드는 것보다는 개발적으로 어떻게 해결하는지가 무기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;졸업작품 전시회 하듯이 포트폴리오하면 효과가 없다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기능, UI 기획 등등이 강조된 PPT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;서류 검토하시는 분들은 코드가 보고 싶다..!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TC를 작성하는지, OOP를 아는지, commit message 를 어떻게 작성하는지&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;보안 문제가 없다면 github에 올린다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;README에 실행방법, 소개까지 써주자&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;꿀팁 🍯&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;문제 해결 사례를 언급&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;학교, 국비, 스터디 하면서 만났던 문제를 해결한 사례를 정리하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jojoldu.tistory.com/40&quot;&gt;tcpdump로 post 데이터 확인하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;어떤 문제의 난이도, 즐기는지 이런걸 알 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;마무리&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;잘 쓰려면 잘 살아야 한다.&lt;br&gt;
강원국의 글쓰기 / p.317&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이력서 잘쓰려면 좋은 개발자로 잘 살아야 한다.&lt;br&gt;
좋은 개발자가 되기 위한 노력이 좋은 이력서가 우선 되선 안된다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://speakerdeck.com/weirdx/99con-junieo-gaebaljayi-iryeogseo-sseugi-idongug&quot;&gt;발표자료&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;패널 토크&lt;/h2&gt;
&lt;p&gt;이 부분은 사전에 받은 질문에 대해 두 연사가 답변을 하는 세션이었다.&lt;/p&gt;
&lt;br/&gt;
&lt;h3&gt;Q. 어느덧 쌓인 연차가 꽤 되어, 주니어때 했던 일들이 기억이 나지 않습니다. 특히 신입 때 햇던 것들은 기술에 대한 변별력이 없는데, 어떻게 기술해야 할까요?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A. 이동욱님&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기억 안나는데 써봤자 답변 못하면 감점이 된다&lt;/li&gt;
&lt;li&gt;쓰기는 하는데 강조하지는 않을 것 같다&lt;/li&gt;
&lt;li&gt;현재 업무하는 것에 대해서 어필하는게 좋은 것 같다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A. 최지호님&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;본인이 생각하기에 기억이 나지 않거나 변별력이 없다면 버려도 될 것 같다&lt;/li&gt;
&lt;li&gt;면접관 입장에서도 별로 의미가 없는 일이다&lt;/li&gt;
&lt;li&gt;조각적으로 생각나고 의미가 있는 일이라면 구체적이진 않지만 그게 지금의 나를 어떻게 만들었나 퍼즐이 만들어지면 좋을 것 같다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;h3&gt;Q. 지원동기를 쓰라는 이력서가 많은데, 회사만을 위한 맞춤 지원동기를 작성하는 팁이 있을까요?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A. 최지호님&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사람이 싫어서 퇴사해서 이직하면 안된다&lt;/li&gt;
&lt;li&gt;내가 하고 싶은 일이 있어서 거기로 가야된다&lt;/li&gt;
&lt;li&gt;내가하고 싶은 일이 무엇인지 명확히 드러나고&lt;/li&gt;
&lt;li&gt;어떤 프로덕트를 만들고 싶은지&lt;/li&gt;
&lt;li&gt;이런게 없다면 정성이 느껴지지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;h3&gt;Q. 회사업무만으로는 지원하는 직무에 부족하다고 느낄 때, 사이드프로젝트로 어필해도 괜찮을까요?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A. 이동욱님&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;너무 좋으나 사이드프로젝트가 코드로만 끝나지 않고, 웹이나 앱으로 도메인까지 붙여서 있으면 더 좋다&lt;/li&gt;
&lt;li&gt;남는 시간에 내가 부족한걸 채우기위해 공부했다는 것인데 가산점이다!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;h3&gt;Q. 백엔드 개발을 하다가 프론트로 전직했는데, 다시 프론트 개발자로 지원할 때, 이전 백엔드 경력을 써야하나요? 앱을 공부한적이 잇는데 직무과 연관없는 것들을 적는게 도움이 될까?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A. 이동욱님&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;써도 무방하지만, 결국 프론트 개발에 백엔드와 앱개발이 어떻게 도움이 되었는지를 어필한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;h3&gt;Q. 다른 직무로 전직하려고 합니다. 목표하는 직무에 대한 업무 경험이 없는데, 어떻게 보완해야 할까요&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A. 최지호님&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;경험이 없으면 배우고 경험해봐야한다&lt;/li&gt;
&lt;li&gt;교육을 수강한다&lt;/li&gt;
&lt;li&gt;그 분야에 어떻게든 뛰어드는 것 말고는 방법이 없다&lt;/li&gt;
&lt;li&gt;그리고 그것을 업무에 녹인다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Q. 저와 맞는 회사인지 어떻게 알 수 있나요?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A. 이동욱님&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;패를 뒤집어 보기 전까지는 모르지만&lt;/li&gt;
&lt;li&gt;나랑 맞는 회사는 어떤 조건들을 가지고 있는지 리스트업 해보자&lt;/li&gt;
&lt;li&gt;백퍼센트 맞는 회사는 없다, 중요도를 선별하자&lt;/li&gt;
&lt;li&gt;감정적으로 판단하지 말자&lt;/li&gt;
&lt;li&gt;사람이 싫으면 팀을 옮기면 된다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A. 최지호님&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내 성향이 어디에 있는지 잘 아는게 중요하.&lt;/li&gt;
&lt;li&gt;내향적인지 외향적인지&lt;/li&gt;
&lt;li&gt;좋은 동료와 좋은 일이 있을 뿐이지, 좋은 회사는 없다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Q. 프로젝트 중간에 퇴사하면 민폐가 되지 않나요?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A. 최지호님&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그건 니가 걱정할 일이 아니다&lt;/li&gt;
&lt;li&gt;그거 걱정하라고 매니저가 있는 것이다&lt;/li&gt;
&lt;li&gt;그냥 팽겨치고 나가는 건 평판에 문제가 생길 수 있으므로&lt;/li&gt;
&lt;li&gt;문제가 생길 것 같으면 매니저에게 빨리 이야기하는게 답이다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_002_bm.png&quot; alt=&quot;우아한 형제들 작은집에서&quot;&gt;&lt;/p&gt;
&lt;h2&gt;라이트닝 토크1. 미래를 준비하는 자세&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;신예진님&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;에멘탈 서비스 기획자&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3&gt;꿀팁 🍯&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;이력서의 핵심과 상세를 나누기&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;꼭 전달하고 싶은 핵심 되는 요소를 상단에 짧고 집중력 있게&lt;/li&gt;
&lt;li&gt;채용담당자는 모든 이력서를 집중력 있게 읽지 않는다&lt;/li&gt;
&lt;li&gt;정리된 상세 영역은 또 하나의 포트폴리오&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이전 회사 포트폴리오를 넣는다면 보안에 신경 쓰기&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기업 보안은 생각보다 중요하다&lt;/li&gt;
&lt;li&gt;전에 회사를 먼저 비난하는 것은 자제&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;지원하는 회사에 관련된 맞춤 내용을 넣기&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://speakerdeck.com/weirdx/99con-miraereul-junbihaneun-jase-sinyejin&quot;&gt;발표자료&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;라이트닝 토크2. SI 탈출기&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;황건구님&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;마켓컬리&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hwang.gg&quot;&gt;blog.hwang.gg&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3&gt;SI ~7년차&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;레거시, 사수없음, 저임금, 상사의 회사 사정에 대한 거짓말&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;SI &amp;#x26; 전살실 문제점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;과정을 고민하지 않고 결과만 고민함&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;늘 찍어내는 결과물&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SI : 김밥 300개를 만든다&lt;/li&gt;
&lt;li&gt;서비스 : 김밥 1줄을 300만원의 가치로 모두가 투입되어 고민한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;환경이 받쳐주지 않는다고 해서 계속 안주 할 수 없다&lt;br&gt;
능력치 분배는 나의 몫!&lt;br&gt;
페이스북, 깃허브, 블로그 등&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;라이트닝 토크3. 개발자 이력서 작성 팁&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;김슬기님&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로그래머스 DR&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/pages/resume-clinic-1907&quot;&gt;이력서 클리닉 프로젝트 시즌2&lt;/a&gt;&lt;br&gt;
나의 실제 발자취와 현 상황을 잘 드러내자&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3&gt;기술 스택 - 첫인상&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;본인의 주력 분야를 보여줌&lt;/li&gt;
&lt;li&gt;동시에 능숙한 기술은 무엇이 있는지&lt;/li&gt;
&lt;li&gt;키워드 중심으로 소개&lt;/li&gt;
&lt;li&gt;내가 정말 쓸 줄 아는 기술 위주로, 내 주력 분야가 드러나도록&lt;/li&gt;
&lt;li&gt;가장 상위 레벨의 기술 1~2개 정도만 핵심적으로 기재&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;상세 키워드는 프로젝트나 경력사항에서 소화를 하자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;납득이 가는 시나리오와 함께&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;어떤 분야에 집중된 사람인지 나타내기 위한 첫인상 파트&lt;/li&gt;
&lt;li&gt;단순 키워드 나열은 지식의 넓이가 아니라 혼란을 줌&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;이력서 스크리닝은 짧은 시간안에 이뤄지는데(3~10초) 이때 일목요연해야 한다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;경력사항 - 당장 할 수 있는가&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;이 사람이 우리팀에 들어오면 바로 무슨 일을 할 수 있을지 판단하는 근거&lt;/li&gt;
&lt;li&gt;팀 내에서의 역할, 개발한 기능 기여한 부분&lt;/li&gt;
&lt;li&gt;세부 기술 등을 드러낼 수 있는 가장 중요한 파트&lt;/li&gt;
&lt;li&gt;업무 성과 중심이 아니라, 실제로 뭘 했고, 당장 뭘 할 수 있는지 드러내기&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;프로젝트 - 부족함을 채울 최고의 비기&lt;/h3&gt;
&lt;p&gt;신입에게만 중요할까?&lt;br&gt;
경력이 부족한 신입에게 당연히 중요&lt;br&gt;
본인 분야를 바꾸려는 경력자도 매우 중요&lt;br&gt;
부족함을 채울 수 있는 최고의 비법&lt;/p&gt;
&lt;br/&gt;
&lt;h4&gt;프로젝트 접근 방식&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가장 편한 접근&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;따라하기(클로닝)&lt;/li&gt;
&lt;li&gt;교육 과정 등에 등록해서 주어지는 과제 발전시키기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;조금 노력해야하는 접근&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팀을 꾸리고, 주제부터 고민 해가며 진행하기&lt;/li&gt;
&lt;li&gt;기존 기술의 문제점을 보완하여 만들어보기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;교육, 활동 이력 - 프로젝트 다음으로 부족함을 채울 방법&lt;/h3&gt;
&lt;p&gt;단순히 어떤 교육과정의 타이틀만을 나열하기 보다는 중요한 건 뭘 배웠냐!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;왜 배웠나? 뭐가 부족했나? 거기서 무엇을 배웠나?&lt;/li&gt;
&lt;li&gt;배운 후 어떻게 활용하고 있나?&lt;/li&gt;
&lt;li&gt;지원 직무와 관련된 부분을 어필한다&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Github 블로그에 개인 도메인 연결해보고 sub github pages 셋팅하기]]></title><description><![CDATA[<p>Github는 정적 페이지 사이트를 제공하는데, 이를 활용하면 블로그 사이트를 운영할 수 있습니다..
인터넷 서핑을 하다 종종 만나게 되는 <strong><a href="https://baekdev.github.io">baekdev.github.io</a></strong> 와 같은 주소들이 모두 <a href="https://help.github.com/en/articles/what-is-github-pages">github pages</a> 를 이용한 사이트입니다.
이 주소를 대부분 그대로 이용하기도 하지만, 개인 브랜딩을 위해서 커스텀 도메인을 적용하기도 합니다.</p>
<p>그럼 우리도 함께 적용해보고 깃허브 서브 페이지까지 어떻게 적용할 수 있을지 시작해보겠습니다.</p>
<h2>1. 도메인을 구입</h2>
<p>먼저 내가 갖고 싶은 도메인을 구입합니다.<br>
국내는 <a href="https://whois.co.kr/">후이즈</a> 또는 <a href="https://www.gabia.com/">가비아</a> 가 등이 있고, 해외는 <a href="https://kr.godaddy.com/">goDaddy</a>, <a href="https://www.name.com/">Name.com</a> 등이 있습니다. 올 초부터는 구글에서 <code>.dev</code> 도메인 서비스를 개시해서 구매 가능합니다. <code>.dev</code> 도메인은 개발자에게 특화된 도메인이라 좀 더 개발 특성을 나타내는데 좋습니다.<br>
구입한 도메인은 아무것도 설정되어 있지 않기때문에 브라우저에 구입한 도메인 접속 시도를 해도 연결 실패 메시지가 뜰 것입니다. 그럼 이제 바로 설정을 시작해보겠습니다!</p>
<h2>2. 도메인 DNS 설정</h2>
<p>구입한 도메인을 깃허브로 연결하기 위해서는 DNS 설정을 해줘야 합니다.</p>
<h3>A type 추가</h3>
<p><img src="https://baek.dev/assets/images/post/2019/2019_001_gabia_002.png" alt="A type 추가"></p>
<p>위 ip들은 앞서 말한 github pages 호스팅 ip주소입니다. 위 중 1개만 추가해도 무방합니다.<br>
각자 구입한 도메인 구매 사이트에서 DNS 설정을 하도록 하겠습니다.</p>
<blockquote>
<p><strong>ip list</strong></p>
<ul>
<li>185.199.108.153</li>
<li>185.199.109.153</li>
<li>185.199.110.153</li>
<li>185.199.111.153</li>
</ul>
</blockquote>
<h2>3. github pages repository 설정</h2>
<p>각자 만든 깃허브 페이지 레포지토리의 셋팅 화면으로 이동합니다.</p>
<p><img src="https://baek.dev/assets/images/post/2019/2019_001_github_001.png" alt="github pages repository setting"></p>
<p>아래로 스크롤을 쭈욱 내리다보면 <code>Github Pages</code> 섹션이 나옵니다. <code>Custom Domain</code> 란에 내가 설정한 CNAME대로 값을 입력합니다. 저는 <code>baek.dev</code> 으로 설정했습니다.<br>
참고로 깃허브는 https를 제공하는데, 커스텀 도메인을 적용하고 나면 일정 시간 뒤에 <code>Enforce HTTPS</code> 를 적용할 수 있습니다.<br>
HTTPS를 적용하면 js, css 등 파일 경로가 http로 적용되어 깨질 수가 있습니다. 이 경우 <a href="https://help.github.com/en/articles/securing-your-github-pages-site-with-https">링크</a> 를 통해 확인하여 수정하면 됩니다.</p>
<h2>4. 다른 github page를 활용하여 sub page를 운영</h2>
<p>하나의 깃허브 계정에서 여러 개의 github pages를 운영 할 수 있습니다.<br>
깃헙에서 서브 페이지로 운영할 신규 저장소를 추가합니다. <strong><em>repository name이 sub pages 주소</em></strong> 가 되므로 원하는 이름을 입력해주고 생성합니다.</p>
<p><img src="https://baek.dev/assets/images/post/2019/2019_001_github_004.png" alt="Add new repository"><br>
Github Pages 영역에서 Branch를 master로 선택하면 해당 repository를 baekdev.github.io/TIL의 서브페이지로 셋팅이 됩니다.<br>
단, 우리는 baekdev.github.io를 baek.dev 커스텀 도메인으로 연결했기 때문에, 나의 커스텀 도메인의 하위 페이지로 셋팅이 된 alert을 확인 할 수 있습니다. <a href="https://baek.dev/TIL/">baek.dev/TIL</a></p>
<p>이와 같은 sub page를 추가함으로써 <strong>하나의 계정에 여러개의 깃헙 페이지를 운영</strong> 할 수 있으니 이력서나, 포트폴리오 또는 구인 공고 같은 static page를 활용해 볼 수 있는 장점이 될 것입니다.</p>
<p>그럼 이제 새로운 도메인으로 블로깅을 시작해보세요 😀</p>]]></description><link>https://baek.dev/post/1/</link><guid isPermaLink="false">https://baek.dev/post/1/</guid><dc:creator><![CDATA[BAEKDEV]]></dc:creator><pubDate>Wed, 11 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Github는 정적 페이지 사이트를 제공하는데, 이를 활용하면 블로그 사이트를 운영할 수 있습니다..
인터넷 서핑을 하다 종종 만나게 되는 &lt;strong&gt;&lt;a href=&quot;https://baekdev.github.io&quot;&gt;baekdev.github.io&lt;/a&gt;&lt;/strong&gt; 와 같은 주소들이 모두 &lt;a href=&quot;https://help.github.com/en/articles/what-is-github-pages&quot;&gt;github pages&lt;/a&gt; 를 이용한 사이트입니다.
이 주소를 대부분 그대로 이용하기도 하지만, 개인 브랜딩을 위해서 커스텀 도메인을 적용하기도 합니다.&lt;/p&gt;
&lt;p&gt;그럼 우리도 함께 적용해보고 깃허브 서브 페이지까지 어떻게 적용할 수 있을지 시작해보겠습니다.&lt;/p&gt;
&lt;h2&gt;1. 도메인을 구입&lt;/h2&gt;
&lt;p&gt;먼저 내가 갖고 싶은 도메인을 구입합니다.&lt;br&gt;
국내는 &lt;a href=&quot;https://whois.co.kr/&quot;&gt;후이즈&lt;/a&gt; 또는 &lt;a href=&quot;https://www.gabia.com/&quot;&gt;가비아&lt;/a&gt; 가 등이 있고, 해외는 &lt;a href=&quot;https://kr.godaddy.com/&quot;&gt;goDaddy&lt;/a&gt;, &lt;a href=&quot;https://www.name.com/&quot;&gt;Name.com&lt;/a&gt; 등이 있습니다. 올 초부터는 구글에서 &lt;code&gt;.dev&lt;/code&gt; 도메인 서비스를 개시해서 구매 가능합니다. &lt;code&gt;.dev&lt;/code&gt; 도메인은 개발자에게 특화된 도메인이라 좀 더 개발 특성을 나타내는데 좋습니다.&lt;br&gt;
구입한 도메인은 아무것도 설정되어 있지 않기때문에 브라우저에 구입한 도메인 접속 시도를 해도 연결 실패 메시지가 뜰 것입니다. 그럼 이제 바로 설정을 시작해보겠습니다!&lt;/p&gt;
&lt;h2&gt;2. 도메인 DNS 설정&lt;/h2&gt;
&lt;p&gt;구입한 도메인을 깃허브로 연결하기 위해서는 DNS 설정을 해줘야 합니다.&lt;/p&gt;
&lt;h3&gt;A type 추가&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_001_gabia_002.png&quot; alt=&quot;A type 추가&quot;&gt;&lt;/p&gt;
&lt;p&gt;위 ip들은 앞서 말한 github pages 호스팅 ip주소입니다. 위 중 1개만 추가해도 무방합니다.&lt;br&gt;
각자 구입한 도메인 구매 사이트에서 DNS 설정을 하도록 하겠습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;ip list&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;185.199.108.153&lt;/li&gt;
&lt;li&gt;185.199.109.153&lt;/li&gt;
&lt;li&gt;185.199.110.153&lt;/li&gt;
&lt;li&gt;185.199.111.153&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;3. github pages repository 설정&lt;/h2&gt;
&lt;p&gt;각자 만든 깃허브 페이지 레포지토리의 셋팅 화면으로 이동합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_001_github_001.png&quot; alt=&quot;github pages repository setting&quot;&gt;&lt;/p&gt;
&lt;p&gt;아래로 스크롤을 쭈욱 내리다보면 &lt;code&gt;Github Pages&lt;/code&gt; 섹션이 나옵니다. &lt;code&gt;Custom Domain&lt;/code&gt; 란에 내가 설정한 CNAME대로 값을 입력합니다. 저는 &lt;code&gt;baek.dev&lt;/code&gt; 으로 설정했습니다.&lt;br&gt;
참고로 깃허브는 https를 제공하는데, 커스텀 도메인을 적용하고 나면 일정 시간 뒤에 &lt;code&gt;Enforce HTTPS&lt;/code&gt; 를 적용할 수 있습니다.&lt;br&gt;
HTTPS를 적용하면 js, css 등 파일 경로가 http로 적용되어 깨질 수가 있습니다. 이 경우 &lt;a href=&quot;https://help.github.com/en/articles/securing-your-github-pages-site-with-https&quot;&gt;링크&lt;/a&gt; 를 통해 확인하여 수정하면 됩니다.&lt;/p&gt;
&lt;h2&gt;4. 다른 github page를 활용하여 sub page를 운영&lt;/h2&gt;
&lt;p&gt;하나의 깃허브 계정에서 여러 개의 github pages를 운영 할 수 있습니다.&lt;br&gt;
깃헙에서 서브 페이지로 운영할 신규 저장소를 추가합니다. &lt;strong&gt;&lt;em&gt;repository name이 sub pages 주소&lt;/em&gt;&lt;/strong&gt; 가 되므로 원하는 이름을 입력해주고 생성합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://baek.dev/assets/images/post/2019/2019_001_github_004.png&quot; alt=&quot;Add new repository&quot;&gt;&lt;br&gt;
Github Pages 영역에서 Branch를 master로 선택하면 해당 repository를 baekdev.github.io/TIL의 서브페이지로 셋팅이 됩니다.&lt;br&gt;
단, 우리는 baekdev.github.io를 baek.dev 커스텀 도메인으로 연결했기 때문에, 나의 커스텀 도메인의 하위 페이지로 셋팅이 된 alert을 확인 할 수 있습니다. &lt;a href=&quot;https://baek.dev/TIL/&quot;&gt;baek.dev/TIL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이와 같은 sub page를 추가함으로써 &lt;strong&gt;하나의 계정에 여러개의 깃헙 페이지를 운영&lt;/strong&gt; 할 수 있으니 이력서나, 포트폴리오 또는 구인 공고 같은 static page를 활용해 볼 수 있는 장점이 될 것입니다.&lt;/p&gt;
&lt;p&gt;그럼 이제 새로운 도메인으로 블로깅을 시작해보세요 😀&lt;/p&gt;</content:encoded></item></channel></rss>